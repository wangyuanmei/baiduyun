!function (t, e) {
    "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
}(this, function () {
    var t, e;
    !function () {
        function i(t, e) {
            if (!e)return t;
            if (0 === t.indexOf(".")) {
                var i = e.split("/"), n = t.split("/"), r = i.length - 1, a = n.length, o = 0, s = 0;
                t:for (var l = 0; a > l; l++)switch (n[l]) {
                    case"..":
                        if (!(r > o))break t;
                        o++, s++;
                        break;
                    case".":
                        s++;
                        break;
                    default:
                        break t
                }
                return i.length = r - o, n = n.slice(s), i.concat(n).join("/")
            }
            return t
        }

        function n(t) {
            function e(e, o) {
                if ("string" == typeof e) {
                    var s = n[e];
                    return s || (s = a(i(e, t)), n[e] = s), s
                }
                e instanceof Array && (o = o || function () {
                }, o.apply(this, r(e, o, t)))
            }

            var n = {};
            return e
        }

        function r(e, n, r) {
            for (var s = [], l = o[r], c = 0, u = Math.min(e.length, n.length); u > c; c++) {
                var h, d = i(e[c], r);
                switch (d) {
                    case"require":
                        h = l && l.require || t;
                        break;
                    case"exports":
                        h = l.exports;
                        break;
                    case"module":
                        h = l;
                        break;
                    default:
                        h = a(d)
                }
                s.push(h)
            }
            return s
        }

        function a(t) {
            var e = o[t];
            if (!e)throw new Error("No " + t);
            if (!e.defined) {
                var i = e.factory, n = i.apply(this, r(e.deps || [], i, t));
                "undefined" != typeof n && (e.exports = n), e.defined = 1
            }
            return e.exports
        }

        var o = {};
        e = function (t, e, i) {
            o[t] = {id: t, deps: e, factory: i, defined: 0, exports: {}, require: n(t)}
        }, t = n("")
    }();
    var i = "ordinal", n = "category", r = "../core/util", a = "undefined", o = "createElement", s = "normal", l = "stroke", c = "lineWidth", u = "applyTransform", h = "concat", d = "getExtent", f = "contain", p = "opacity", v = "position", g = "center", m = "middle", y = "getBoundingRect", x = "getFont", _ = "textStyle", b = "function", w = "indexOf", M = "isArray", T = "replace", S = "seriesIndex", C = "target", z = "getData", A = "splice", L = "series", P = "length", k = "defaults", D = "extend", I = "isObject", R = "create", B = "height", E = "bottom", O = "ignore", N = "getHeight", F = "getWidth", V = "getModel", G = "resize", q = "string", H = "prototype", W = "toLowerCase", X = "filter", Z = "transform", j = "zrender/core/util", U = "require";
    e("echarts/echarts", [U, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", j, "zrender/tool/color", "zrender/core/env", "zrender/mixin/Eventful", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./util/number", "./util/format", "zrender/core/matrix", "zrender/core/vector"], function (t) {
        function e(t) {
            return function (e, i, n) {
                e = e && e[W](), te[H][t].call(this, e, i, n)
            }
        }

        function i() {
            te.call(this)
        }

        function n(t, e, n) {
            n = n || {}, typeof e === q && (e = pe[e]), e && ee(de, function (t) {
                t(e)
            }), this.id, this.group, this._dom = t, this._zr = Q.init(t, {
                renderer: n.renderer || "canvas",
                devicePixelRatio: n.devicePixelRatio
            }), this._theme = $.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new v(this), this._coordSysMgr = new g, te.call(this), this._messageCenter = new i, this._initEvents(), this[G] = $.bind(this[G], this)
        }

        function r(t, e) {
            var i = this._model;
            i && i.eachComponent({mainType: "series", query: e}, function (n) {
                var r = this._chartsMap[n.__viewId];
                r && r.__alive && r[t](n, i, this._api, e)
            }, this)
        }

        function a(t, e, i) {
            var n = this._api;
            ee(this._componentsViews, function (r) {
                var a = r.__model;
                r[t](a, e, n, i), d(a, r)
            }, this), e.eachSeries(function (r) {
                var a = this._chartsMap[r.__viewId];
                a[t](r, e, n, i), d(r, a)
            }, this)
        }

        function o(t, e) {
            for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[P]; o++)n[o].__alive = !1;
            e[i ? "eachComponent" : "eachSeries"](function (t, o) {
                if (i) {
                    if (t === L)return
                } else o = t;
                var s = o.id + "_" + o.type, l = r[s];
                if (!l) {
                    var c = y.parseClassType(o.type), u = i ? _.getClass(c.main, c.sub) : U.getClass(c.sub);
                    if (!u)return;
                    l = new u, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
                }
                o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
            }, this);
            for (var o = 0; o < n[P];) {
                var s = n[o];
                s.__alive ? o++ : (a.remove(s.group), s.dispose(e, this._api), n[A](o, 1), delete r[s.__id])
            }
        }

        function s(t, e) {
            ee(ne, function (i) {
                ee(he[i] || [], function (i) {
                    i(t, e)
                })
            })
        }

        function l(t) {
            var e = {};
            t.eachSeries(function (t) {
                var i = t.get("stack"), n = t[z]();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r), e[i] = n
                }
            })
        }

        function c(t, e) {
            var i = this._api;
            ee(ue, function (n) {
                n(t, i, e)
            })
        }

        function u(t, e) {
            ee(ie, function (i) {
                ee(fe[i] || [], function (i) {
                    i(t, e)
                })
            })
        }

        function h(t, e) {
            var i = this._api;
            ee(this._componentsViews, function (n) {
                var r = n.__model;
                n.render(r, t, i, e), d(r, n)
            }, this), ee(this._chartsViews, function (t) {
                t.__alive = !1
            }, this), t.eachSeries(function (n) {
                var r = this._chartsMap[n.__viewId];
                r.__alive = !0, r.render(n, t, i, e), r.group.silent = !!n.get("silent"), d(n, r)
            }, this), ee(this._chartsViews, function (e) {
                e.__alive || e.remove(t, i)
            }, this)
        }

        function d(t, e) {
            var i = t.get("z"), n = t.get("zlevel");
            e.group.traverse(function (t) {
                null != i && (t.z = i), null != n && (t.zlevel = n)
            })
        }

        function f(t) {
            function e(t, e) {
                for (var i = 0; i < t[P]; i++) {
                    var n = t[i];
                    n[a] = e
                }
            }

            var i = 0, n = 1, r = 2, a = "__connectUpdateStatus";
            $.each(ce, function (o, s) {
                t._messageCenter.on(s, function (o) {
                    if (ge[t.group] && t[a] !== i) {
                        var s = t.makeActionFromEvent(o), l = [];
                        for (var c in ve) {
                            var u = ve[c];
                            u !== t && u.group === t.group && l.push(u)
                        }
                        e(l, i), ee(l, function (t) {
                            t[a] !== n && t.dispatchAction(s)
                        }), e(l, r)
                    }
                })
            })
        }

        var p = t("./model/Global"), v = t("./ExtensionAPI"), g = t("./CoordinateSystem"), m = t("./model/OptionManager"), y = t("./model/Component"), x = t("./model/Series"), _ = t("./view/Component"), U = t("./view/Chart"), Y = t("./util/graphic"), Q = t("zrender"), $ = t(j), K = t("zrender/tool/color"), J = t("zrender/core/env"), te = t("zrender/mixin/Eventful"), ee = $.each, ie = ["echarts", "chart", "component"], ne = [Z, X, "statistic"];
        i[H].on = e("on"), i[H].off = e("off"), i[H].one = e("one"), $.mixin(i, te);
        var re = n[H];
        re.getDom = function () {
            return this._dom
        }, re.getZr = function () {
            return this._zr
        }, re.setOption = function (t, e, i) {
            (!this._model || e) && (this._model = new p(null, null, this._theme, new m(this._api))), this._model.setOption(t, de), ae.prepareAndUpdate.call(this), !i && this._zr.refreshImmediately()
        }, re.setTheme = function () {
            console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
        }, re[V] = function () {
            return this._model
        }, re.getOption = function () {
            return this._model.getOption()
        }, re[F] = function () {
            return this._zr[F]()
        }, re[N] = function () {
            return this._zr[N]()
        }, re.getRenderedCanvas = function (t) {
            if (J.canvasSupported) {
                t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
                var e = this._zr, i = e.storage.getDisplayList();
                return $.each(i, function (t) {
                    t.stopAnimation(!0)
                }), e.painter.getRenderedCanvas(t)
            }
        }, re.getDataURL = function (t) {
            t = t || {};
            var e = t.excludeComponents, i = this._model, n = [], r = this;
            ee(e, function (t) {
                i.eachComponent({mainType: t}, function (t) {
                    var e = r._componentsMap[t.__viewId];
                    e.group[O] || (n.push(e), e.group[O] = !0)
                })
            });
            var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
            return ee(n, function (t) {
                t.group[O] = !1
            }), a
        }, re.getConnectedDataURL = function (t) {
            if (J.canvasSupported) {
                var e = this.group, i = Math.min, n = Math.max, r = 1 / 0;
                if (ge[e]) {
                    var a = r, o = r, s = -r, l = -r, c = [], u = t && t.pixelRatio || 1;
                    for (var h in ve) {
                        var d = ve[h];
                        if (d.group === e) {
                            var f = d.getRenderedCanvas($.clone(t)), p = d.getDom().getBoundingClientRect();
                            a = i(p.left, a), o = i(p.top, o), s = n(p.right, s), l = n(p[E], l), c.push({
                                dom: f,
                                left: p.left,
                                top: p.top
                            })
                        }
                    }
                    a *= u, o *= u, s *= u, l *= u;
                    var v = s - a, g = l - o, m = $.createCanvas();
                    m.width = v, m[B] = g;
                    var y = Q.init(m);
                    return ee(c, function (t) {
                        var e = new Y.Image({style: {x: t.left * u - a, y: t.top * u - o, image: t.dom}});
                        y.add(e)
                    }), y.refreshImmediately(), m.toDataURL("image/" + (t && t.type || "png"))
                }
                return this.getDataURL(t)
            }
        };
        var ae = {
            update: function (t) {
                var e = this._model, i = this._api, n = this._coordSysMgr;
                if (e) {
                    e.restoreData(), n[R](this._model, this._api), s.call(this, e, i), l.call(this, e), n.update(e, i), c.call(this, e, t), u.call(this, e, t), h.call(this, e, t);
                    var r = e.get("backgroundColor") || "transparent", a = this._zr.painter;
                    if (a.isSingleCanvas && a.isSingleCanvas())this._zr.configLayer(0, {clearColor: r}); else {
                        if (!J.canvasSupported) {
                            var o = K.parse(r);
                            r = K.stringify(o, "rgb"), 0 === o[3] && (r = "transparent")
                        }
                        r = r, this._dom.style.backgroundColor = r
                    }
                }
            }, updateView: function (t) {
                var e = this._model;
                e && (c.call(this, e, t), u.call(this, e, t), a.call(this, "updateView", e, t))
            }, updateVisual: function (t) {
                var e = this._model;
                e && (u.call(this, e, t), a.call(this, "updateVisual", e, t))
            }, updateLayout: function (t) {
                var e = this._model;
                e && (c.call(this, e, t), a.call(this, "updateLayout", e, t))
            }, highlight: function (t) {
                r.call(this, "highlight", t)
            }, downplay: function (t) {
                r.call(this, "downplay", t)
            }, prepareAndUpdate: function (t) {
                var e = this._model;
                o.call(this, "component", e), o.call(this, "chart", e), ae.update.call(this, t)
            }
        };
        re[G] = function () {
            this._zr[G]();
            var t = this._model && this._model.resetOption("media");
            ae[t ? "prepareAndUpdate" : "update"].call(this), this._loadingFX && this._loadingFX[G]()
        };
        var oe = t("./loading/default");
        re.showLoading = function (t, e) {
            $[I](t) && (e = t, t = "default"), this.hideLoading();
            var i = oe(this._api, e), n = this._zr;
            this._loadingFX = i, n.add(i)
        }, re.hideLoading = function () {
            this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null
        }, re.makeActionFromEvent = function (t) {
            var e = $[D]({}, t);
            return e.type = ce[t.type], e
        }, re.dispatchAction = function (t, e) {
            var i = le[t.type];
            if (i) {
                var n = i.actionInfo, r = n.update || "update", a = [t], o = !1;
                t.batch && (o = !0, a = $.map(t.batch, function (e) {
                    return e = $[k]($[D]({}, e), t), e.batch = null, e
                }));
                for (var s, l = [], c = "highlight" === t.type || "downplay" === t.type, u = 0; u < a[P]; u++) {
                    var h = a[u];
                    s = i.action(h, this._model), s = s || $[D]({}, h), s.type = n.event || s.type, l.push(s), c && ae[r].call(this, h)
                }
                "none" !== r && !c && ae[r].call(this, t), e || (s = o ? {
                    type: n.event || t.type,
                    batch: l
                } : l[0], this._messageCenter.trigger(s.type, s))
            }
        }, re.on = e("on"), re.off = e("off"), re.one = e("one");
        var se = ["click", "dblclick", "mouseover", "mouseout", "mousedown", "mouseup", "globalout"];
        re._initEvents = function () {
            ee(se, function (t) {
                this._zr.on(t, function (e) {
                    var i = this[V](), n = e[C];
                    if (n && null != n.dataIndex) {
                        var r = n.dataModel || i.getSeriesByIndex(n[S]), a = r && r.getDataParams(n.dataIndex, n.dataType) || {};
                        a.event = e, a.type = t, this.trigger(t, a)
                    } else n && n.eventData && this.trigger(t, n.eventData)
                }, this)
            }, this), ee(ce, function (t, e) {
                this._messageCenter.on(e, function (t) {
                    this.trigger(e, t)
                }, this)
            }, this)
        }, re.isDisposed = function () {
            return this._disposed
        }, re.clear = function () {
            this.setOption({}, !0)
        }, re.dispose = function () {
            this._disposed = !0;
            var t = this._api, e = this._model;
            ee(this._componentsViews, function (i) {
                i.dispose(e, t)
            }), ee(this._chartsViews, function (i) {
                i.dispose(e, t)
            }), this._zr.dispose(), delete ve[this.id]
        }, $.mixin(n, te);
        var le = [], ce = {}, ue = [], he = {}, de = [], fe = {}, pe = {}, ve = {}, ge = {}, me = new Date - 0, ye = new Date - 0, xe = "_echarts_instance_", _e = {
            version: "3.1.10",
            dependencies: {zrender: "3.1.0"}
        };
        return _e.init = function (t, e, i) {
            if (Q.version[T](".", "") - 0 < _e.dependencies.zrender[T](".", "") - 0)throw new Error("ZRender " + Q.version + " is too old for ECharts " + _e.version + ". Current version need ZRender " + _e.dependencies.zrender + "+");
            if (!t)throw new Error("Initialize failed: invalid dom.");
            var r = new n(t, e, i);
            return r.id = "ec_" + me++, ve[r.id] = r, t.setAttribute && t.setAttribute(xe, r.id), f(r), r
        }, _e.connect = function (t) {
            if ($[M](t)) {
                var e = t;
                t = null, $.each(e, function (e) {
                    null != e.group && (t = e.group)
                }), t = t || "g_" + ye++, $.each(e, function (e) {
                    e.group = t
                })
            }
            return ge[t] = !0, t
        }, _e.disConnect = function (t) {
            ge[t] = !1
        }, _e.dispose = function (t) {
            $.isDom(t) ? t = _e.getInstanceByDom(t) : typeof t === q && (t = ve[t]), t instanceof n && !t.isDisposed() && t.dispose()
        }, _e.getInstanceByDom = function (t) {
            var e = t.getAttribute(xe);
            return ve[e]
        }, _e.getInstanceById = function (t) {
            return ve[t]
        }, _e.registerTheme = function (t, e) {
            pe[t] = e
        }, _e.registerPreprocessor = function (t) {
            de.push(t)
        }, _e.registerProcessor = function (t, e) {
            if ($[w](ne, t) < 0)throw new Error("stage should be one of " + ne);
            var i = he[t] || (he[t] = []);
            i.push(e)
        }, _e.registerAction = function (t, e, i) {
            typeof e === b && (i = e, e = "");
            var n = $[I](t) ? t.type : [t, t = {event: e}][0];
            t.event = (t.event || n)[W](), e = t.event, le[n] || (le[n] = {action: i, actionInfo: t}), ce[e] = n
        }, _e.registerCoordinateSystem = function (t, e) {
            g.register(t, e)
        }, _e.registerLayout = function (t) {
            $[w](ue, t) < 0 && ue.push(t)
        }, _e.registerVisualCoding = function (t, e) {
            if ($[w](ie, t) < 0)throw new Error("stage should be one of " + ie);
            var i = fe[t] || (fe[t] = []);
            i.push(e)
        }, _e.extendChartView = function (t) {
            return U[D](t)
        }, _e.extendComponentModel = function (t) {
            return y[D](t)
        }, _e.extendSeriesModel = function (t) {
            return x[D](t)
        }, _e.extendComponentView = function (t) {
            return _[D](t)
        }, _e.setCanvasCreator = function (t) {
            $.createCanvas = t
        }, _e.registerVisualCoding("echarts", $.curry(t("./visual/seriesColor"), "", "itemStyle")), _e.registerPreprocessor(t("./preprocessor/backwardCompat")), _e.registerAction({
            type: "highlight",
            event: "highlight",
            update: "highlight"
        }, $.noop), _e.registerAction({
            type: "downplay",
            event: "downplay",
            update: "downplay"
        }, $.noop), _e.graphic = t("./util/graphic"), _e.number = t("./util/number"), _e.format = t("./util/format"), _e.matrix = t("zrender/core/matrix"), _e.vector = t("zrender/core/vector"), _e.util = {}, ee(["map", "each", X, w, "inherits", "reduce", X, "bind", "curry", M, "isString", I, "isFunction", D], function (t) {
            _e.util[t] = $[t]
        }), _e
    }), e("echarts/component/grid", [U, "../util/graphic", j, "../coord/cartesian/Grid", "./axis", "../echarts"], function (t) {
        var e = t("../util/graphic"), i = t(j);
        t("../coord/cartesian/Grid"), t("./axis"), t("../echarts").extendComponentView({
            type: "grid",
            render: function (t) {
                this.group.removeAll(), t.get("show") && this.group.add(new e.Rect({
                    shape: t.coordinateSystem.getRect(),
                    style: i[k]({fill: t.get("backgroundColor")}, t.getItemStyle()),
                    silent: !0
                }))
            }
        })
    }), e("echarts/component/legend", [U, "./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", "../echarts", "./legend/legendFilter"], function (t) {
        t("./legend/LegendModel"), t("./legend/legendAction"), t("./legend/LegendView");
        var e = t("../echarts");
        e.registerProcessor(X, t("./legend/legendFilter"))
    }), e("echarts/component/title", [U, "../echarts", "../util/graphic", "../util/layout"], function (t) {
        var e = t("../echarts"), i = t("../util/graphic"), n = t("../util/layout");
        e.extendComponentModel({
            type: "title",
            layoutMode: {type: "box", ignoreSize: !0},
            defaultOption: {
                zlevel: 0,
                z: 6,
                show: !0,
                text: "",
                target: "blank",
                subtext: "",
                subtarget: "blank",
                left: 0,
                top: 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                textStyle: {fontSize: 18, fontWeight: "bolder", color: "#333"},
                subtextStyle: {color: "#aaa"}
            }
        }), e.extendComponentView({
            type: "title", render: function (t, e, r) {
                if (this.group.removeAll(), t.get("show")) {
                    var a = this.group, o = t[V](_), s = t[V]("subtextStyle"), l = t.get("textAlign"), c = new i.Text({
                        style: {
                            text: t.get("text"),
                            textFont: o[x](),
                            fill: o.getTextColor(),
                            textBaseline: "top"
                        }, z2: 10
                    }), u = c[y](), h = t.get("subtext"), d = new i.Text({
                        style: {
                            text: h,
                            textFont: s[x](),
                            fill: s.getTextColor(),
                            y: u[B] + t.get("itemGap"),
                            textBaseline: "top"
                        }, z2: 10
                    }), f = t.get("link"), b = t.get("sublink");
                    c.silent = !f, d.silent = !b, f && c.on("click", function () {
                        window.open(f, "_" + t.get(C))
                    }), b && d.on("click", function () {
                        window.open(b, "_" + t.get("subtarget"))
                    }), a.add(c), h && a.add(d);
                    var w = a[y](), M = t.getBoxLayoutParams();
                    M.width = w.width, M[B] = w[B];
                    var T = n.getLayoutRect(M, {width: r[F](), height: r[N]()}, t.get("padding"));
                    l || (l = t.get("left") || t.get("right"), l === m && (l = g), "right" === l ? T.x += T.width : l === g && (T.x += T.width / 2)), a[v] = [T.x, T.y], c.setStyle("textAlign", l), d.setStyle("textAlign", l), w = a[y]();
                    var S = T.margin, z = t.getItemStyle(["color", p]);
                    z.fill = t.get("backgroundColor");
                    var A = new i.Rect({
                        shape: {
                            x: w.x - S[3],
                            y: w.y - S[0],
                            width: w.width + S[1] + S[3],
                            height: w[B] + S[0] + S[2]
                        }, style: z, silent: !0
                    });
                    i.subPixelOptimizeRect(A), a.add(A)
                }
            }
        })
    }), e("echarts/chart/bar", [U, j, "../coord/cartesian/Grid", "./bar/BarSeries", "./bar/BarView", "../layout/barGrid", "../echarts", "../component/grid"], function (t) {
        var e = t(j);
        t("../coord/cartesian/Grid"), t("./bar/BarSeries"), t("./bar/BarView");
        var i = t("../layout/barGrid"), n = t("../echarts");
        n.registerLayout(e.curry(i, "bar")), n.registerVisualCoding("chart", function (t) {
            t.eachSeriesByType("bar", function (t) {
                var e = t[z]();
                e.setVisual("legendSymbol", "roundRect")
            })
        }), t("../component/grid")
    }), e("echarts/component/tooltip", [U, "./tooltip/TooltipModel", "./tooltip/TooltipView", "../echarts"], function (t) {
        t("./tooltip/TooltipModel"), t("./tooltip/TooltipView"), t("../echarts").registerAction({
            type: "showTip",
            event: "showTip",
            update: "none"
        }, function () {
        }), t("../echarts").registerAction({type: "hideTip", event: "hideTip", update: "none"}, function () {
        })
    }), e("zrender/vml/vml", [U, "./graphic", "../zrender", "./Painter"], function (t) {
        t("./graphic"), t("../zrender").registerPainter("vml", t("./Painter"))
    }), e("echarts/scale/Time", [U, j, "../util/number", "../util/format", "./Interval"], function (t) {
        var e = t(j), i = t("../util/number"), n = t("../util/format"), r = t("./Interval"), a = r[H], o = Math.ceil, s = Math.floor, l = 1e3, c = 60 * l, u = 60 * c, h = 24 * u, d = function (t, e, i, n) {
            for (; n > i;) {
                var r = i + n >>> 1;
                t[r][2] < e ? i = r + 1 : n = r
            }
            return i
        }, p = r[D]({
            type: "time", getLabel: function (t) {
                var e = this._stepLvl, i = new Date(t);
                return n.formatTime(e[0], i)
            }, niceExtent: function (t, e, n) {
                var r = this._extent;
                if (r[0] === r[1] && (r[0] -= h, r[1] += h), r[1] === -1 / 0 && 1 / 0 === r[0]) {
                    var a = new Date;
                    r[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), r[0] = r[1] - h
                }
                this.niceTicks(t);
                var l = this._interval;
                e || (r[0] = i.round(s(r[0] / l) * l)), n || (r[1] = i.round(o(r[1] / l) * l))
            }, niceTicks: function (t) {
                t = t || 10;
                var e = this._extent, n = e[1] - e[0], r = n / t, a = v[P], l = d(v, r, 0, a), c = v[Math.min(l, a - 1)], u = c[2];
                if ("year" === c[0]) {
                    var h = n / u, f = i.nice(h / t, !0);
                    u *= f
                }
                var p = [o(e[0] / u) * u, s(e[1] / u) * u];
                this._stepLvl = c, this._interval = u, this._niceExtent = p
            }, parse: function (t) {
                return +i.parseDate(t)
            }
        });
        e.each([f, "normalize"], function (t) {
            p[H][t] = function (e) {
                return a[t].call(this, this.parse(e))
            }
        });
        var v = [["hh:mm:ss", 1, l], ["hh:mm:ss", 5, 5 * l], ["hh:mm:ss", 10, 10 * l], ["hh:mm:ss", 15, 15 * l], ["hh:mm:ss", 30, 30 * l], ["hh:mm\nMM-dd", 1, c], ["hh:mm\nMM-dd", 5, 5 * c], ["hh:mm\nMM-dd", 10, 10 * c], ["hh:mm\nMM-dd", 15, 15 * c], ["hh:mm\nMM-dd", 30, 30 * c], ["hh:mm\nMM-dd", 1, u], ["hh:mm\nMM-dd", 2, 2 * u], ["hh:mm\nMM-dd", 6, 6 * u], ["hh:mm\nMM-dd", 12, 12 * u], ["MM-dd\nyyyy", 1, h], ["week", 7, 7 * h], ["month", 1, 31 * h], ["quarter", 3, 380 * h / 4], ["half-year", 6, 380 * h / 2], ["year", 1, 380 * h]];
        return p[R] = function () {
            return new p
        }, p
    }), e("echarts/scale/Log", [U, j, "./Scale", "../util/number", "./Interval"], function (t) {
        var e = t(j), i = t("./Scale"), n = t("../util/number"), r = t("./Interval"), a = i[H], o = r[H], s = Math.floor, l = Math.ceil, c = Math.pow, u = 10, h = Math.log, p = i[D]({
            type: "log",
            getTicks: function () {
                return e.map(o.getTicks.call(this), function (t) {
                    return n.round(c(u, t))
                })
            },
            getLabel: o.getLabel,
            scale: function (t) {
                return t = a.scale.call(this, t), c(u, t)
            },
            setExtent: function (t, e) {
                t = h(t) / h(u), e = h(e) / h(u), o.setExtent.call(this, t, e)
            },
            getExtent: function () {
                var t = a[d].call(this);
                return t[0] = c(u, t[0]), t[1] = c(u, t[1]), t
            },
            unionExtent: function (t) {
                t[0] = h(t[0]) / h(u), t[1] = h(t[1]) / h(u), a.unionExtent.call(this, t)
            },
            niceTicks: function (t) {
                t = t || 10;
                var e = this._extent, i = e[1] - e[0];
                if (!(1 / 0 === i || 0 >= i)) {
                    var r = c(10, s(h(i / t) / Math.LN10)), a = t / i * r;
                    .5 >= a && (r *= 10);
                    var o = [n.round(l(e[0] / r) * r), n.round(s(e[1] / r) * r)];
                    this._interval = r, this._niceExtent = o
                }
            },
            niceExtent: o.niceExtent
        });
        return e.each([f, "normalize"], function (t) {
            p[H][t] = function (e) {
                return e = h(e) / h(u), a[t].call(this, e)
            }
        }), p[R] = function () {
            return new p
        }, p
    }), e("echarts/ExtensionAPI", [U, j], function (t) {
        function e(t) {
            i.each(n, function (e) {
                this[e] = i.bind(t[e], t)
            }, this)
        }

        var i = t(j), n = ["getDom", "getZr", F, N, "dispatchAction", "on", "off", "getDataURL", "getConnectedDataURL", V, "getOption"];
        return e
    }), e("echarts/model/Global", [U, j, "../util/model", "./Model", "./Component", "./globalDefault"], function (t) {
        function e(t, e) {
            for (var i in e)y.hasClass(i) || ("object" == typeof e[i] ? t[i] = t[i] ? c.merge(t[i], e[i], !1) : c.clone(e[i]) : null == t[i] && (t[i] = e[i]))
        }

        function i(t) {
            t = t, this.option = {}, this.option[_] = 1, this._componentsMap = {}, this._seriesIndices = null, e(t, this._theme.option), c.merge(t, x, !1), this.mergeOption(t)
        }

        function n(t, e) {
            c[M](e) || (e = e ? [e] : []);
            var i = {};
            return d(e, function (e) {
                i[e] = (t[e] || []).slice()
            }), i
        }

        function r(t, e) {
            var i = {};
            d(e, function (t) {
                var e = t.exist;
                e && (i[e.id] = t)
            }), d(e, function (e) {
                var n = e.option;
                if (c.assert(!n || null == n.id || !i[n.id] || i[n.id] === e, "id duplicates: " + (n && n.id)), n && null != n.id && (i[n.id] = e), m(n)) {
                    var r = a(t, n, e.exist);
                    e.keyInfo = {mainType: t, subType: r}
                }
            }), d(e, function (t) {
                var e = t.exist, n = t.option, r = t.keyInfo;
                if (m(n)) {
                    if (r.name = null != n.name ? n.name + "" : e ? e.name : "\x00-", e)r.id = e.id; else if (null != n.id)r.id = n.id + ""; else {
                        var a = 0;
                        do r.id = "\x00" + r.name + "\x00" + a++; while (i[r.id])
                    }
                    i[r.id] = t
                }
            })
        }

        function a(t, e, i) {
            var n = e.type ? e.type : i ? i.subType : y.determineSubType(t, e);
            return n
        }

        function o(t) {
            return p(t, function (t) {
                    return t.componentIndex
                }) || []
        }

        function s(t, e) {
            return e.hasOwnProperty("subType") ? f(t, function (t) {
                return t.subType === e.subType
            }) : t
        }

        function l(t) {
            if (!t._seriesIndices)throw new Error("Series has not been initialized yet.")
        }

        var c = t(j), u = t("../util/model"), h = t("./Model"), d = c.each, f = c[X], p = c.map, v = c[M], g = c[w], m = c[I], y = t("./Component"), x = t("./globalDefault"), _ = "\x00_ec_inner", T = h[D]({
            constructor: T,
            init: function (t, e, i, n) {
                i = i || {}, this.option = null, this._theme = new h(i), this._optionManager = n
            },
            setOption: function (t, e) {
                c.assert(!(_ in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
            },
            resetOption: function (t) {
                var e = !1, n = this._optionManager;
                if (!t || "recreate" === t) {
                    var r = n.mountOption("recreate" === t);
                    this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(r)) : i.call(this, r), e = !0
                }
                if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                    var a = n.getTimelineOption(this);
                    a && (this.mergeOption(a), e = !0)
                }
                if (!t || "recreate" === t || "media" === t) {
                    var o = n.getMediaOption(this, this._api);
                    o[P] && d(o, function (t) {
                        this.mergeOption(t, e = !0)
                    }, this)
                }
                return e
            },
            mergeOption: function (t) {
                function e(e, s) {
                    var l = u.normalizeToArray(t[e]), h = u.mappingToExists(a[e], l);
                    r(e, h);
                    var f = n(a, s);
                    i[e] = [], a[e] = [], d(h, function (t, n) {
                        var r = t.exist, o = t.option;
                        if (c.assert(m(o) || r, "Empty component definition"), o) {
                            var s = y.getClass(e, t.keyInfo.subType, !0);
                            r && r instanceof s ? (r.mergeOption(o, this), r.optionUpdated(this)) : (r = new s(o, this, this, c[D]({
                                dependentModels: f,
                                componentIndex: n
                            }, t.keyInfo)), r.optionUpdated(this))
                        } else r.mergeOption({}, this), r.optionUpdated(this);
                        a[e][n] = r, i[e][n] = r.option
                    }, this), e === L && (this._seriesIndices = o(a[L]))
                }

                var i = this.option, a = this._componentsMap, s = [];
                d(t, function (t, e) {
                    null != t && (y.hasClass(e) ? s.push(e) : i[e] = null == i[e] ? c.clone(t) : c.merge(i[e], t, !0))
                }), y.topologicalTravel(s, y.getAllClassMainTypes(), e, this)
            },
            getOption: function () {
                var t = c.clone(this.option);
                return d(t, function (e, i) {
                    if (y.hasClass(i)) {
                        for (var e = u.normalizeToArray(e), n = e[P] - 1; n >= 0; n--)u.isIdInner(e[n]) && e[A](n, 1);
                        t[i] = e
                    }
                }), delete t[_], t
            },
            getTheme: function () {
                return this._theme
            },
            getComponent: function (t, e) {
                var i = this._componentsMap[t];
                return i ? i[e || 0] : void 0
            },
            queryComponents: function (t) {
                var e = t.mainType;
                if (!e)return [];
                var i = t.index, n = t.id, r = t.name, a = this._componentsMap[e];
                if (!a || !a[P])return [];
                var o;
                if (null != i)v(i) || (i = [i]), o = f(p(i, function (t) {
                    return a[t]
                }), function (t) {
                    return !!t
                }); else if (null != n) {
                    var l = v(n);
                    o = f(a, function (t) {
                        return l && g(n, t.id) >= 0 || !l && t.id === n
                    })
                } else if (null != r) {
                    var c = v(r);
                    o = f(a, function (t) {
                        return c && g(r, t.name) >= 0 || !c && t.name === r
                    })
                }
                return s(o, t)
            },
            findComponents: function (t) {
                function e(t) {
                    var e = r + "Index", i = r + "Id", n = r + "Name";
                    return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? {
                        mainType: r,
                        index: t[e],
                        id: t[i],
                        name: t[n]
                    } : null
                }

                function i(e) {
                    return t[X] ? f(e, t[X]) : e
                }

                var n = t.query, r = t.mainType, a = e(n), o = a ? this.queryComponents(a) : this._componentsMap[r];
                return i(s(o, t))
            },
            eachComponent: function (t, e, i) {
                var n = this._componentsMap;
                if (typeof t === b)i = e, e = t, d(n, function (t, n) {
                    d(t, function (t, r) {
                        e.call(i, n, t, r)
                    })
                }); else if (c.isString(t))d(n[t], e, i); else if (m(t)) {
                    var r = this.findComponents(t);
                    d(r, e, i)
                }
            },
            getSeriesByName: function (t) {
                var e = this._componentsMap[L];
                return f(e, function (e) {
                    return e.name === t
                })
            },
            getSeriesByIndex: function (t) {
                return this._componentsMap[L][t]
            },
            getSeriesByType: function (t) {
                var e = this._componentsMap[L];
                return f(e, function (e) {
                    return e.subType === t
                })
            },
            getSeries: function () {
                return this._componentsMap[L].slice()
            },
            eachSeries: function (t, e) {
                l(this), d(this._seriesIndices, function (i) {
                    var n = this._componentsMap[L][i];
                    t.call(e, n, i)
                }, this)
            },
            eachRawSeries: function (t, e) {
                d(this._componentsMap[L], t, e)
            },
            eachSeriesByType: function (t, e, i) {
                l(this), d(this._seriesIndices, function (n) {
                    var r = this._componentsMap[L][n];
                    r.subType === t && e.call(i, r, n)
                }, this)
            },
            eachRawSeriesByType: function (t, e, i) {
                return d(this.getSeriesByType(t), e, i)
            },
            isSeriesFiltered: function (t) {
                return l(this), c[w](this._seriesIndices, t.componentIndex) < 0
            },
            filterSeries: function (t, e) {
                l(this);
                var i = f(this._componentsMap[L], t, e);
                this._seriesIndices = o(i)
            },
            restoreData: function () {
                var t = this._componentsMap;
                this._seriesIndices = o(t[L]);
                var e = [];
                d(t, function (t, i) {
                    e.push(i)
                }), y.topologicalTravel(e, y.getAllClassMainTypes(), function (e) {
                    d(t[e], function (t) {
                        t.restoreData()
                    })
                })
            }
        });
        return T
    }), e("echarts/CoordinateSystem", [U], function () {
        function t() {
            this._coordinateSystems = []
        }

        var e = {};
        return t[H] = {
            constructor: t, create: function (t, i) {
                var n = [];
                for (var r in e) {
                    var a = e[r][R](t, i);
                    a && (n = n[h](a))
                }
                this._coordinateSystems = n
            }, update: function (t, e) {
                for (var i = this._coordinateSystems, n = 0; n < i[P]; n++)i[n].update && i[n].update(t, e)
            }
        }, t.register = function (t, i) {
            e[t] = i
        }, t.get = function (t) {
            return e[t]
        }, t
    }), e("echarts/model/OptionManager", [U, j, "../util/model", "./Component"], function (t) {
        function e(t) {
            this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
        }

        function i(t, e) {
            var i, n, r = [], a = [], o = t.timeline;
            if (t.baseOption && (n = t.baseOption), (o || t.options) && (n = n || {}, r = (t.options || []).slice()), t.media) {
                n = n || {};
                var l = t.media;
                u(l, function (t) {
                    t && t.option && (t.query ? a.push(t) : i || (i = t))
                })
            }
            return n || (n = t), n.timeline || (n.timeline = o), u([n][h](r)[h](s.map(a, function (t) {
                return t.option
            })), function (t) {
                u(e, function (e) {
                    e(t)
                })
            }), {baseOption: n, timelineOptions: r, mediaDefault: i, mediaList: a}
        }

        function n(t, e, i) {
            var n = {width: e, height: i, aspectratio: e / i}, a = !0;
            return s.each(t, function (t, e) {
                var i = e.match(v);
                if (i && i[1] && i[2]) {
                    var o = i[1], s = i[2][W]();
                    r(n[s], t, o) || (a = !1)
                }
            }), a
        }

        function r(t, e, i) {
            return "min" === i ? t >= e : "max" === i ? e >= t : t === e
        }

        function a(t, e) {
            return t.join(",") === e.join(",")
        }

        function o(t, e) {
            e = e || {}, u(e, function (e, i) {
                if (null != e) {
                    var n = t[i];
                    if (c.hasClass(i)) {
                        e = l.normalizeToArray(e), n = l.normalizeToArray(n);
                        var r = l.mappingToExists(n, e);
                        t[i] = f(r, function (t) {
                            return t.option && t.exist ? p(t.exist, t.option, !0) : t.exist || t.option
                        })
                    } else t[i] = p(n, e, !0)
                }
            })
        }

        var s = t(j), l = t("../util/model"), c = t("./Component"), u = s.each, d = s.clone, f = s.map, p = s.merge, v = /^(min|max)?(.+)$/;
        return e[H] = {
            constructor: e, setOption: function (t, e) {
                t = d(t, !0);
                var n = this._optionBackup, r = i.call(this, t, e);
                this._newBaseOption = r.baseOption, n ? (o(n.baseOption, r.baseOption), r.timelineOptions[P] && (n.timelineOptions = r.timelineOptions), r.mediaList[P] && (n.mediaList = r.mediaList), r.mediaDefault && (n.mediaDefault = r.mediaDefault)) : this._optionBackup = r
            }, mountOption: function (t) {
                var e = this._optionBackup;
                return this._timelineOptions = f(e.timelineOptions, d), this._mediaList = f(e.mediaList, d), this._mediaDefault = d(e.mediaDefault), this._currentMediaIndices = [], d(t ? e.baseOption : this._newBaseOption)
            }, getTimelineOption: function (t) {
                var e, i = this._timelineOptions;
                if (i[P]) {
                    var n = t.getComponent("timeline");
                    n && (e = d(i[n.getCurrentIndex()], !0))
                }
                return e
            }, getMediaOption: function () {
                var t = this._api[F](), e = this._api[N](), i = this._mediaList, r = this._mediaDefault, o = [], s = [];
                if (!i[P] && !r)return s;
                for (var l = 0, c = i[P]; c > l; l++)n(i[l].query, t, e) && o.push(l);
                return !o[P] && r && (o = [-1]), o[P] && !a(o, this._currentMediaIndices) && (s = f(o, function (t) {
                    return d(-1 === t ? r.option : i[t].option)
                })), this._currentMediaIndices = o, s
            }
        }, e
    }), e("echarts/model/Component", [U, "./Model", j, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function (t) {
        function e(t) {
            var e = [];
            return n.each(l.getClassesByMainType(t), function (t) {
                r.apply(e, t[H].dependencies || [])
            }), n.map(e, function (t) {
                return o.parseClassType(t).main
            })
        }

        var i = t("./Model"), n = t(j), r = Array[H].push, a = t("../util/component"), o = t("../util/clazz"), s = t("../util/layout"), l = i[D]({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            init: function () {
                this.mergeDefaultAndTheme(this.option, this.ecModel)
            },
            mergeDefaultAndTheme: function (t, e) {
                var i = this.layoutMode, r = i ? s.getLayoutParams(t) : {}, a = e.getTheme();
                n.merge(t, a.get(this.mainType)), n.merge(t, this.getDefaultOption()), i && s.mergeLayoutParam(t, r, i)
            },
            mergeOption: function (t) {
                n.merge(this.option, t, !0);
                var e = this.layoutMode;
                e && s.mergeLayoutParam(this.option, t, e)
            },
            optionUpdated: function () {
            },
            getDefaultOption: function () {
                if (!this.hasOwnProperty("__defaultOption")) {
                    for (var t = [], e = this.constructor; e;) {
                        var i = e[H].defaultOption;
                        i && t.push(i), e = e.superClass
                    }
                    for (var r = {}, a = t[P] - 1; a >= 0; a--)r = n.merge(r, t[a], !0);
                    this.__defaultOption = r
                }
                return this.__defaultOption
            }
        });
        return o.enableClassExtend(l, function (t, e, i, r) {
            n[D](this, r), this.uid = a.getUID("componentModel")
        }), o.enableClassManagement(l, {registerWhenExtend: !0}), a.enableSubTypeDefaulter(l), a.enableTopologicalTravel(l, e), n.mixin(l, t("./mixin/boxLayout")), l
    }), e("echarts/model/Series", [U, j, "../util/format", "../util/model", "./Component"], function (t) {
        var e = t(j), i = t("../util/format"), n = t("../util/model"), r = t("./Component"), a = i.encodeHTML, o = i.addCommas, s = r[D]({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            init: function (t, e, i) {
                this[S] = this.componentIndex, this.mergeDefaultAndTheme(t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow()
            },
            mergeDefaultAndTheme: function (t, i) {
                e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), n.defaultEmphasis(t.label, n.LABEL_OPTIONS), this.fillDataTextStyle(t.data)
            },
            mergeOption: function (t, i) {
                t = e.merge(this.option, t, !0), this.fillDataTextStyle(t.data);
                var n = this.getInitialData(t, i);
                n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow())
            },
            fillDataTextStyle: function (t) {
                if (t)for (var e = 0; e < t[P]; e++)t[e] && t[e].label && n.defaultEmphasis(t[e].label, n.LABEL_OPTIONS)
            },
            getInitialData: function () {
            },
            getData: function (t) {
                return null == t ? this._data : this._data.getLinkedData(t)
            },
            setData: function (t) {
                this._data = t
            },
            getRawData: function () {
                return this._dataBeforeProcessed
            },
            coordDimToDataDim: function (t) {
                return [t]
            },
            dataDimToCoordDim: function (t) {
                return t
            },
            getBaseAxis: function () {
                var t = this.coordinateSystem;
                return t && t.getBaseAxis && t.getBaseAxis()
            },
            formatTooltip: function (t, i) {
                var n = this._data, r = this.getRawValue(t), s = e[M](r) ? e.map(r, o).join(", ") : o(r), l = n.getName(t), c = n.getItemVisual(t, "color"), u = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + c + '"></span>', h = this.name;
                return "\x00-" === h && (h = ""), i ? u + a(this.name) + " : " + s : (h && a(h) + "<br />") + u + (l ? a(l) + " : " + s : s)
            },
            restoreData: function () {
                this._data = this._dataBeforeProcessed.cloneShallow()
            },
            getAxisTooltipDataIndex: null
        });
        return e.mixin(s, n.dataFormatMixin), s
    }), e("echarts/view/Component", [U, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
        var e = t("zrender/container/Group"), i = t("../util/component"), n = t("../util/clazz"), r = function () {
            this.group = new e, this.uid = i.getUID("viewComponent")
        };
        r[H] = {
            constructor: r, init: function () {
            }, render: function () {
            }, dispose: function () {
            }
        };
        var a = r[H];
        return a.updateView = a.updateLayout = a.updateVisual = function () {
        }, n.enableClassExtend(r), n.enableClassManagement(r, {registerWhenExtend: !0}), r
    }), e("echarts/util/graphic", [U, j, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", "zrender/core/matrix", "zrender/core/vector", "zrender/graphic/Gradient", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/CompoundPath", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", "zrender/core/BoundingRect"], function (t) {
        function e(t) {
            return null != t && "none" != t
        }

        function i(t) {
            return t instanceof I ? t : L.lift(t, -.1)
        }

        function n(t) {
            if (t.__hoverStlDirty) {
                var n = t.style[l], r = t.style.fill, a = t.__hoverStl;
                a.fill = a.fill || (e(r) ? i(r) : null), a[l] = a[l] || (e(n) ? i(n) : null);
                var o = {};
                for (var s in a)a.hasOwnProperty(s) && (o[s] = t.style[s]);
                t.__normalStl = o, t.__hoverStlDirty = !1
            }
        }

        function r(t) {
            t.__isHover || (n(t), t.setStyle(t.__hoverStl), t.z2 += 1, t.__isHover = !0)
        }

        function a(t) {
            if (t.__isHover) {
                var e = t.__normalStl;
                e && t.setStyle(e), t.z2 -= 1, t.__isHover = !1
            }
        }

        function o(t) {
            "group" === t.type ? t.traverse(function (t) {
                "group" !== t.type && r(t)
            }) : r(t)
        }

        function h(t) {
            "group" === t.type ? t.traverse(function (t) {
                "group" !== t.type && a(t)
            }) : a(t)
        }

        function d(t, e) {
            t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && n(t)
        }

        function f() {
            !this.__isEmphasis && o(this)
        }

        function p() {
            !this.__isEmphasis && h(this)
        }

        function m() {
            this.__isEmphasis = !0, o(this)
        }

        function M() {
            this.__isEmphasis = !1, h(this)
        }

        function T(t, e, i, n, r, a) {
            typeof r === b && (a = r, r = null);
            var o = t ? "Update" : "", s = n && n.getShallow("animationDuration" + o), l = n && n.getShallow("animationEasing" + o), c = n && n.getShallow("animationDelay" + o);
            typeof c === b && (c = c(r)), n && n.getShallow("animation") ? e.animateTo(i, s, c || 0, l, a) : (e.attr(i), a && a())
        }

        var S = t(j), C = t("zrender/tool/path"), z = Math.round, A = t("zrender/graphic/Path"), L = t("zrender/tool/color"), P = t("zrender/core/matrix"), k = t("zrender/core/vector"), I = t("zrender/graphic/Gradient"), R = {};
        return R.Group = t("zrender/container/Group"), R.Image = t("zrender/graphic/Image"), R.Text = t("zrender/graphic/Text"), R.Circle = t("zrender/graphic/shape/Circle"), R.Sector = t("zrender/graphic/shape/Sector"), R.Ring = t("zrender/graphic/shape/Ring"), R.Polygon = t("zrender/graphic/shape/Polygon"), R.Polyline = t("zrender/graphic/shape/Polyline"), R.Rect = t("zrender/graphic/shape/Rect"), R.Line = t("zrender/graphic/shape/Line"), R.BezierCurve = t("zrender/graphic/shape/BezierCurve"), R.Arc = t("zrender/graphic/shape/Arc"), R.CompoundPath = t("zrender/graphic/CompoundPath"), R.LinearGradient = t("zrender/graphic/LinearGradient"), R.RadialGradient = t("zrender/graphic/RadialGradient"), R.BoundingRect = t("zrender/core/BoundingRect"), R.extendShape = function (t) {
            return A[D](t)
        }, R.extendPath = function (t, e) {
            return C.extendFromString(t, e)
        }, R.makePath = function (t, e, i, n) {
            var r = C.createFromString(t, e), a = r[y]();
            if (i) {
                var o = a.width / a[B];
                if (n === g) {
                    var s, l = i[B] * o;
                    l <= i.width ? s = i[B] : (l = i.width, s = l / o);
                    var c = i.x + i.width / 2, u = i.y + i[B] / 2;
                    i.x = c - l / 2, i.y = u - s / 2, i.width = l, i[B] = s
                }
                this.resizePath(r, i)
            }
            return r
        }, R.mergePath = C.mergePath, R.resizePath = function (t, e) {
            if (t[u]) {
                var i = t[y](), n = i.calculateTransform(e);
                t[u](n)
            }
        }, R.subPixelOptimizeLine = function (t) {
            var e = R.subPixelOptimize, i = t.shape, n = t.style[c];
            return z(2 * i.x1) === z(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), z(2 * i.y1) === z(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
        }, R.subPixelOptimizeRect = function (t) {
            var e = R.subPixelOptimize, i = t.shape, n = t.style[c], r = i.x, a = i.y, o = i.width, s = i[B];
            return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[B] = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
        }, R.subPixelOptimize = function (t, e, i) {
            var n = z(2 * t);
            return (n + z(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
        }, R.setHoverStyle = function (t, e) {
            "group" === t.type ? t.traverse(function (t) {
                "group" !== t.type && d(t, e)
            }) : d(t, e), t.on("mouseover", f).on("mouseout", p), t.on("emphasis", m).on(s, M)
        }, R.setText = function (t, e, i) {
            var n = e.getShallow(v) || "inside", r = n[w]("inside") >= 0 ? "white" : i, a = e[V](_);
            S[D](t, {
                textDistance: e.getShallow("distance") || 5,
                textFont: a[x](),
                textPosition: n,
                textFill: a.getTextColor() || r
            })
        }, R.updateProps = S.curry(T, !0), R.initProps = S.curry(T, !1), R.getTransform = function (t, e) {
            for (var i = P.identity([]); t && t !== e;)P.mul(i, t.getLocalTransform(), i), t = t.parent;
            return i
        }, R[u] = function (t, e, i) {
            return i && (e = P.invert([], e)), k[u]([], t, e)
        }, R.transformDirection = function (t, e, i) {
            var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]), r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]), a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === E ? r : 0];
            return a = R[u](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? E : "top"
        }, R
    }), e("echarts/view/Chart", [U, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
        function e() {
            this.group = new r, this.uid = a.getUID("viewChart")
        }

        function i(t, e) {
            if (t && (t.trigger(e), "group" === t.type))for (var n = 0; n < t.childCount(); n++)i(t.childAt(n), e)
        }

        function n(t, e, n) {
            if (null != e.dataIndex) {
                var r = t.getItemGraphicEl(e.dataIndex);
                i(r, n)
            } else if (e.name) {
                var a = t.indexOfName(e.name), r = t.getItemGraphicEl(a);
                i(r, n)
            } else t.eachItemGraphicEl(function (t) {
                i(t, n)
            })
        }

        var r = t("zrender/container/Group"), a = t("../util/component"), o = t("../util/clazz");
        e[H] = {
            type: "chart", init: function () {
            }, render: function () {
            }, highlight: function (t, e, i, r) {
                n(t[z](), r, "emphasis")
            }, downplay: function (t, e, i, r) {
                n(t[z](), r, s)
            }, remove: function () {
                this.group.removeAll()
            }, dispose: function () {
            }
        };
        var l = e[H];
        return l.updateView = l.updateLayout = l.updateVisual = function (t, e, i, n) {
            this.render(t, e, i, n)
        }, o.enableClassExtend(e), o.enableClassManagement(e, {registerWhenExtend: !0}), e
    }), e("zrender/zrender", [U, "./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./Painter"], function (t) {
        function e(t) {
            delete c[t]
        }

        var i = t("./core/guid"), n = t("./core/env"), r = t("./Handler"), a = t("./Storage"), o = t("./animation/Animation"), s = !n.canvasSupported, l = {canvas: t("./Painter")}, c = {}, u = {};
        u.version = "3.1.0", u.init = function (t, e) {
            var n = new h(i(), t, e);
            return c[n.id] = n, n
        }, u.dispose = function (t) {
            if (t)t.dispose(); else {
                for (var e in c)c[e].dispose();
                c = {}
            }
            return u
        }, u.getInstance = function (t) {
            return c[t]
        }, u.registerPainter = function (t, e) {
            l[t] = e
        };
        var h = function (t, e, i) {
            i = i || {}, this.dom = e, this.id = t;
            var c = this, u = new a, h = i.renderer;
            if (s) {
                if (!l.vml)throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                h = "vml"
            } else h && l[h] || (h = "canvas");
            var d = new l[h](e, u, i);
            this.storage = u, this.painter = d, n.node || (this.handler = new r(d.getViewportRoot(), u, d)), this.animation = new o({
                stage: {
                    update: function () {
                        c._needsRefresh && c.refreshImmediately()
                    }
                }
            }), this.animation.start(), this._needsRefresh;
            var f = u.delFromMap, p = u.addToMap;
            u.delFromMap = function (t) {
                var e = u.get(t);
                f.call(u, t), e && e.removeSelfFromZr(c)
            }, u.addToMap = function (t) {
                p.call(u, t), t.addSelfToZr(c)
            }
        };
        return h[H] = {
            constructor: h, getId: function () {
                return this.id
            }, add: function (t) {
                this.storage.addRoot(t), this._needsRefresh = !0
            }, remove: function (t) {
                this.storage.delRoot(t), this._needsRefresh = !0
            }, configLayer: function (t, e) {
                this.painter.configLayer(t, e), this._needsRefresh = !0
            }, refreshImmediately: function () {
                this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
            }, refresh: function () {
                this._needsRefresh = !0
            }, resize: function () {
                this.painter[G](), this.handler && this.handler[G]()
            }, clearAnimation: function () {
                this.animation.clear()
            }, getWidth: function () {
                return this.painter[F]()
            }, getHeight: function () {
                return this.painter[N]()
            }, pathToImage: function (t, e, n) {
                var r = i();
                return this.painter.pathToImage(r, t, e, n)
            }, setDefaultCursorStyle: function (t) {
                this.handler.setDefaultCursorStyle(t)
            }, on: function (t, e, i) {
                this.handler && this.handler.on(t, e, i)
            }, off: function (t, e) {
                this.handler && this.handler.off(t, e)
            }, trigger: function (t, e) {
                this.handler && this.handler.trigger(t, e)
            }, clear: function () {
                this.storage.delRoot(), this.painter.clear()
            }, dispose: function () {
                this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler && this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, e(this.id)
            }
        }, u
    }), e(j, [U, "../graphic/Gradient"], function (t) {
        function e(t) {
            if ("object" == typeof t && null !== t) {
                var i = t;
                if (t instanceof Array) {
                    i = [];
                    for (var n = 0, r = t[P]; r > n; n++)i[n] = e(t[n])
                } else if (!z(t) && !A(t)) {
                    i = {};
                    for (var a in t)t.hasOwnProperty(a) && (i[a] = e(t[a]))
                }
                return i
            }
            return t
        }

        function i(t, n, r) {
            if (!C(n) || !C(t))return r ? e(n) : t;
            for (var a in n)if (n.hasOwnProperty(a)) {
                var o = t[a], s = n[a];
                !C(s) || !C(o) || M(s) || M(o) || A(s) || A(o) || z(s) || z(o) ? !r && a in t || (t[a] = e(n[a], !0)) : i(o, s, r)
            }
            return t
        }

        function n(t, e) {
            for (var n = t[0], r = 1, a = t[P]; a > r; r++)n = i(n, t[r], e);
            return n
        }

        function r(t, e) {
            for (var i in e)e.hasOwnProperty(i) && (t[i] = e[i]);
            return t
        }

        function a(t, e, i) {
            for (var n in e)e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
            return t
        }

        function s() {
            return document[o]("canvas")
        }

        function l() {
            return I || (I = Z.createCanvas().getContext("2d")), I
        }

        function c(t, e) {
            if (t) {
                if (t[w])return t[w](e);
                for (var i = 0, n = t[P]; n > i; i++)if (t[i] === e)return i
            }
            return -1
        }

        function u(t, e) {
            function i() {
            }

            var n = t[H];
            i[H] = e[H], t[H] = new i;
            for (var r in n)t[H][r] = n[r];
            t[H].constructor = t, t.superClass = e
        }

        function d(t, e, i) {
            t = H in t ? t[H] : t, e = H in e ? e[H] : e, a(t, e, i)
        }

        function f(t) {
            return t ? typeof t == q ? !1 : "number" == typeof t[P] : void 0
        }

        function p(t, e, i) {
            if (t && e)if (t.forEach && t.forEach === N)t.forEach(e, i); else if (t[P] === +t[P])for (var n = 0, r = t[P]; r > n; n++)e.call(i, t[n], n, t); else for (var a in t)t.hasOwnProperty(a) && e.call(i, t[a], a, t)
        }

        function v(t, e, i) {
            if (t && e) {
                if (t.map && t.map === G)return t.map(e, i);
                for (var n = [], r = 0, a = t[P]; a > r; r++)n.push(e.call(i, t[r], r, t));
                return n
            }
        }

        function g(t, e, i, n) {
            if (t && e) {
                if (t.reduce && t.reduce === W)return t.reduce(e, i, n);
                for (var r = 0, a = t[P]; a > r; r++)i = e.call(n, i, t[r], r, t);
                return i
            }
        }

        function m(t, e, i) {
            if (t && e) {
                if (t[X] && t[X] === F)return t[X](e, i);
                for (var n = [], r = 0, a = t[P]; a > r; r++)e.call(i, t[r], r, t) && n.push(t[r]);
                return n
            }
        }

        function y(t, e, i) {
            if (t && e)for (var n = 0, r = t[P]; r > n; n++)if (e.call(i, t[n], n, t))return t[n]
        }

        function x(t, e) {
            var i = V.call(arguments, 2);
            return function () {
                return t.apply(e, i[h](V.call(arguments)))
            }
        }

        function _(t) {
            var e = V.call(arguments, 1);
            return function () {
                return t.apply(this, e[h](V.call(arguments)))
            }
        }

        function M(t) {
            return "[object Array]" === E.call(t)
        }

        function T(t) {
            return typeof t === b
        }

        function S(t) {
            return "[object String]" === E.call(t)
        }

        function C(t) {
            var e = typeof t;
            return e === b || !!t && "object" == e
        }

        function z(t) {
            return !!B[E.call(t)] || t instanceof R
        }

        function A(t) {
            return t && 1 === t.nodeType && typeof t.nodeName == q
        }

        function L() {
            for (var t = 0, e = arguments[P]; e > t; t++)if (null != arguments[t])return arguments[t]
        }

        function k() {
            return Function.call.apply(V, arguments)
        }

        function D(t, e) {
            if (!t)throw new Error(e)
        }

        var I, R = t("../graphic/Gradient"), B = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1
        }, E = Object[H].toString, O = Array[H], N = O.forEach, F = O[X], V = O.slice, G = O.map, W = O.reduce, Z = {
            inherits: u,
            mixin: d,
            clone: e,
            merge: i,
            mergeAll: n,
            extend: r,
            defaults: a,
            getContext: l,
            createCanvas: s,
            indexOf: c,
            slice: k,
            find: y,
            isArrayLike: f,
            each: p,
            map: v,
            reduce: g,
            filter: m,
            bind: x,
            curry: _,
            isArray: M,
            isString: S,
            isObject: C,
            isFunction: T,
            isBuildInObject: z,
            isDom: A,
            retrieve: L,
            assert: D,
            noop: function () {
            }
        };
        return Z
    }), e("zrender/tool/color", [U], function () {
        function t(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
        }

        function e(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
        }

        function i(t) {
            return 0 > t ? 0 : t > 1 ? 1 : t
        }

        function n(e) {
            return t(e[P] && "%" === e.charAt(e[P] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
        }

        function r(t) {
            return i(t[P] && "%" === t.charAt(t[P] - 1) ? parseFloat(t) / 100 : parseFloat(t))
        }

        function a(t, e, i) {
            return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
        }

        function o(t, e, i) {
            return t + (e - t) * i
        }

        function s(t) {
            if (t) {
                t += "";
                var e = t[T](/ /g, "")[W]();
                if (e in m)return m[e].slice();
                if ("#" !== e.charAt(0)) {
                    var i = e[w]("("), a = e[w](")");
                    if (-1 !== i && a + 1 === e[P]) {
                        var o = e.substr(0, i), s = e.substr(i + 1, a - (i + 1)).split(","), c = 1;
                        switch (o) {
                            case"rgba":
                                if (4 !== s[P])return;
                                c = r(s.pop());
                            case"rgb":
                                if (3 !== s[P])return;
                                return [n(s[0]), n(s[1]), n(s[2]), c];
                            case"hsla":
                                if (4 !== s[P])return;
                                return s[3] = r(s[3]), l(s);
                            case"hsl":
                                if (3 !== s[P])return;
                                return l(s);
                            default:
                                return
                        }
                    }
                } else {
                    if (4 === e[P]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 4095 >= u))return;
                        return [(3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1]
                    }
                    if (7 === e[P]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 16777215 >= u))return;
                        return [(16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1]
                    }
                }
            }
        }

        function l(e) {
            var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = r(e[1]), o = r(e[2]), s = .5 >= o ? o * (n + 1) : o + n - o * n, l = 2 * o - s, c = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
            return 4 === e[P] && (c[3] = e[3]), c
        }

        function c(t) {
            if (t) {
                var e, i, n = t[0] / 255, r = t[1] / 255, a = t[2] / 255, o = Math.min(n, r, a), s = Math.max(n, r, a), l = s - o, c = (s + o) / 2;
                if (0 === l)e = 0, i = 0; else {
                    i = .5 > c ? l / (s + o) : l / (2 - s - o);
                    var u = ((s - n) / 6 + l / 2) / l, h = ((s - r) / 6 + l / 2) / l, d = ((s - a) / 6 + l / 2) / l;
                    n === s ? e = d - h : r === s ? e = 1 / 3 + u - d : a === s && (e = 2 / 3 + h - u), 0 > e && (e += 1), e > 1 && (e -= 1)
                }
                var f = [360 * e, i, c];
                return null != t[3] && f.push(t[3]), f
            }
        }

        function u(t, e) {
            var i = s(t);
            if (i) {
                for (var n = 0; 3 > n; n++)i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
                return g(i, 4 === i[P] ? "rgba" : "rgb")
            }
        }

        function h(t) {
            var e = s(t);
            return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
        }

        function d(e, i, n) {
            if (i && i[P] && e >= 0 && 1 >= e) {
                n = n || [0, 0, 0, 0];
                var r = e * (i[P] - 1), a = Math.floor(r), s = Math.ceil(r), l = i[a], c = i[s], u = r - a;
                return n[0] = t(o(l[0], c[0], u)), n[1] = t(o(l[1], c[1], u)), n[2] = t(o(l[2], c[2], u)), n[3] = t(o(l[3], c[3], u)), n
            }
        }

        function f(e, n, r) {
            if (n && n[P] && e >= 0 && 1 >= e) {
                var a = e * (n[P] - 1), l = Math.floor(a), c = Math.ceil(a), u = s(n[l]), h = s(n[c]), d = a - l, f = g([t(o(u[0], h[0], d)), t(o(u[1], h[1], d)), t(o(u[2], h[2], d)), i(o(u[3], h[3], d))], "rgba");
                return r ? {color: f, leftIndex: l, rightIndex: c, value: a} : f
            }
        }

        function p(t, i, n, a) {
            return t = s(t), t ? (t = c(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), g(l(t), "rgba")) : void 0
        }

        function v(t, e) {
            return t = s(t), t && null != e ? (t[3] = i(e), g(t, "rgba")) : void 0
        }

        function g(t, e) {
            return ("rgb" === e || "hsv" === e || "hsl" === e) && (t = t.slice(0, 3)), e + "(" + t.join(",") + ")"
        }

        var m = {
            transparent: [0, 0, 0, 0],
            aliceblue: [240, 248, 255, 1],
            antiquewhite: [250, 235, 215, 1],
            aqua: [0, 255, 255, 1],
            aquamarine: [127, 255, 212, 1],
            azure: [240, 255, 255, 1],
            beige: [245, 245, 220, 1],
            bisque: [255, 228, 196, 1],
            black: [0, 0, 0, 1],
            blanchedalmond: [255, 235, 205, 1],
            blue: [0, 0, 255, 1],
            blueviolet: [138, 43, 226, 1],
            brown: [165, 42, 42, 1],
            burlywood: [222, 184, 135, 1],
            cadetblue: [95, 158, 160, 1],
            chartreuse: [127, 255, 0, 1],
            chocolate: [210, 105, 30, 1],
            coral: [255, 127, 80, 1],
            cornflowerblue: [100, 149, 237, 1],
            cornsilk: [255, 248, 220, 1],
            crimson: [220, 20, 60, 1],
            cyan: [0, 255, 255, 1],
            darkblue: [0, 0, 139, 1],
            darkcyan: [0, 139, 139, 1],
            darkgoldenrod: [184, 134, 11, 1],
            darkgray: [169, 169, 169, 1],
            darkgreen: [0, 100, 0, 1],
            darkgrey: [169, 169, 169, 1],
            darkkhaki: [189, 183, 107, 1],
            darkmagenta: [139, 0, 139, 1],
            darkolivegreen: [85, 107, 47, 1],
            darkorange: [255, 140, 0, 1],
            darkorchid: [153, 50, 204, 1],
            darkred: [139, 0, 0, 1],
            darksalmon: [233, 150, 122, 1],
            darkseagreen: [143, 188, 143, 1],
            darkslateblue: [72, 61, 139, 1],
            darkslategray: [47, 79, 79, 1],
            darkslategrey: [47, 79, 79, 1],
            darkturquoise: [0, 206, 209, 1],
            darkviolet: [148, 0, 211, 1],
            deeppink: [255, 20, 147, 1],
            deepskyblue: [0, 191, 255, 1],
            dimgray: [105, 105, 105, 1],
            dimgrey: [105, 105, 105, 1],
            dodgerblue: [30, 144, 255, 1],
            firebrick: [178, 34, 34, 1],
            floralwhite: [255, 250, 240, 1],
            forestgreen: [34, 139, 34, 1],
            fuchsia: [255, 0, 255, 1],
            gainsboro: [220, 220, 220, 1],
            ghostwhite: [248, 248, 255, 1],
            gold: [255, 215, 0, 1],
            goldenrod: [218, 165, 32, 1],
            gray: [128, 128, 128, 1],
            green: [0, 128, 0, 1],
            greenyellow: [173, 255, 47, 1],
            grey: [128, 128, 128, 1],
            honeydew: [240, 255, 240, 1],
            hotpink: [255, 105, 180, 1],
            indianred: [205, 92, 92, 1],
            indigo: [75, 0, 130, 1],
            ivory: [255, 255, 240, 1],
            khaki: [240, 230, 140, 1],
            lavender: [230, 230, 250, 1],
            lavenderblush: [255, 240, 245, 1],
            lawngreen: [124, 252, 0, 1],
            lemonchiffon: [255, 250, 205, 1],
            lightblue: [173, 216, 230, 1],
            lightcoral: [240, 128, 128, 1],
            lightcyan: [224, 255, 255, 1],
            lightgoldenrodyellow: [250, 250, 210, 1],
            lightgray: [211, 211, 211, 1],
            lightgreen: [144, 238, 144, 1],
            lightgrey: [211, 211, 211, 1],
            lightpink: [255, 182, 193, 1],
            lightsalmon: [255, 160, 122, 1],
            lightseagreen: [32, 178, 170, 1],
            lightskyblue: [135, 206, 250, 1],
            lightslategray: [119, 136, 153, 1],
            lightslategrey: [119, 136, 153, 1],
            lightsteelblue: [176, 196, 222, 1],
            lightyellow: [255, 255, 224, 1],
            lime: [0, 255, 0, 1],
            limegreen: [50, 205, 50, 1],
            linen: [250, 240, 230, 1],
            magenta: [255, 0, 255, 1],
            maroon: [128, 0, 0, 1],
            mediumaquamarine: [102, 205, 170, 1],
            mediumblue: [0, 0, 205, 1],
            mediumorchid: [186, 85, 211, 1],
            mediumpurple: [147, 112, 219, 1],
            mediumseagreen: [60, 179, 113, 1],
            mediumslateblue: [123, 104, 238, 1],
            mediumspringgreen: [0, 250, 154, 1],
            mediumturquoise: [72, 209, 204, 1],
            mediumvioletred: [199, 21, 133, 1],
            midnightblue: [25, 25, 112, 1],
            mintcream: [245, 255, 250, 1],
            mistyrose: [255, 228, 225, 1],
            moccasin: [255, 228, 181, 1],
            navajowhite: [255, 222, 173, 1],
            navy: [0, 0, 128, 1],
            oldlace: [253, 245, 230, 1],
            olive: [128, 128, 0, 1],
            olivedrab: [107, 142, 35, 1],
            orange: [255, 165, 0, 1],
            orangered: [255, 69, 0, 1],
            orchid: [218, 112, 214, 1],
            palegoldenrod: [238, 232, 170, 1],
            palegreen: [152, 251, 152, 1],
            paleturquoise: [175, 238, 238, 1],
            palevioletred: [219, 112, 147, 1],
            papayawhip: [255, 239, 213, 1],
            peachpuff: [255, 218, 185, 1],
            peru: [205, 133, 63, 1],
            pink: [255, 192, 203, 1],
            plum: [221, 160, 221, 1],
            powderblue: [176, 224, 230, 1],
            purple: [128, 0, 128, 1],
            red: [255, 0, 0, 1],
            rosybrown: [188, 143, 143, 1],
            royalblue: [65, 105, 225, 1],
            saddlebrown: [139, 69, 19, 1],
            salmon: [250, 128, 114, 1],
            sandybrown: [244, 164, 96, 1],
            seagreen: [46, 139, 87, 1],
            seashell: [255, 245, 238, 1],
            sienna: [160, 82, 45, 1],
            silver: [192, 192, 192, 1],
            skyblue: [135, 206, 235, 1],
            slateblue: [106, 90, 205, 1],
            slategray: [112, 128, 144, 1],
            slategrey: [112, 128, 144, 1],
            snow: [255, 250, 250, 1],
            springgreen: [0, 255, 127, 1],
            steelblue: [70, 130, 180, 1],
            tan: [210, 180, 140, 1],
            teal: [0, 128, 128, 1],
            thistle: [216, 191, 216, 1],
            tomato: [255, 99, 71, 1],
            turquoise: [64, 224, 208, 1],
            violet: [238, 130, 238, 1],
            wheat: [245, 222, 179, 1],
            white: [255, 255, 255, 1],
            whitesmoke: [245, 245, 245, 1],
            yellow: [255, 255, 0, 1],
            yellowgreen: [154, 205, 50, 1]
        };
        return {
            parse: s,
            lift: u,
            toHex: h,
            fastMapToColor: d,
            mapToColor: f,
            modifyHSL: p,
            modifyAlpha: v,
            stringify: g
        }
    }), e("zrender/core/env", [], function () {
        function t(t) {
            var e = {}, i = {}, n = t.match(/Web[kK]it[\/]{0,1}([\d.]+)/), r = t.match(/(Android);?[\s\/]+([\d.]+)?/), a = t.match(/(iPad).*OS\s([\d_]+)/), s = t.match(/(iPod)(.*OS\s([\d_]+))?/), l = !a && t.match(/(iPhone\sOS)\s([\d_]+)/), c = t.match(/(webOS|hpwOS)[\s\/]([\d.]+)/), u = c && t.match(/TouchPad/), h = t.match(/Kindle\/([\d.]+)/), d = t.match(/Silk\/([\d._]+)/), f = t.match(/(BlackBerry).*Version\/([\d.]+)/), p = t.match(/(BB10).*Version\/([\d.]+)/), v = t.match(/(RIM\sTablet\sOS)\s([\d.]+)/), g = t.match(/PlayBook/), m = t.match(/Chrome\/([\d.]+)/) || t.match(/CriOS\/([\d.]+)/), y = t.match(/Firefox\/([\d.]+)/), x = n && t.match(/Mobile\//) && !m, _ = t.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !m, b = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), w = t.match(/Edge\/([\d.]+)/);
            return (i.webkit = !!n) && (i.version = n[1]), r && (e.android = !0, e.version = r[2]), l && !s && (e.ios = e.iphone = !0, e.version = l[2][T](/_/g, ".")), a && (e.ios = e.ipad = !0, e.version = a[2][T](/_/g, ".")), s && (e.ios = e.ipod = !0, e.version = s[3] ? s[3][T](/_/g, ".") : null), c && (e.webos = !0, e.version = c[2]), u && (e.touchpad = !0), f && (e.blackberry = !0, e.version = f[2]), p && (e.bb10 = !0, e.version = p[2]), v && (e.rimtabletos = !0, e.version = v[2]), g && (i.playbook = !0), h && (e.kindle = !0, e.version = h[1]), d && (i.silk = !0, i.version = d[1]), !d && e.android && t.match(/Kindle Fire/) && (i.silk = !0), m && (i.chrome = !0, i.version = m[1]), y && (i.firefox = !0, i.version = y[1]), b && (i.ie = !0, i.version = b[1]), x && (t.match(/Safari/) || e.ios) && (i.safari = !0), _ && (i.webview = !0), b && (i.ie = !0, i.version = b[1]), w && (i.edge = !0, i.version = w[1]), e.tablet = !!(a || g || r && !t.match(/Mobile/) || y && t.match(/Tablet/) || b && !t.match(/Phone/) && t.match(/Touch/)), e.phone = !(e.tablet || e.ipod || !(r || l || c || f || p || m && t.match(/Android/) || m && t.match(/CriOS\/([\d.]+)/) || y && t.match(/Mobile/) || b && t.match(/Touch/))), {
                browser: i,
                os: e,
                node: !1,
                canvasSupported: document[o]("canvas").getContext ? !0 : !1,
                touchEventsSupported: "ontouchstart"in window && !i.ie && !i.edge,
                pointerEventsSupported: "onpointerdown"in window && (i.edge || i.ie && i.version >= 10)
            }
        }

        var e = {};
        return e = typeof navigator === a ? {
            browser: {},
            os: {},
            node: !0,
            canvasSupported: !0
        } : t(navigator.userAgent)
    }), e("zrender/mixin/Eventful", [U, r], function (t) {
        var e = Array[H].slice, i = t(r), n = i[w], a = function () {
            this._$handlers = {}
        };
        return a[H] = {
            constructor: a, one: function (t, e, i) {
                var r = this._$handlers;
                return e && t ? (r[t] || (r[t] = []), n(r[t], t) >= 0 ? this : (r[t].push({
                    h: e,
                    one: !0,
                    ctx: i || this
                }), this)) : this
            }, on: function (t, e, i) {
                var n = this._$handlers;
                return e && t ? (n[t] || (n[t] = []), n[t].push({h: e, one: !1, ctx: i || this}), this) : this
            }, isSilent: function (t) {
                var e = this._$handlers;
                return e[t] && e[t][P]
            }, off: function (t, e) {
                var i = this._$handlers;
                if (!t)return this._$handlers = {}, this;
                if (e) {
                    if (i[t]) {
                        for (var n = [], r = 0, a = i[t][P]; a > r; r++)i[t][r].h != e && n.push(i[t][r]);
                        i[t] = n
                    }
                    i[t] && 0 === i[t][P] && delete i[t]
                } else delete i[t];
                return this
            }, trigger: function (t) {
                if (this._$handlers[t]) {
                    var i = arguments, n = i[P];
                    n > 3 && (i = e.call(i, 1));
                    for (var r = this._$handlers[t], a = r[P], o = 0; a > o;) {
                        switch (n) {
                            case 1:
                                r[o].h.call(r[o].ctx);
                                break;
                            case 2:
                                r[o].h.call(r[o].ctx, i[1]);
                                break;
                            case 3:
                                r[o].h.call(r[o].ctx, i[1], i[2]);
                                break;
                            default:
                                r[o].h.apply(r[o].ctx, i)
                        }
                        r[o].one ? (r[A](o, 1), a--) : o++
                    }
                }
                return this
            }, triggerWithContext: function (t) {
                if (this._$handlers[t]) {
                    var i = arguments, n = i[P];
                    n > 4 && (i = e.call(i, 1, i[P] - 1));
                    for (var r = i[i[P] - 1], a = this._$handlers[t], o = a[P], s = 0; o > s;) {
                        switch (n) {
                            case 1:
                                a[s].h.call(r);
                                break;
                            case 2:
                                a[s].h.call(r, i[1]);
                                break;
                            case 3:
                                a[s].h.call(r, i[1], i[2]);
                                break;
                            default:
                                a[s].h.apply(r, i)
                        }
                        a[s].one ? (a[A](s, 1), o--) : s++
                    }
                }
                return this
            }
        }, a
    }), e("echarts/loading/default", [U, "../util/graphic", j], function (t) {
        var e = t("../util/graphic"), i = t(j), n = Math.PI;
        return function (t, r) {
            r = r || {}, i[k](r, {
                text: "loading",
                color: "#c23531",
                textColor: "#000",
                maskColor: "rgba(255, 255, 255, 0.8)",
                zlevel: 0
            });
            var a = new e.Rect({
                style: {fill: r.maskColor},
                zlevel: r.zlevel,
                z: 1e4
            }), o = new e.Arc({
                shape: {startAngle: -n / 2, endAngle: -n / 2 + .1, r: 10},
                style: {stroke: r.color, lineCap: "round", lineWidth: 5},
                zlevel: r.zlevel,
                z: 10001
            }), s = new e.Rect({
                style: {
                    fill: "none",
                    text: r.text,
                    textPosition: "right",
                    textDistance: 10,
                    textFill: r.textColor
                }, zlevel: r.zlevel, z: 10001
            });
            o.animateShape(!0).when(1e3, {endAngle: 3 * n / 2}).start("circularInOut"), o.animateShape(!0).when(1e3, {startAngle: 3 * n / 2}).delay(300).start("circularInOut");
            var l = new e.Group;
            return l.add(o), l.add(s), l.add(a), l[G] = function () {
                var e = t[F]() / 2, i = t[N]() / 2;
                o.setShape({cx: e, cy: i});
                var n = o.shape.r;
                s.setShape({x: e - n, y: i - n, width: 2 * n, height: 2 * n}), a.setShape({
                    x: 0,
                    y: 0,
                    width: t[F](),
                    height: t[N]()
                })
            }, l[G](), l
        }
    }), e("echarts/visual/seriesColor", [U, "zrender/graphic/Gradient"], function (t) {
        var e = t("zrender/graphic/Gradient");
        return function (t, i, n) {
            function r(t) {
                var r = [i, s, "color"], a = n.get("color"), o = t[z](), l = t.get(r) || a[t[S] % a[P]];
                o.setVisual("color", l), n.isSeriesFiltered(t) || (typeof l !== b || l instanceof e || o.each(function (e) {
                    o.setItemVisual(e, "color", l(t.getDataParams(e)))
                }), o.each(function (t) {
                    var e = o.getItemModel(t), i = e.get(r, !0);
                    null != i && o.setItemVisual(t, "color", i)
                }))
            }

            t ? n.eachSeriesByType(t, r) : n.eachSeries(r)
        }
    }), e("echarts/preprocessor/backwardCompat", [U, j, "./helper/compatStyle"], function (t) {
        function e(t, e) {
            e = e.split(",");
            for (var i = t, n = 0; n < e[P] && (i = i && i[e[n]], null != i); n++);
            return i
        }

        function i(t, e, i, n) {
            e = e.split(",");
            for (var r, a = t, o = 0; o < e[P] - 1; o++)r = e[o], null == a[r] && (a[r] = {}), a = a[r];
            (n || null == a[e[o]]) && (a[e[o]] = i)
        }

        function n(t) {
            c(o, function (e) {
                e[0]in t && !(e[1]in t) && (t[e[1]] = t[e[0]])
            })
        }

        var r = t(j), a = t("./helper/compatStyle"), o = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", E]], s = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"], c = r.each;
        return function (t) {
            c(t[L], function (t) {
                if (r[I](t)) {
                    var o = t.type;
                    if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === o) {
                        var s = e(t, "pointer.color");
                        null != s && i(t, "itemStyle.normal.color", s)
                    }
                    for (var c = 0; c < l[P]; c++)if (l[c] === t.type) {
                        n(t);
                        break
                    }
                }
            }), t.dataRange && (t.visualMap = t.dataRange), c(s, function (e) {
                var i = t[e];
                i && (r[M](i) || (i = [i]), c(i, function (t) {
                    n(t)
                }))
            })
        }
    }), e("echarts/util/number", [U], function () {
        function t(t) {
            return t[T](/^\s+/, "")[T](/\s+$/, "")
        }

        var e = {}, i = 1e-4;
        return e.linearMap = function (t, e, i, n) {
            var r = e[1] - e[0], a = i[1] - i[0];
            if (0 === r)return 0 === a ? i[0] : (i[0] + i[1]) / 2;
            if (n)if (r > 0) {
                if (t <= e[0])return i[0];
                if (t >= e[1])return i[1]
            } else {
                if (t >= e[0])return i[0];
                if (t <= e[1])return i[1]
            } else {
                if (t === e[0])return i[0];
                if (t === e[1])return i[1]
            }
            return (t - e[0]) / r * a + i[0]
        }, e.parsePercent = function (e, i) {
            switch (e) {
                case g:
                case m:
                    e = "50%";
                    break;
                case"left":
                case"top":
                    e = "0%";
                    break;
                case"right":
                case E:
                    e = "100%"
            }
            return typeof e === q ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e
        }, e.round = function (t) {
            return +(+t).toFixed(10)
        }, e.asc = function (t) {
            return t.sort(function (t, e) {
                return t - e
            }), t
        }, e.getPrecision = function (t) {
            if (isNaN(t))return 0;
            for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++;
            return i
        }, e.getPixelPrecision = function (t, e) {
            var i = Math.log, n = Math.LN10, r = Math.floor(i(t[1] - t[0]) / n), a = Math.round(i(Math.abs(e[1] - e[0])) / n);
            return Math.max(-r + a, 0)
        }, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function (t) {
            var e = 2 * Math.PI;
            return (t % e + e) % e
        }, e.isRadianAroundZero = function (t) {
            return t > -i && i > t
        }, e.parseDate = function (t) {
            return t instanceof Date ? t : new Date(typeof t === q ? t[T](/-/g, "/") : Math.round(t))
        }, e.quantity = function (t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
        }, e.nice = function (t, i) {
            var n, r = e.quantity(t), a = t / r;
            return n = i ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, n * r
        }, e
    }), e("zrender/core/matrix", [], function () {
        var t = typeof Float32Array === a ? Array : Float32Array, e = {
            create: function () {
                var i = new t(6);
                return e.identity(i), i
            }, identity: function (t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
            }, copy: function (t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
            }, mul: function (t, e, i) {
                var n = e[0] * i[0] + e[2] * i[1], r = e[1] * i[0] + e[3] * i[1], a = e[0] * i[2] + e[2] * i[3], o = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5];
                return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
            }, translate: function (t, e, i) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
            }, rotate: function (t, e, i) {
                var n = e[0], r = e[2], a = e[4], o = e[1], s = e[3], l = e[5], c = Math.sin(i), u = Math.cos(i);
                return t[0] = n * u + o * c, t[1] = -n * c + o * u, t[2] = r * u + s * c, t[3] = -r * c + u * s, t[4] = u * a + c * l, t[5] = u * l - c * a, t
            }, scale: function (t, e, i) {
                var n = i[0], r = i[1];
                return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
            }, invert: function (t, e) {
                var i = e[0], n = e[2], r = e[4], a = e[1], o = e[3], s = e[5], l = i * o - a * n;
                return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
            }
        };
        return e
    }), e("echarts/util/format", [U, j, "./number"], function (t) {
        function e(t) {
            return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][T](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[P] > 1 ? "." + t[1] : ""))
        }

        function i(t) {
            return t[W]()[T](/-(.)/g, function (t, e) {
                return e.toUpperCase()
            })
        }

        function n(t) {
            var e = t[P];
            return "number" == typeof t ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
        }

        function r(t) {
            return String(t)[T](/&/g, "&amp;")[T](/</g, "&lt;")[T](/>/g, "&gt;")[T](/"/g, "&quot;")[T](/'/g, "&#39;")
        }

        function a(t, e) {
            return "{" + t + (null == e ? "" : e) + "}"
        }

        function o(t, e) {
            c[M](e) || (e = [e]);
            var i = e[P];
            if (!i)return "";
            for (var n = e[0].$vars, r = 0; r < n[P]; r++) {
                var o = h[r];
                t = t[T](a(o), a(o, 0))
            }
            for (var s = 0; i > s; s++)for (var l = 0; l < n[P]; l++)t = t[T](a(h[l], s), e[s][n[l]]);
            return t
        }

        function s(t, e) {
            ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
            var i = u.parseDate(e), n = i.getFullYear(), r = i.getMonth() + 1, a = i.getDate(), o = i.getHours(), s = i.getMinutes(), c = i.getSeconds();
            return t = t[T]("MM", l(r))[W]()[T]("yyyy", n)[T]("yy", n % 100)[T]("dd", l(a))[T]("d", a)[T]("hh", l(o))[T]("h", o)[T]("mm", l(s))[T]("m", s)[T]("ss", l(c))[T]("s", c)
        }

        function l(t) {
            return 10 > t ? "0" + t : t
        }

        var c = t(j), u = t("./number"), h = ["a", "b", "c", "d", "e", "f", "g"];
        return {normalizeCssArray: n, addCommas: e, toCamelCase: i, encodeHTML: r, formatTpl: o, formatTime: s}
    }), e("zrender/core/vector", [], function () {
        var t = typeof Float32Array === a ? Array : Float32Array, e = {
            create: function (e, i) {
                var n = new t(2);
                return n[0] = e || 0, n[1] = i || 0, n
            }, copy: function (t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, clone: function (e) {
                var i = new t(2);
                return i[0] = e[0], i[1] = e[1], i
            }, set: function (t, e, i) {
                return t[0] = e, t[1] = i, t
            }, add: function (t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, scaleAndAdd: function (t, e, i, n) {
                return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
            }, sub: function (t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, len: function (t) {
                return Math.sqrt(this.lenSquare(t))
            }, lenSquare: function (t) {
                return t[0] * t[0] + t[1] * t[1]
            }, mul: function (t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, div: function (t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, dot: function (t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, scale: function (t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, normalize: function (t, i) {
                var n = e.len(i);
                return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t
            }, distance: function (t, e) {
                return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
            }, distanceSquare: function (t, e) {
                return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
            }, negate: function (t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, lerp: function (t, e, i, n) {
                return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
            }, applyTransform: function (t, e, i) {
                var n = e[0], r = e[1];
                return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
            }, min: function (t, e, i) {
                return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
            }, max: function (t, e, i) {
                return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
            }
        };
        return e[P] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e
    }), e("echarts/component/axis", [U, "../coord/cartesian/AxisModel", "./axis/AxisView"], function (t) {
        t("../coord/cartesian/AxisModel"), t("./axis/AxisView")
    }), e("echarts/coord/cartesian/Grid", [U, "exports", "../../util/layout", "../../coord/axisHelper", j, "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem"], function (t) {
        function e(t, e, i) {
            return i.getComponent("grid", t.get("gridIndex")) === e
        }

        function r(t) {
            var e, i = t.model, n = i.getFormattedLabels(), r = 1, a = n[P];
            a > 40 && (r = Math.ceil(a / 40));
            for (var o = 0; a > o; o += r)if (!t.isLabelIgnored(o)) {
                var s = i.getTextRect(n[o]);
                e ? e.union(s) : e = s
            }
            return e
        }

        function a(t, e, i) {
            this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t
        }

        function o(t, e) {
            var i = t[d](), n = i[0] + i[1];
            t.toGlobalCoord = "x" === t.dim ? function (t) {
                return t + e
            } : function (t) {
                return n - t + e
            }, t.toLocalCoord = "x" === t.dim ? function (t) {
                return t - e
            } : function (t) {
                return n - t + e
            }
        }

        var s = t("../../util/layout"), l = t("../../coord/axisHelper"), c = t(j), u = t("./Cartesian2D"), h = t("./Axis2D"), f = c.each, p = l.ifAxisCrossZero, g = l.niceScaleExtent;
        t("./GridModel");
        var m = a[H];
        return m.type = "grid", m.getRect = function () {
            return this._rect
        }, m.update = function (t, e) {
            function i(t) {
                var e = r[t];
                for (var i in e) {
                    var a = e[i];
                    if (a && (a.type === n || !p(a)))return !0
                }
                return !1
            }

            var r = this._axesMap;
            this._updateScale(t, this._model), f(r.x, function (t) {
                g(t, t.model)
            }), f(r.y, function (t) {
                g(t, t.model)
            }), f(r.x, function (t) {
                i("y") && (t.onZero = !1)
            }), f(r.y, function (t) {
                i("x") && (t.onZero = !1)
            }), this[G](this._model, e)
        }, m[G] = function (t, e) {
            function i() {
                f(a, function (t) {
                    var e = t.isHorizontal(), i = e ? [0, n.width] : [0, n[B]], r = t.inverse ? 1 : 0;
                    t.setExtent(i[r], i[1 - r]), o(t, e ? n.x : n.y)
                })
            }

            var n = s.getLayoutRect(t.getBoxLayoutParams(), {width: e[F](), height: e[N]()});
            this._rect = n;
            var a = this._axesList;
            i(), t.get("containLabel") && (f(a, function (t) {
                if (!t.model.get("axisLabel.inside")) {
                    var e = r(t);
                    if (e) {
                        var i = t.isHorizontal() ? B : "width", a = t.model.get("axisLabel.margin");
                        n[i] -= e[i] + a, "top" === t[v] ? n.y += e[B] + a : "left" === t[v] && (n.x += e.width + a)
                    }
                }
            }), i())
        }, m.getAxis = function (t, e) {
            var i = this._axesMap[t];
            if (null != i) {
                if (null == e)for (var n in i)return i[n];
                return i[e]
            }
        }, m.getCartesian = function (t, e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i]
        }, m._initCartesian = function (t, i) {
            function r(r) {
                return function (c, u) {
                    if (e(c, t, i)) {
                        var d = c.get(v);
                        "x" === r ? ("top" !== d && d !== E && (d = E), a[d] && (d = "top" === d ? E : "top")) : ("left" !== d && "right" !== d && (d = "left"), a[d] && (d = "left" === d ? "right" : "left")), a[d] = !0;
                        var f = new h(r, l.createScaleByModel(c), [0, 0], c.get("type"), d), p = f.type === n;
                        f.onBand = p && c.get("boundaryGap"), f.inverse = c.get("inverse"), f.onZero = c.get("axisLine.onZero"), c.axis = f, f.model = c, f.index = u, this._axesList.push(f), o[r][u] = f, s[r]++
                    }
                }
            }

            var a = {left: !1, right: !1, top: !1, bottom: !1}, o = {x: {}, y: {}}, s = {x: 0, y: 0};
            return i.eachComponent("xAxis", r("x"), this), i.eachComponent("yAxis", r("y"), this), s.x && s.y ? (this._axesMap = o, void f(o.x, function (t, e) {
                f(o.y, function (i, n) {
                    var r = "x" + e + "y" + n, a = new u(r);
                    a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
                }, this)
            }, this)) : (this._axesMap = {}, void(this._axesList = []))
        }, m._updateScale = function (t, n) {
            function r(t, e, n) {
                f(n.coordDimToDataDim(e.dim), function (n) {
                    e.scale.unionExtent(t.getDataExtent(n, e.scale.type !== i))
                })
            }

            c.each(this._axesList, function (t) {
                t.scale.setExtent(1 / 0, -1 / 0)
            }), t.eachSeries(function (i) {
                if ("cartesian2d" === i.get("coordinateSystem")) {
                    var a = i.get("xAxisIndex"), o = i.get("yAxisIndex"), s = t.getComponent("xAxis", a), l = t.getComponent("yAxis", o);
                    if (!e(s, n, t) || !e(l, n, t))return;
                    var c = this.getCartesian(a, o), u = i[z](), h = c.getAxis("x"), d = c.getAxis("y");
                    "list" === u.type && (r(u, h, i), r(u, d, i))
                }
            }, this)
        }, a[R] = function (t, e) {
            var i = [];
            return t.eachComponent("grid", function (n, r) {
                var o = new a(n, t, e);
                o.name = "grid_" + r, o[G](n, e), n.coordinateSystem = o, i.push(o)
            }), t.eachSeries(function (e) {
                if ("cartesian2d" === e.get("coordinateSystem")) {
                    var n = e.get("xAxisIndex"), r = t.getComponent("xAxis", n), a = i[r.get("gridIndex")];
                    e.coordinateSystem = a.getCartesian(n, e.get("yAxisIndex"))
                }
            }), i
        }, a.dimensions = u[H].dimensions, t("../../CoordinateSystem").register("cartesian2d", a), a
    }), e("echarts/component/legend/LegendModel", [U, j, "../../model/Model", "../../echarts"], function (t) {
        var e = t(j), i = t("../../model/Model"), n = t("../../echarts").extendComponentModel({
            type: "legend",
            dependencies: [L],
            layoutMode: {type: "box", ignoreSize: !0},
            init: function (t, e, i) {
                this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateData(i);
                var n = this._data, r = this.option.selected;
                if (n[0] && "single" === this.get("selectedMode")) {
                    var a = !1;
                    for (var o in r)r[o] && (this.select(o), a = !0);
                    !a && this.select(n[0].get("name"))
                }
            },
            mergeOption: function (t) {
                n.superCall(this, "mergeOption", t), this._updateData(this.ecModel)
            },
            _updateData: function (t) {
                var n = e.map(this.get("data") || [], function (t) {
                    return typeof t === q && (t = {name: t}), new i(t, this, this.ecModel)
                }, this);
                this._data = n;
                var r = e.map(t.getSeries(), function (t) {
                    return t.name
                });
                t.eachSeries(function (t) {
                    if (t.legendDataProvider) {
                        var e = t.legendDataProvider();
                        r = r[h](e.mapArray(e.getName))
                    }
                }), this._availableNames = r
            },
            getData: function () {
                return this._data
            },
            select: function (t) {
                var i = this.option.selected, n = this.get("selectedMode");
                if ("single" === n) {
                    var r = this._data;
                    e.each(r, function (t) {
                        i[t.get("name")] = !1
                    })
                }
                i[t] = !0
            },
            unSelect: function (t) {
                "single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
            },
            toggleSelected: function (t) {
                var e = this.option.selected;
                t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
            },
            isSelected: function (t) {
                var i = this.option.selected;
                return !(t in i && !i[t]) && e[w](this._availableNames, t) >= 0
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: "top",
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                textStyle: {color: "#333"},
                selectedMode: !0
            }
        });
        return n
    }), e("echarts/component/legend/legendAction", [U, "../../echarts", j], function (t) {
        function e(t, e, i) {
            var r, a = {}, o = "toggleSelected" === t;
            return i.eachComponent("legend", function (i) {
                o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
                var s = i[z]();
                n.each(s, function (t) {
                    var e = t.get("name");
                    if ("\n" !== e && "" !== e) {
                        var n = i.isSelected(e);
                        a[e] = e in a ? a[e] && n : n
                    }
                })
            }), {name: e.name, selected: a}
        }

        var i = t("../../echarts"), n = t(j);
        i.registerAction("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i.registerAction("legendSelect", "legendselected", n.curry(e, "select")), i.registerAction("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
    }), e("echarts/component/legend/LegendView", [U, j, "../../util/symbol", "../../util/graphic", "../helper/listComponent", "../../echarts"], function (t) {
        function e(t, e) {
            e.dispatchAction({type: "legendToggleSelect", name: t})
        }

        function i(t, e, i) {
            t.get("legendHoverLink") && i.dispatchAction({type: "highlight", seriesName: t.name, name: e})
        }

        function n(t, e, i) {
            t.get("legendHoverLink") && i.dispatchAction({type: "downplay", seriesName: t.name, name: e})
        }

        var r = t(j), a = t("../../util/symbol"), o = t("../../util/graphic"), s = t("../helper/listComponent"), l = r.curry, c = "#ccc";
        return t("../../echarts").extendComponentView({
            type: "legend", init: function () {
                this._symbolTypeStore = {}
            }, render: function (t, a, c) {
                var u = this.group;
                if (u.removeAll(), t.get("show")) {
                    var h = t.get("selectedMode"), d = t.get("align");
                    "auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
                    var f = {};
                    r.each(t[z](), function (r) {
                        var s = r.get("name");
                        if ("" === s || "\n" === s)return void u.add(new o.Group({newline: !0}));
                        var p = a.getSeriesByName(s)[0];
                        if (!f[s])if (p) {
                            var v = p[z](), g = v.getVisual("color");
                            typeof g === b && (g = g(p.getDataParams(0)));
                            var m = v.getVisual("legendSymbol") || "roundRect", y = v.getVisual("symbol"), x = this._createItem(s, r, t, m, y, d, g, h);
                            x.on("click", l(e, s, c)).on("mouseover", l(i, p, "", c)).on("mouseout", l(n, p, "", c)), f[s] = !0
                        } else a.eachRawSeries(function (a) {
                            if (!f[s] && a.legendDataProvider) {
                                var o = a.legendDataProvider(), u = o.indexOfName(s);
                                if (0 > u)return;
                                var p = o.getItemVisual(u, "color"), v = "roundRect", g = this._createItem(s, r, t, v, null, d, p, h);
                                g.on("click", l(e, s, c)).on("mouseover", l(i, a, s, c)).on("mouseout", l(n, a, s, c)), f[s] = !0
                            }
                        }, this)
                    }, this), s.layout(u, t, c), s.addBackground(u, t)
                }
            }, _createItem: function (t, e, i, n, r, s, l, u) {
                var h = i.get("itemWidth"), d = i.get("itemHeight"), f = i.isSelected(t), p = new o.Group, v = e[V](_), g = e.get("icon");
                if (n = g || n, p.add(a.createSymbol(n, 0, 0, h, d, f ? l : c)), !g && r && (r !== n || "none" == r)) {
                    var m = .8 * d;
                    "none" === r && (r = "circle"), p.add(a.createSymbol(r, (h - m) / 2, (d - m) / 2, m, m, f ? l : c))
                }
                var w = "left" === s ? h + 5 : -5, M = s, S = i.get("formatter");
                typeof S === q && S ? t = S[T]("{name}", t) : typeof S === b && (t = S(t));
                var C = new o.Text({
                    style: {
                        text: t,
                        x: w,
                        y: d / 2,
                        fill: f ? v.getTextColor() : c,
                        textFont: v[x](),
                        textAlign: M,
                        textVerticalAlign: "middle"
                    }
                });
                return p.add(C), p.add(new o.Rect({shape: p[y](), invisible: !0})), p.eachChild(function (t) {
                    t.silent = !u
                }), this.group.add(p), o.setHoverStyle(p), p
            }
        })
    }), e("echarts/component/legend/legendFilter", [], function () {
        return function (t) {
            var e = t.findComponents({mainType: "legend"});
            e && e[P] && t.filterSeries(function (t) {
                for (var i = 0; i < e[P]; i++)if (!e[i].isSelected(t.name))return !1;
                return !0
            })
        }
    }), e("echarts/chart/bar/BarSeries", [U, "../../model/Series", "../helper/createListFromArray"], function (t) {
        var e = t("../../model/Series"), i = t("../helper/createListFromArray");
        return e[D]({
            type: "series.bar",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, e) {
                return i(t.data, this, e)
            },
            getMarkerPosition: function (t) {
                var e = this.coordinateSystem;
                if (e) {
                    var i = e.dataToPoint(t), n = this[z](), r = n.getLayout("offset"), a = n.getLayout("size"), o = e.getBaseAxis().isHorizontal() ? 0 : 1;
                    return i[o] += r + a / 2, i
                }
                return [0 / 0, 0 / 0]
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                barMinHeight: 0,
                itemStyle: {
                    normal: {barBorderColor: "#fff", barBorderWidth: 0},
                    emphasis: {barBorderColor: "#fff", barBorderWidth: 0}
                }
            }
        })
    }), e("echarts/util/layout", [U, j, "zrender/core/BoundingRect", "./number", "./format"], function (t) {
        function e(t, e, i, n, r) {
            var a = 0, o = 0;
            null == n && (n = 1 / 0), null == r && (r = 1 / 0);
            var s = 0;
            e.eachChild(function (l, c) {
                var u, h, d = l[v], f = l[y](), p = e.childAt(c + 1), g = p && p[y]();
                if ("horizontal" === t) {
                    var m = f.width + (g ? -g.x + f.x : 0);
                    u = a + m, u > n || l.newline ? (a = 0, u = m, o += s + i, s = f[B]) : s = Math.max(s, f[B])
                } else {
                    var x = f[B] + (g ? -g.y + f.y : 0);
                    h = o + x, h > r || l.newline ? (a += s + i, o = 0, h = x, s = f.width) : s = Math.max(s, f.width)
                }
                l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = u + i : o = h + i)
            })
        }

        var i = t(j), n = t("zrender/core/BoundingRect"), r = t("./number"), a = t("./format"), o = r.parsePercent, s = i.each, l = {}, c = ["left", "right", "top", E, "width", B];
        return l.box = e, l.vbox = i.curry(e, "vertical"), l.hbox = i.curry(e, "horizontal"), l.getAvailableSize = function (t, e, i) {
            var n = e.width, r = e[B], s = o(t.x, n), l = o(t.y, r), c = o(t.x2, n), u = o(t.y2, r);
            return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0), (isNaN(c) || isNaN(parseFloat(t.x2))) && (c = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(u) || isNaN(parseFloat(t.y2))) && (u = r), i = a.normalizeCssArray(i || 0), {
                width: Math.max(c - s - i[1] - i[3], 0),
                height: Math.max(u - l - i[0] - i[2], 0)
            }
        }, l.getLayoutRect = function (t, e, i) {
            i = a.normalizeCssArray(i || 0);
            var r = e.width, s = e[B], l = o(t.left, r), c = o(t.top, s), u = o(t.right, r), h = o(t[E], s), d = o(t.width, r), f = o(t[B], s), p = i[2] + i[0], v = i[1] + i[3], y = t.aspect;
            switch (isNaN(d) && (d = r - u - v - l), isNaN(f) && (f = s - h - p - c), isNaN(d) && isNaN(f) && (y > r / s ? d = .8 * r : f = .8 * s), null != y && (isNaN(d) && (d = y * f), isNaN(f) && (f = d / y)), isNaN(l) && (l = r - u - d - v), isNaN(c) && (c = s - h - f - p), t.left || t.right) {
                case g:
                    l = r / 2 - d / 2 - i[3];
                    break;
                case"right":
                    l = r - d - v
            }
            switch (t.top || t[E]) {
                case m:
                case g:
                    c = s / 2 - f / 2 - i[0];
                    break;
                case E:
                    c = s - f - p
            }
            l = l || 0, c = c || 0, isNaN(d) && (d = r - l - (u || 0)), isNaN(f) && (f = s - c - (h || 0));
            var x = new n(l + i[3], c + i[0], d, f);
            return x.margin = i, x
        }, l.positionGroup = function (t, e, n, r) {
            var a = t[y]();
            e = i[D](i.clone(e), {
                width: a.width,
                height: a[B]
            }), e = l.getLayoutRect(e, n, r), t[v] = [e.x - a.x, e.y - a.y]
        }, l.mergeLayoutParam = function (t, e, n) {
            function r(i) {
                var r = {}, l = 0, c = {}, u = 0, h = n.ignoreSize ? 1 : 2;
                if (s(i, function (e) {
                        c[e] = t[e]
                    }), s(i, function (t) {
                        a(e, t) && (r[t] = c[t] = e[t]), o(r, t) && l++, o(c, t) && u++
                    }), u !== h && l) {
                    if (l >= h)return r;
                    for (var d = 0; d < i[P]; d++) {
                        var f = i[d];
                        if (!a(r, f) && a(t, f)) {
                            r[f] = t[f];
                            break
                        }
                    }
                    return r
                }
                return c
            }

            function a(t, e) {
                return t.hasOwnProperty(e)
            }

            function o(t, e) {
                return null != t[e] && "auto" !== t[e]
            }

            function l(t, e, i) {
                s(t, function (t) {
                    e[t] = i[t]
                })
            }

            !i[I](n) && (n = {});
            var c = ["width", "left", "right"], u = [B, "top", E], h = r(c), d = r(u);
            l(c, t, h), l(u, t, d)
        }, l.getLayoutParams = function (t) {
            return l.copyLayoutParams({}, t)
        }, l.copyLayoutParams = function (t, e) {
            return e && t && s(c, function (i) {
                e.hasOwnProperty(i) && (t[i] = e[i])
            }), t
        }, l
    }), e("echarts/chart/bar/BarView", [U, j, "../../util/graphic", "../../model/Model", "./barItemStyle", "../../echarts"], function (t) {
        function e(t, e) {
            var i = t.width > 0 ? 1 : -1, n = t[B] > 0 ? 1 : -1;
            e = Math.min(e, Math.abs(t.width), Math.abs(t[B])), t.x += i * e / 2, t.y += n * e / 2, t.width -= i * e, t[B] -= n * e
        }

        var i = t(j), n = t("../../util/graphic");
        return i[D](t("../../model/Model")[H], t("./barItemStyle")), t("../../echarts").extendChartView({
            type: "bar",
            render: function (t, e, i) {
                var n = t.get("coordinateSystem");
                return "cartesian2d" === n && this._renderOnCartesian(t, e, i), this.group
            },
            _renderOnCartesian: function (t) {
                function r(r, a) {
                    var s = o.getItemLayout(r), l = o.getItemModel(r).get(f) || 0;
                    e(s, l);
                    var c = new n.Rect({shape: i[D]({}, s)});
                    if (d) {
                        var u = c.shape, p = h ? B : "width", v = {};
                        u[p] = 0, v[p] = s[p], n[a ? "updateProps" : "initProps"](c, {shape: v}, t, r)
                    }
                    return c
                }

                var a = this.group, o = t[z](), l = this._data, c = t.coordinateSystem, u = c.getBaseAxis(), h = u.isHorizontal(), d = t.get("animation"), f = ["itemStyle", s, "barBorderWidth"];
                o.diff(l).add(function (t) {
                    if (o.hasValue(t)) {
                        var e = r(t);
                        o.setItemGraphicEl(t, e), a.add(e)
                    }
                }).update(function (i, s) {
                    var c = l.getItemGraphicEl(s);
                    if (!o.hasValue(i))return void a.remove(c);
                    c || (c = r(i, !0));
                    var u = o.getItemLayout(i), h = o.getItemModel(i).get(f) || 0;
                    e(u, h), n.updateProps(c, {shape: u}, t, i), o.setItemGraphicEl(i, c), a.add(c)
                }).remove(function (e) {
                    var i = l.getItemGraphicEl(e);
                    i && (i.style.text = "", n.updateProps(i, {shape: {width: 0}}, t, e, function () {
                        a.remove(i)
                    }))
                }).execute(), this._updateStyle(t, o, h), this._data = o
            },
            _updateStyle: function (t, e, r) {
                function a(t, e, i, r, a) {
                    n.setText(t, e, i), t.text = r, "outside" === t.textPosition && (t.textPosition = a)
                }

                e.eachItemGraphicEl(function (o, l) {
                    var c = e.getItemModel(l), u = e.getItemVisual(l, "color"), h = e.getItemVisual(l, p), d = e.getItemLayout(l), f = c[V]("itemStyle.normal"), v = c[V]("itemStyle.emphasis").getBarItemStyle();
                    o.setShape("r", f.get("barBorderRadius") || 0), o.useStyle(i[k]({
                        fill: u,
                        opacity: h
                    }, f.getBarItemStyle()));
                    var g = r ? d[B] > 0 ? E : "top" : d.width > 0 ? "left" : "right", m = c[V]("label.normal"), y = c[V]("label.emphasis"), x = o.style;
                    m.get("show") ? a(x, m, u, i.retrieve(t.getFormattedLabel(l, s), t.getRawValue(l)), g) : x.text = "", y.get("show") ? a(v, y, u, i.retrieve(t.getFormattedLabel(l, "emphasis"), t.getRawValue(l)), g) : v.text = "", n.setHoverStyle(o, v)
                })
            },
            remove: function (t) {
                var e = this.group;
                t.get("animation") ? this._data && this._data.eachItemGraphicEl(function (i) {
                    i.style.text = "", n.updateProps(i, {shape: {width: 0}}, t, i.dataIndex, function () {
                        e.remove(i)
                    })
                }) : e.removeAll()
            }
        })
    }), e("echarts/layout/barGrid", [U, j, "../util/number"], function (t) {
        function e(t) {
            return t.get("stack") || "__ec_stack_" + t[S]
        }

        function i(t) {
            var i = {};
            r.each(t, function (t) {
                var n = t.coordinateSystem, r = n.getBaseAxis(), a = i[r.index] || {
                        remainedWidth: r.getBandWidth(),
                        autoWidthCount: 0,
                        categoryGap: "20%",
                        gap: "30%",
                        axis: r,
                        stacks: {}
                    }, o = a.stacks;
                i[r.index] = a;
                var s = e(t);
                o[s] || a.autoWidthCount++, o[s] = o[s] || {width: 0, maxWidth: 0};
                var l = t.get("barWidth"), c = t.get("barMaxWidth"), u = t.get("barGap"), h = t.get("barCategoryGap");
                l && !o[s].width && (l = Math.min(a.remainedWidth, l), o[s].width = l, a.remainedWidth -= l), c && (o[s].maxWidth = c), null != u && (a.gap = u), null != h && (a.categoryGap = h)
            });
            var n = {};
            return r.each(i, function (t, e) {
                n[e] = {};
                var i = t.stacks, a = t.axis, s = a.getBandWidth(), l = o(t.categoryGap, s), c = o(t.gap, 1), u = t.remainedWidth, h = t.autoWidthCount, d = (u - l) / (h + (h - 1) * c);
                d = Math.max(d, 0), r.each(i, function (t) {
                    var e = t.maxWidth;
                    !t.width && e && d > e && (e = Math.min(e, u), u -= e, t.width = e, h--)
                }), d = (u - l) / (h + (h - 1) * c), d = Math.max(d, 0);
                var f, p = 0;
                r.each(i, function (t) {
                    t.width || (t.width = d), f = t, p += t.width * (1 + c)
                }), f && (p -= f.width * c);
                var v = -p / 2;
                r.each(i, function (t, i) {
                    n[e][i] = n[e][i] || {offset: v, width: t.width}, v += t.width * (1 + c)
                })
            }), n
        }

        function n(t, n) {
            var a = i(r[X](n.getSeriesByType(t), function (t) {
                return !n.isSeriesFiltered(t) && t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
            })), o = {};
            n.eachSeriesByType(t, function (t) {
                var i = t[z](), n = t.coordinateSystem, r = n.getBaseAxis(), s = e(t), l = a[r.index][s], c = l.offset, u = l.width, h = n.getOtherAxis(r), d = t.get("barMinHeight") || 0, f = r.onZero ? h.toGlobalCoord(h.dataToCoord(0)) : h.getGlobalExtent()[0], p = n.dataToPoints(i, !0);
                o[s] = o[s] || [], i.setLayout({offset: c, size: u}), i.each(h.dim, function (t, e) {
                    if (!isNaN(t)) {
                        o[s][e] || (o[s][e] = {p: f, n: f});
                        var n, r, a, l, v = t >= 0 ? "p" : "n", g = p[e], m = o[s][e][v];
                        h.isHorizontal() ? (n = m, r = g[1] + c, a = g[0] - m, l = u, Math.abs(a) < d && (a = (0 > a ? -1 : 1) * d), o[s][e][v] += a) : (n = g[0] + c, r = m, a = u, l = g[1] - m, Math.abs(l) < d && (l = (0 >= l ? -1 : 1) * d), o[s][e][v] += l), i.setItemLayout(e, {
                            x: n,
                            y: r,
                            width: a,
                            height: l
                        })
                    }
                }, !0)
            }, this)
        }

        var r = t(j), a = t("../util/number"), o = a.parsePercent;
        return n
    }), e("echarts/component/tooltip/TooltipModel", [U, "../../echarts"], function (t) {
        t("../../echarts").extendComponentModel({
            type: "tooltip",
            defaultOption: {
                zlevel: 0,
                z: 8,
                show: !0,
                showContent: !0,
                trigger: "item",
                triggerOn: "mousemove",
                alwaysShowContent: !1,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: .4,
                enterable: !1,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: !0,
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    lineStyle: {color: "#555", width: 1, type: "solid"},
                    crossStyle: {color: "#555", width: 1, type: "dashed", textStyle: {}},
                    shadowStyle: {color: "rgba(150,150,150,0.3)"}
                },
                textStyle: {color: "#fff", fontSize: 14}
            }
        })
    }), e("echarts/component/tooltip/TooltipView", [U, "./TooltipContent", "../../util/graphic", j, "../../util/format", "../../util/number", "zrender/core/env", "../../echarts"], function (t) {
        function e(t, e) {
            if (!t || !e)return !1;
            var i = T.round;
            return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
        }

        function i(t, e, i, n) {
            return {x1: t, y1: e, x2: i, y2: n}
        }

        function r(t, e, i, n) {
            return {x: t, y: e, width: i, height: n}
        }

        function a(t, e, i, n, r, a) {
            return {cx: t, cy: e, r0: i, r: n, startAngle: r, endAngle: a, clockwise: !0}
        }

        function o(t, e, i, n, r) {
            var a = i.clientWidth, o = i.clientHeight, s = 20;
            return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e]
        }

        function s(t, e, i) {
            var n = i.clientWidth, r = i.clientHeight, a = 5, o = 0, s = 0, l = e.width, c = e[B];
            switch (t) {
                case"inside":
                    o = e.x + l / 2 - n / 2, s = e.y + c / 2 - r / 2;
                    break;
                case"top":
                    o = e.x + l / 2 - n / 2, s = e.y - r - a;
                    break;
                case E:
                    o = e.x + l / 2 - n / 2, s = e.y + c + a;
                    break;
                case"left":
                    o = e.x - n - a, s = e.y + c / 2 - r / 2;
                    break;
                case"right":
                    o = e.x + l + a, s = e.y + c / 2 - r / 2
            }
            return [o, s]
        }

        function c(t, e, i, n, r, a, l) {
            var c = l[F](), h = l[N](), d = a && a[y]().clone();
            if (a && d[u](a[Z]), typeof t === b && (t = t([e, i], r, n.el, d)), g[M](t))e = A(t[0], c), i = A(t[1], h); else if (typeof t === q && a) {
                var f = s(t, d, n.el);
                e = f[0], i = f[1]
            } else {
                var f = o(e, i, n.el, c, h);
                e = f[0], i = f[1]
            }
            n.moveTo(e, i)
        }

        function h(t) {
            var e = t.coordinateSystem, i = t.get("tooltip.trigger", !0);
            return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "single" !== e.type || "item" === i)
        }

        var f = t("./TooltipContent"), p = t("../../util/graphic"), g = t(j), m = t("../../util/format"), T = t("../../util/number"), A = T.parsePercent, P = t("zrender/core/env");
        t("../../echarts").extendComponentView({
            type: "tooltip", _axisPointers: {}, init: function (t, e) {
                if (!P.node) {
                    var i = new f(e.getDom(), e);
                    this._tooltipContent = i, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this)
                }
            }, render: function (t, e, i) {
                if (!P.node) {
                    this.group.removeAll(), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
                    var n = this._tooltipContent;
                    n.update(), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                    var r = this._crossText;
                    if (r && this.group.add(r), null != this._lastX && null != this._lastY) {
                        var a = this;
                        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
                            a._manuallyShowTip({x: a._lastX, y: a._lastY})
                        })
                    }
                    var o = this._api.getZr();
                    o.off("click", this._tryShow), o.off("mousemove", this._mousemove), o.off("mouseout", this._hide), o.off("globalout", this._hide), "click" === t.get("triggerOn") ? o.on("click", this._tryShow, this) : (o.on("mousemove", this._mousemove, this), o.on("mouseout", this._hide, this), o.on("globalout", this._hide, this))
                }
            }, _mousemove: function (t) {
                var e = this._tooltipModel.get("showDelay"), i = this;
                clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function () {
                    i._tryShow(t)
                }, e) : this._tryShow(t)
            }, _manuallyShowTip: function (t) {
                if (t.from !== this.uid) {
                    var e = this._ecModel, i = t[S], n = t.dataIndex, r = e.getSeriesByIndex(i), a = this._api;
                    if (null == t.x || null == t.y) {
                        if (r || e.eachSeries(function (t) {
                                h(t) && !r && (r = t)
                            }), r) {
                            var o = r[z]();
                            null == n && (n = o.indexOfName(t.name));
                            var s, l, c = o.getItemGraphicEl(n), d = r.coordinateSystem;
                            if (d && d.dataToPoint) {
                                var f = d.dataToPoint(o.getValues(g.map(d.dimensions, function (t) {
                                    return r.coordDimToDataDim(t)[0]
                                }), n, !0));
                                s = f && f[0], l = f && f[1]
                            } else if (c) {
                                var p = c[y]().clone();
                                p[u](c[Z]), s = p.x + p.width / 2, l = p.y + p[B] / 2
                            }
                            null != s && null != l && this._tryShow({offsetX: s, offsetY: l, target: c, event: {}})
                        }
                    } else {
                        var c = a.getZr().handler.findHover(t.x, t.y);
                        this._tryShow({offsetX: t.x, offsetY: t.y, target: c, event: {}})
                    }
                }
            }, _manuallyHideTip: function (t) {
                t.from !== this.uid && this._hide()
            }, _prepareAxisTriggerData: function (t, e) {
                var i = {};
                return e.eachSeries(function (t) {
                    if (h(t)) {
                        var e, n, r = t.coordinateSystem;
                        "cartesian2d" === r.type ? (e = r.getBaseAxis(), n = e.dim + e.index) : "single" === r.type ? (e = r.getAxis(), n = e.dim + e.type) : (e = r.getBaseAxis(), n = e.dim + r.name), i[n] = i[n] || {
                            coordSys: [],
                            series: []
                        }, i[n].coordSys.push(r), i[n][L].push(t)
                    }
                }, this), i
            }, _tryShow: function (t) {
                var e = t[C], i = this._tooltipModel, n = i.get("trigger"), r = this._ecModel, a = this._api;
                if (i)if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e.dataIndex) {
                    var o = e.dataModel || r.getSeriesByIndex(e[S]), s = e.dataIndex, l = o[z]().getItemModel(s);
                    "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, e.dataType, t)), a.dispatchAction({
                        type: "showTip",
                        from: this.uid,
                        dataIndex: e.dataIndex,
                        seriesIndex: e[S]
                    })
                } else"item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a.dispatchAction({
                    type: "showTip",
                    from: this.uid,
                    x: t.offsetX,
                    y: t.offsetY
                })
            }, _showAxisTooltip: function (t, i, n) {
                var r = t[V]("axisPointer"), a = r.get("type");
                if ("cross" === a) {
                    var o = n[C];
                    if (o && null != o.dataIndex) {
                        var s = i.getSeriesByIndex(o[S]), l = o.dataIndex;
                        this._showItemTooltipContent(s, l, o.dataType, n)
                    }
                }
                this._showAxisPointer();
                var c = !0;
                g.each(this._seriesGroupByAxis, function (t) {
                    var i = t.coordSys, o = i[0], s = [n.offsetX, n.offsetY];
                    if (!o.containPoint(s))return void this._hideAxisPointer(o.name);
                    c = !1;
                    var l = o.dimensions, u = o.pointToData(s, !0);
                    s = o.dataToPoint(u);
                    var h = o.getBaseAxis(), d = r.get("axis");
                    "auto" === d && (d = h.dim);
                    var f = !1, p = this._lastHover;
                    if ("cross" === a)e(p.data, u) && (f = !0), p.data = u; else {
                        var v = g[w](l, d);
                        p.data === u[v] && (f = !0), p.data = u[v]
                    }
                    "cartesian2d" !== o.type || f ? "polar" !== o.type || f ? "single" !== o.type || f || this._showSinglePointer(r, o, d, s) : this._showPolarPointer(r, o, d, s) : this._showCartesianPointer(r, o, d, s), "cross" !== a && this._dispatchAndShowSeriesTooltipContent(o, t[L], s, u, f)
                }, this), this._tooltipModel.get("show") || this._hideAxisPointer(), c && this._hide()
            }, _showCartesianPointer: function (t, e, n, a) {
                function o(n, r, a) {
                    var o = "x" === n ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), s = l._getPointerElement(e, t, n, o);
                    u ? p.updateProps(s, {shape: o}, t) : s.attr({shape: o})
                }

                function s(i, n, a) {
                    var o = e.getAxis(i), s = o.getBandWidth(), c = a[1] - a[0], h = "x" === i ? r(n[0] - s / 2, a[0], s, c) : r(a[0], n[1] - s / 2, c, s), d = l._getPointerElement(e, t, i, h);
                    u ? p.updateProps(d, {shape: h}, t) : d.attr({shape: h})
                }

                var l = this, c = t.get("type"), u = "cross" !== c;
                if ("cross" === c)o("x", a, e.getAxis("y").getGlobalExtent()), o("y", a, e.getAxis("x").getGlobalExtent()), this._updateCrossText(e, a, t); else {
                    var h = e.getAxis("x" === n ? "y" : "x"), d = h.getGlobalExtent();
                    "cartesian2d" === e.type && ("line" === c ? o : s)(n, a, d)
                }
            }, _showSinglePointer: function (t, e, n, r) {
                function a(n, r, a) {
                    var s = e.getAxis(), c = s.orient, u = "horizontal" === c ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), h = o._getPointerElement(e, t, n, u);
                    l ? p.updateProps(h, {shape: u}, t) : h.attr({shape: u})
                }

                var o = this, s = t.get("type"), l = "cross" !== s, c = e.getRect(), u = [c.y, c.y + c[B]];
                a(n, r, u)
            }, _showPolarPointer: function (t, e, n, r) {
                function o(n, r, a) {
                    var o, s = e.pointToCoord(r);
                    if ("angle" === n) {
                        var c = e.coordToPoint([a[0], s[1]]), u = e.coordToPoint([a[1], s[1]]);
                        o = i(c[0], c[1], u[0], u[1])
                    } else o = {cx: e.cx, cy: e.cy, r: s[0]};
                    var h = l._getPointerElement(e, t, n, o);
                    f ? p.updateProps(h, {shape: o}, t) : h.attr({shape: o})
                }

                function s(i, n, r) {
                    var o, s = e.getAxis(i), c = s.getBandWidth(), u = e.pointToCoord(n), h = Math.PI / 180;
                    o = "angle" === i ? a(e.cx, e.cy, r[0], r[1], (-u[1] - c / 2) * h, (-u[1] + c / 2) * h) : a(e.cx, e.cy, u[0] - c / 2, u[0] + c / 2, 0, 2 * Math.PI);
                    var d = l._getPointerElement(e, t, i, o);
                    f ? p.updateProps(d, {shape: o}, t) : d.attr({shape: o})
                }

                var l = this, c = t.get("type"), u = e.getAngleAxis(), h = e.getRadiusAxis(), f = "cross" !== c;
                if ("cross" === c)o("angle", r, h[d]()), o("radius", r, u[d]()), this._updateCrossText(e, r, t); else {
                    var v = e.getAxis("radius" === n ? "angle" : "radius"), g = v[d]();
                    ("line" === c ? o : s)(n, r, g)
                }
            }, _updateCrossText: function (t, e, i) {
                var r = i[V]("crossStyle"), a = r[V](_), o = this._tooltipModel, s = this._crossText;
                s || (s = this._crossText = new p.Text({
                    style: {
                        textAlign: "left",
                        textVerticalAlign: "bottom"
                    }
                }), this.group.add(s));
                var l = t.pointToData(e), c = t.dimensions;
                l = g.map(l, function (e, i) {
                    var r = t.getAxis(c[i]);
                    return e = r.type === n || "time" === r.type ? r.scale.getLabel(e) : m.addCommas(e.toFixed(r.getPixelPrecision()))
                }), s.setStyle({
                    fill: a.getTextColor() || r.get("color"),
                    textFont: a[x](),
                    text: l.join(", "),
                    x: e[0] + 5,
                    y: e[1] - 5
                }), s.z = o.get("z"), s.zlevel = o.get("zlevel")
            }, _getPointerElement: function (t, e, i, n) {
                var r = this._tooltipModel, a = r.get("z"), o = r.get("zlevel"), s = this._axisPointers, c = t.name;
                if (s[c] = s[c] || {}, s[c][i])return s[c][i];
                var u = e.get("type"), h = e[V](u + "Style"), d = "shadow" === u, f = h[d ? "getAreaStyle" : "getLineStyle"](), v = "polar" === t.type ? d ? "Sector" : "radius" === i ? "Circle" : "Line" : d ? "Rect" : "Line";
                d ? f[l] = null : f.fill = null;
                var g = s[c][i] = new p[v]({style: f, z: a, zlevel: o, silent: !0, shape: n});
                return this.group.add(g), g
            }, _dispatchAndShowSeriesTooltipContent: function (t, e, i, n, r) {
                var a = this._tooltipModel, o = this._tooltipContent, s = t.getBaseAxis(), l = g.map(e, function (t) {
                    return {
                        seriesIndex: t[S],
                        dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(s.dim), n, s) : t[z]().indexOfNearest(t.coordDimToDataDim(s.dim)[0], n["x" === s.dim || "radius" === s.dim ? 0 : 1])
                    }
                }), u = this._lastHover, h = this._api;
                if (u.payloadBatch && !r && h.dispatchAction({
                        type: "downplay",
                        batch: u.payloadBatch
                    }), r || (h.dispatchAction({
                        type: "highlight",
                        batch: l
                    }), u.payloadBatch = l), h.dispatchAction({
                        type: "showTip",
                        dataIndex: l[0].dataIndex,
                        seriesIndex: l[0][S],
                        from: this.uid
                    }), s && a.get("showContent") && a.get("show")) {
                    var d, f = a.get("formatter"), p = a.get(v), y = g.map(e, function (t, e) {
                        return t.getDataParams(l[e].dataIndex)
                    });
                    o.show(a);
                    var x = l[0].dataIndex;
                    if (!r) {
                        if (this._ticket = "", f) {
                            if (typeof f === q)d = m.formatTpl(f, y); else if (typeof f === b) {
                                var _ = this, w = "axis_" + t.name + "_" + x, M = function (t, e) {
                                    t === _._ticket && (o.setContent(e), c(p, i[0], i[1], o, y, null, h))
                                };
                                _._ticket = w, d = f(y, w, M)
                            }
                        } else {
                            var T = e[0][z]().getName(x);
                            d = (T ? T + "<br />" : "") + g.map(e, function (t, e) {
                                return t.formatTooltip(l[e].dataIndex, !0)
                            }).join("<br />")
                        }
                        o.setContent(d)
                    }
                    c(p, i[0], i[1], o, y, null, h)
                }
            }, _showItemTooltipContent: function (t, e, i, n) {
                var r = this._api, a = t[z](i), o = a.getItemModel(e), s = this._tooltipModel, l = this._tooltipContent, u = o[V]("tooltip");
                if (u.parentModel ? u.parentModel.parentModel = s : u.parentModel = this._tooltipModel, u.get("showContent") && u.get("show")) {
                    var h, d = u.get("formatter"), f = u.get(v), p = t.getDataParams(e, i);
                    if (d) {
                        if (typeof d === q)h = m.formatTpl(d, p); else if (typeof d === b) {
                            var g = this, y = "item_" + t.name + "_" + e, x = function (t, e) {
                                t === g._ticket && (l.setContent(e), c(f, n.offsetX, n.offsetY, l, p, n[C], r))
                            };
                            g._ticket = y, h = d(p, y, x)
                        }
                    } else h = t.formatTooltip(e, !1, i);
                    l.show(u), l.setContent(h), c(f, n.offsetX, n.offsetY, l, p, n[C], r)
                }
            }, _showAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && g.each(e, function (t) {
                        t.show()
                    })
                } else this.group.eachChild(function (t) {
                    t.show()
                }), this.group.show()
            }, _resetLastHover: function () {
                var t = this._lastHover;
                t.payloadBatch && this._api.dispatchAction({
                    type: "downplay",
                    batch: t.payloadBatch
                }), this._lastHover = {}
            }, _hideAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && g.each(e, function (t) {
                        t.hide()
                    })
                } else this.group.hide()
            }, _hide: function () {
                clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api.dispatchAction({
                    type: "hideTip",
                    from: this.uid
                }), this._lastX = this._lastY = null
            }, dispose: function (t, e) {
                if (!P.node) {
                    var i = e.getZr();
                    this._tooltipContent.hide(), i.off("click", this._tryShow), i.off("mousemove", this._mousemove), i.off("mouseout", this._hide), i.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip)
                }
            }
        })
    }), e("zrender/vml/graphic", [U, "../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"], function (t) {
        if (!t("../core/env").canvasSupported) {
            var e = t("../core/vector"), i = t("../core/BoundingRect"), n = t("../core/PathProxy").CMD, r = t("../tool/color"), a = t("../contain/text"), h = t("../graphic/mixin/RectText"), d = t("../graphic/Displayable"), f = t("../graphic/Image"), v = t("../graphic/Text"), x = t("../graphic/Path"), _ = t("../graphic/Gradient"), b = t("./core"), w = Math.round, M = Math.sqrt, S = Math.abs, C = Math.cos, z = Math.sin, A = Math.max, L = e[u], k = ",", D = "progid:DXImageTransform.Microsoft", I = 21600, R = I / 2, O = 1e5, N = 1e3, F = function (t) {
                t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = I + "," + I, t.coordorigin = "0,0"
            }, V = function (t) {
                return String(t)[T](/&/g, "&amp;")[T](/"/g, "&quot;")
            }, G = function (t, e, i) {
                return "rgb(" + [t, e, i].join(",") + ")"
            }, W = function (t, e) {
                e && t && e.parentNode !== t && t.appendChild(e)
            }, j = function (t, e) {
                e && t && e.parentNode === t && t.removeChild(e)
            }, U = function (t, e, i) {
                return (parseFloat(t) || 0) * O + (parseFloat(e) || 0) * N + i
            }, Y = function (t, e) {
                return typeof t === q ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
            }, Q = function (t, e, i) {
                var n = r.parse(e);
                i = +i, isNaN(i) && (i = 1), n && (t.color = G(n[0], n[1], n[2]), t[p] = i * n[3])
            }, $ = function (t) {
                var e = r.parse(t);
                return [G(e[0], e[1], e[2]), e[3]]
            }, K = function (t, e, i) {
                var n = e.fill;
                if (null != n)if (n instanceof _) {
                    var r, a = 0, o = [0, 0], s = 0, l = 1, c = i[y](), u = c.width, h = c[B];
                    if ("linear" === n.type) {
                        r = "gradient";
                        var d = i[Z], f = [n.x * u, n.y * h], v = [n.x2 * u, n.y2 * h];
                        d && (L(f, f, d), L(v, v, d));
                        var g = v[0] - f[0], m = v[1] - f[1];
                        a = 180 * Math.atan2(g, m) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0)
                    } else {
                        r = "gradientradial";
                        var f = [n.x * u, n.y * h], d = i[Z], x = i.scale, b = u, w = h;
                        o = [(f[0] - c.x) / b, (f[1] - c.y) / w], d && L(f, f, d), b /= x[0] * I, w /= x[1] * I;
                        var M = A(b, w);
                        s = 0 / M, l = 2 * n.r / M - s
                    }
                    var T = n.colorStops.slice();
                    T.sort(function (t, e) {
                        return t.offset - e.offset
                    });
                    for (var S = T[P], C = [], z = [], k = 0; S > k; k++) {
                        var D = T[k], R = $(D.color);
                        z.push(D.offset * l + s + " " + R[0]), (0 === k || k === S - 1) && C.push(R)
                    }
                    if (S >= 2) {
                        var E = C[0][0], O = C[1][0], N = C[0][1] * e[p], F = C[1][1] * e[p];
                        t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = E, t.color2 = O, t.colors = z.join(","), t[p] = F, t.opacity2 = N
                    }
                    "radial" === r && (t.focusposition = o.join(","))
                } else Q(t, n, e[p])
            }, J = function (t, e) {
                null != e.lineJoin && (t.joinstyle = e.lineJoin), null != e.miterLimit && (t.miterlimit = e.miterLimit * I), null != e.lineCap && (t.endcap = e.lineCap), null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e[l] || e[l]instanceof _ || Q(t, e[l], e[p])
            }, te = function (t, e, i, n) {
                var r = "fill" == e, a = t.getElementsByTagName(e)[0];
                null != i[e] && "none" !== i[e] && (r || !r && i[c]) ? (t[r ? "filled" : "stroked"] = "true", i[e]instanceof _ && j(t, a), a || (a = b.createNode(e)), r ? K(a, i, n) : J(a, i), W(t, a)) : (t[r ? "filled" : "stroked"] = "false", j(t, a))
            }, ee = [[], [], []], ie = function (t, e) {
                var i, r, a, o, s, l, c = n.M, u = n.C, h = n.L, d = n.A, f = n.Q, p = [];
                for (o = 0; o < t[P];) {
                    switch (a = t[o++], r = "", i = 0, a) {
                        case c:
                            r = " m ", i = 1, s = t[o++], l = t[o++], ee[0][0] = s, ee[0][1] = l;
                            break;
                        case h:
                            r = " l ", i = 1, s = t[o++], l = t[o++], ee[0][0] = s, ee[0][1] = l;
                            break;
                        case f:
                        case u:
                            r = " c ", i = 3;
                            var v, g, m = t[o++], y = t[o++], x = t[o++], _ = t[o++];
                            a === f ? (v = x, g = _, x = (x + 2 * m) / 3, _ = (_ + 2 * y) / 3, m = (s + 2 * m) / 3, y = (l + 2 * y) / 3) : (v = t[o++], g = t[o++]), ee[0][0] = m, ee[0][1] = y, ee[1][0] = x, ee[1][1] = _, ee[2][0] = v, ee[2][1] = g, s = v, l = g;
                            break;
                        case d:
                            var b = 0, T = 0, S = 1, A = 1, D = 0;
                            e && (b = e[4], T = e[5], S = M(e[0] * e[0] + e[1] * e[1]), A = M(e[2] * e[2] + e[3] * e[3]), D = Math.atan2(-e[1] / A, e[0] / S));
                            var B = t[o++], E = t[o++], O = t[o++], N = t[o++], F = t[o++] + D, V = t[o++] + F + D;
                            o++;
                            var G = t[o++], q = B + C(F) * O, H = E + z(F) * N, m = B + C(V) * O, y = E + z(V) * N, W = G ? " wa " : " at ";
                            Math.abs(q - m) < 1e-10 && (Math.abs(V - F) > .01 ? G && (q += 270 / I) : Math.abs(H - E) < 1e-10 ? G && B > q || !G && q > B ? y -= 270 / I : y += 270 / I : G && E > H || !G && H > E ? m += 270 / I : m -= 270 / I), p.push(W, w(((B - O) * S + b) * I - R), k, w(((E - N) * A + T) * I - R), k, w(((B + O) * S + b) * I - R), k, w(((E + N) * A + T) * I - R), k, w((q * S + b) * I - R), k, w((H * A + T) * I - R), k, w((m * S + b) * I - R), k, w((y * A + T) * I - R)), s = m, l = y;
                            break;
                        case n.R:
                            var X = ee[0], Z = ee[1];
                            X[0] = t[o++], X[1] = t[o++], Z[0] = X[0] + t[o++], Z[1] = X[1] + t[o++], e && (L(X, X, e), L(Z, Z, e)), X[0] = w(X[0] * I - R), Z[0] = w(Z[0] * I - R), X[1] = w(X[1] * I - R), Z[1] = w(Z[1] * I - R), p.push(" m ", X[0], k, X[1], " l ", Z[0], k, X[1], " l ", Z[0], k, Z[1], " l ", X[0], k, Z[1]);
                            break;
                        case n.Z:
                            p.push(" x ")
                    }
                    if (i > 0) {
                        p.push(r);
                        for (var j = 0; i > j; j++) {
                            var U = ee[j];
                            e && L(U, U, e), p.push(w(U[0] * I - R), k, w(U[1] * I - R), i - 1 > j ? k : "")
                        }
                    }
                }
                return p.join("")
            };
            x[H].brushVML = function (t) {
                var e = this.style, i = this._vmlEl;
                i || (i = b.createNode("shape"), F(i), this._vmlEl = i), te(i, "fill", e, this), te(i, l, e, this);
                var n = this[Z], r = null != n, a = i.getElementsByTagName(l)[0];
                if (a) {
                    var o = e[c];
                    if (r && !e.strokeNoScale) {
                        var s = n[0] * n[3] - n[1] * n[2];
                        o *= M(S(s))
                    }
                    a.weight = o + "px"
                }
                var u = this.path;
                this.__dirtyPath && (u.beginPath(), this.buildPath(u, this.shape), u.toStatic(), this.__dirtyPath = !1), i.path = ie(u.data, this[Z]), i.style.zIndex = U(this.zlevel, this.z, this.z2), W(t, i), e.text ? this.drawRectText(t, this[y]()) : this.removeRectText(t)
            }, x[H].onRemove = function (t) {
                j(t, this._vmlEl), this.removeRectText(t)
            }, x[H].onAdd = function (t) {
                W(t, this._vmlEl), this.appendRectText(t)
            };
            var ne = function (t) {
                return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
            };
            f[H].brushVML = function (t) {
                var e, i, n = this.style, r = n.image;
                if (ne(r)) {
                    var a = r.src;
                    if (a === this._imageSrc)e = this._imageWidth, i = this._imageHeight; else {
                        var s = r.runtimeStyle, l = s.width, c = s[B];
                        s.width = "auto", s[B] = "auto", e = r.width, i = r[B], s.width = l, s[B] = c, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i
                    }
                    r = a
                } else r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
                if (r) {
                    var u = n.x || 0, h = n.y || 0, d = n.width, f = n[B], v = n.sWidth, g = n.sHeight, m = n.sx || 0, x = n.sy || 0, _ = v && g, T = this._vmlEl;
                    T || (T = b.doc[o]("div"), F(T), this._vmlEl = T);
                    var S, C = T.style, z = !1, P = 1, I = 1;
                    if (this[Z] && (S = this[Z], P = M(S[0] * S[0] + S[1] * S[1]), I = M(S[2] * S[2] + S[3] * S[3]), z = S[1] || S[2]), z) {
                        var R = [u, h], E = [u + d, h], O = [u, h + f], N = [u + d, h + f];
                        L(R, R, S), L(E, E, S), L(O, O, S), L(N, N, S);
                        var V = A(R[0], E[0], O[0], N[0]), G = A(R[1], E[1], O[1], N[1]), q = [];
                        q.push("M11=", S[0] / P, k, "M12=", S[2] / I, k, "M21=", S[1] / P, k, "M22=", S[3] / I, k, "Dx=", w(u * P + S[4]), k, "Dy=", w(h * I + S[5])), C.padding = "0 " + w(V) + "px " + w(G) + "px 0", C[X] = D + ".Matrix(" + q.join("") + ", SizingMethod=clip)"
                    } else S && (u = u * P + S[4], h = h * I + S[5]), C[X] = "", C.left = w(u) + "px", C.top = w(h) + "px";
                    var H = this._imageEl, j = this._cropEl;
                    H || (H = b.doc[o]("div"), this._imageEl = H);
                    var Y = H.style;
                    if (_) {
                        if (e && i)Y.width = w(P * e * d / v) + "px", Y[B] = w(I * i * f / g) + "px"; else {
                            var Q = new Image, $ = this;
                            Q.onload = function () {
                                Q.onload = null, e = Q.width, i = Q[B], Y.width = w(P * e * d / v) + "px", Y[B] = w(I * i * f / g) + "px", $._imageWidth = e, $._imageHeight = i, $._imageSrc = r
                            }, Q.src = r
                        }
                        j || (j = b.doc[o]("div"), j.style.overflow = "hidden", this._cropEl = j);
                        var K = j.style;
                        K.width = w((d + m * d / v) * P), K[B] = w((f + x * f / g) * I), K[X] = D + ".Matrix(Dx=" + -m * d / v * P + ",Dy=" + -x * f / g * I + ")", j.parentNode || T.appendChild(j), H.parentNode != j && j.appendChild(H)
                    } else Y.width = w(P * d) + "px", Y[B] = w(I * f) + "px", T.appendChild(H), j && j.parentNode && (T.removeChild(j), this._cropEl = null);
                    var J = "", te = n[p];
                    1 > te && (J += ".Alpha(opacity=" + w(100 * te) + ") "), J += D + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", Y[X] = J, T.style.zIndex = U(this.zlevel, this.z, this.z2), W(t, T), n.text && this.drawRectText(t, this[y]())
                }
            }, f[H].onRemove = function (t) {
                j(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
            }, f[H].onAdd = function (t) {
                W(t, this._vmlEl), this.appendRectText(t)
            };
            var re, ae = s, oe = {}, se = 0, le = 100, ce = document[o]("div"), ue = function (t) {
                var e = oe[t];
                if (!e) {
                    se > le && (se = 0, oe = {});
                    var i, n = ce.style;
                    try {
                        n.font = t, i = n.fontFamily.split(",")[0]
                    } catch (r) {
                    }
                    e = {
                        style: n.fontStyle || ae,
                        variant: n.fontVariant || ae,
                        weight: n.fontWeight || ae,
                        size: 0 | parseFloat(n.fontSize || 12),
                        family: i || "Microsoft YaHei"
                    }, oe[t] = e, se++
                }
                return e
            };
            a.measureText = function (t, e) {
                var i = b.doc;
                re || (re = i[o]("div"), re.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", b.doc.body.appendChild(re));
                try {
                    re.style.font = e
                } catch (n) {
                }
                return re.innerHTML = "", re.appendChild(i.createTextNode(t)), {width: re.offsetWidth}
            };
            for (var he = new i, de = function (t, e, i, n) {
                var r = this.style, o = r.text;
                if (o) {
                    var s, c, h = r.textAlign, d = ue(r.textFont), f = d.style + " " + d.variant + " " + d.weight + " " + d.size + 'px "' + d.family + '"', v = r.textBaseline, x = r.textVerticalAlign;
                    i = i || a[y](o, f, h, v);
                    var _ = this[Z];
                    if (_ && !n && (he.copy(e), he[u](_), e = he), n)s = e.x, c = e.y; else {
                        var M = r.textPosition, T = r.textDistance;
                        if (M instanceof Array)s = e.x + Y(M[0], e.width), c = e.y + Y(M[1], e[B]), h = h || "left", v = v || "top"; else {
                            var S = a.adjustTextPositionOnRect(M, e, i, T);
                            s = S.x, c = S.y, h = h || S.textAlign, v = v || S.textBaseline
                        }
                    }
                    if (x) {
                        switch (x) {
                            case m:
                                c -= i[B] / 2;
                                break;
                            case E:
                                c -= i[B]
                        }
                        v = "top"
                    }
                    var C = d.size;
                    switch (v) {
                        case"hanging":
                        case"top":
                            c += C / 1.75;
                            break;
                        case m:
                            break;
                        default:
                            c -= C / 2.25
                    }
                    switch (h) {
                        case"left":
                            break;
                        case g:
                            s -= i.width / 2;
                            break;
                        case"right":
                            s -= i.width
                    }
                    var z, A, P, D = b.createNode, I = this._textVmlEl;
                    I ? (P = I.firstChild, z = P.nextSibling, A = z.nextSibling) : (I = D("line"), z = D("path"), A = D("textpath"), P = D("skew"), A.style["v-text-align"] = "left", F(I), z.textpathok = !0, A.on = !0, I.from = "0 0", I.to = "1000 0.05", W(I, P), W(I, z), W(I, A), this._textVmlEl = I);
                    var R = [s, c], O = I.style;
                    _ && n ? (L(R, R, _), P.on = !0, P.matrix = _[0].toFixed(3) + k + _[2].toFixed(3) + k + _[1].toFixed(3) + k + _[3].toFixed(3) + ",0,0", P.offset = (w(R[0]) || 0) + "," + (w(R[1]) || 0), P.origin = "0 0", O.left = "0px", O.top = "0px") : (P.on = !1, O.left = w(s) + "px", O.top = w(c) + "px"), A[q] = V(o);
                    try {
                        A.style.font = f
                    } catch (N) {
                    }
                    te(I, "fill", {
                        fill: n ? r.fill : r.textFill,
                        opacity: r[p]
                    }, this), te(I, l, {
                        stroke: n ? r[l] : r.textStroke,
                        opacity: r[p],
                        lineDash: r.lineDash
                    }, this), I.style.zIndex = U(this.zlevel, this.z, this.z2), W(t, I)
                }
            }, fe = function (t) {
                j(t, this._textVmlEl), this._textVmlEl = null
            }, pe = function (t) {
                W(t, this._textVmlEl)
            }, ve = [h, d, f, x, v], ge = 0; ge < ve[P]; ge++) {
                var me = ve[ge][H];
                me.drawRectText = de, me.removeRectText = fe, me.appendRectText = pe
            }
            v[H].brushVML = function (t) {
                var e = this.style;
                e.text ? this.drawRectText(t, {
                    x: e.x || 0,
                    y: e.y || 0,
                    width: 0,
                    height: 0
                }, this[y](), !0) : this.removeRectText(t)
            }, v[H].onRemove = function (t) {
                this.removeRectText(t)
            }, v[H].onAdd = function (t) {
                this.appendRectText(t)
            }
        }
    }), e("echarts/scale/Interval", [U, "../util/number", "../util/format", "./Scale"], function (t) {
        var e = t("../util/number"), i = t("../util/format"), n = t("./Scale"), r = Math.floor, a = Math.ceil, o = n[D]({
            type: "interval",
            _interval: 0,
            setExtent: function (t, e) {
                var i = this._extent;
                isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
            },
            unionExtent: function (t) {
                var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), o[H].setExtent.call(this, e[0], e[1])
            },
            getInterval: function () {
                return this._interval || this.niceTicks(), this._interval
            },
            setInterval: function (t) {
                this._interval = t, this._niceExtent = this._extent.slice()
            },
            getTicks: function () {
                this._interval || this.niceTicks();
                var t = this._interval, i = this._extent, n = [], r = 1e4;
                if (t) {
                    var a = this._niceExtent;
                    i[0] < a[0] && n.push(i[0]);
                    for (var o = a[0]; o <= a[1];)if (n.push(o), o = e.round(o + t), n[P] > r)return [];
                    i[1] > a[1] && n.push(i[1])
                }
                return n
            },
            getTicksLabels: function () {
                for (var t = [], e = this.getTicks(), i = 0; i < e[P]; i++)t.push(this.getLabel(e[i]));
                return t
            },
            getLabel: function (t) {
                return i.addCommas(t)
            },
            niceTicks: function (t) {
                t = t || 5;
                var i = this._extent, n = i[1] - i[0];
                if (isFinite(n)) {
                    0 > n && (n = -n, i.reverse());
                    var o = e.nice(n / t, !0), s = [e.round(a(i[0] / o) * o), e.round(r(i[1] / o) * o)];
                    this._interval = o, this._niceExtent = s
                }
            },
            niceExtent: function (t, i, n) {
                var o = this._extent;
                if (o[0] === o[1])if (0 !== o[0]) {
                    var s = o[0] / 2;
                    o[0] -= s, o[1] += s
                } else o[1] = 1;
                var l = o[1] - o[0];
                isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
                var c = this._interval;
                i || (o[0] = e.round(r(o[0] / c) * c)), n || (o[1] = e.round(a(o[1] / c) * c))
            }
        });
        return o[R] = function () {
            return new o
        }, o
    }), e("zrender/vml/Painter", [U, "../core/log", "./core"], function (t) {
        function e(t) {
            return parseInt(t, 10)
        }

        function i(t, e) {
            a.initVML(), this.root = t, this.storage = e;
            var i = document[o]("div"), n = document[o]("div");
            i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this[G]();
            var r = e.delFromMap, s = e.addToMap;
            e.delFromMap = function (t) {
                var i = e.get(t);
                r.call(e, t), i && i.onRemove && i.onRemove(n)
            }, e.addToMap = function (t) {
                t.onAdd && t.onAdd(n), s.call(e, t)
            }, this._firstPaint = !0
        }

        function n(t) {
            return function () {
                r('In IE8.0 VML mode painter not support method "' + t + '"')
            }
        }

        var r = t("../core/log"), a = t("./core");
        i[H] = {
            constructor: i, getViewportRoot: function () {
                return this._vmlViewport
            }, refresh: function () {
                var t = this.storage.getDisplayList(!0, !0);
                this._paintList(t)
            }, _paintList: function (t) {
                for (var e = this._vmlRoot, i = 0; i < t[P]; i++) {
                    var n = t[i];
                    n.invisible || n[O] ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1
                }
                this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
            }, resize: function () {
                var t = this._getWidth(), e = this._getHeight();
                if (this._width != t && this._height != e) {
                    this._width = t, this._height = e;
                    var i = this._vmlViewport.style;
                    i.width = t + "px", i[B] = e + "px"
                }
            }, dispose: function () {
                this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
            }, getWidth: function () {
                return this._width
            }, getHeight: function () {
                return this._height
            }, _getWidth: function () {
                var t = this.root, i = t.currentStyle;
                return (t.clientWidth || e(i.width)) - e(i.paddingLeft) - e(i.paddingRight) | 0
            }, _getHeight: function () {
                var t = this.root, i = t.currentStyle;
                return (t.clientHeight || e(i[B])) - e(i.paddingTop) - e(i.paddingBottom) | 0
            }
        };
        for (var s = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], l = 0; l < s[P]; l++) {
            var c = s[l];
            i[H][c] = n(c)
        }
        return i
    }), e("echarts/scale/Scale", [U, "../util/clazz"], function (t) {
        function e() {
            this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
        }

        var i = t("../util/clazz"), n = e[H];
        return n.parse = function (t) {
            return t
        }, n[f] = function (t) {
            var e = this._extent;
            return t >= e[0] && t <= e[1]
        }, n.normalize = function (t) {
            var e = this._extent;
            return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
        }, n.scale = function (t) {
            var e = this._extent;
            return t * (e[1] - e[0]) + e[0]
        }, n.unionExtent = function (t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
        }, n[d] = function () {
            return this._extent.slice()
        }, n.setExtent = function (t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
        }, n.getTicksLabels = function () {
            for (var t = [], e = this.getTicks(), i = 0; i < e[P]; i++)t.push(this.getLabel(e[i]));
            return t
        }, i.enableClassExtend(e), i.enableClassManagement(e, {registerWhenExtend: !0}), e
    }), e("echarts/util/model", [U, "./format", "./number", j], function (t) {
        var e = t("./format"), n = t("./number"), r = t(j), a = ["x", "y", "z", "radius", "angle"], o = {};
        return o.createNameEach = function (t, e) {
            t = t.slice();
            var i = r.map(t, o.capitalFirst);
            e = (e || []).slice();
            var n = r.map(e, o.capitalFirst);
            return function (a, o) {
                r.each(t, function (t, r) {
                    for (var s = {name: t, capital: i[r]}, l = 0; l < e[P]; l++)s[e[l]] = t + n[l];
                    a.call(o, s)
                })
            }
        }, o.capitalFirst = function (t) {
            return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
        }, o.eachAxisDim = o.createNameEach(a, ["axisIndex", "axis", "index"]), o.normalizeToArray = function (t) {
            return r[M](t) ? t : null == t ? [] : [t]
        }, o.createLinkedNodesFinder = function (t, e, i) {
            function n(t, e) {
                return r[w](e.nodes, t) >= 0
            }

            function a(t, n) {
                var a = !1;
                return e(function (e) {
                    r.each(i(t, e) || [], function (t) {
                        n.records[e.name][t] && (a = !0)
                    })
                }), a
            }

            function o(t, n) {
                n.nodes.push(t), e(function (e) {
                    r.each(i(t, e) || [], function (t) {
                        n.records[e.name][t] = !0
                    })
                })
            }

            return function (i) {
                function r(t) {
                    !n(t, s) && a(t, s) && (o(t, s), l = !0)
                }

                var s = {nodes: [], records: {}};
                if (e(function (t) {
                        s.records[t.name] = {}
                    }), !i)return s;
                o(i, s);
                var l;
                do l = !1, t(r); while (l);
                return s
            }
        }, o.defaultEmphasis = function (t, e) {
            if (t) {
                var i = t.emphasis = t.emphasis || {}, n = t[s] = t[s] || {};
                r.each(e, function (t) {
                    var e = r.retrieve(i[t], n[t]);
                    null != e && (i[t] = e)
                })
            }
        }, o.LABEL_OPTIONS = [v, "show", _, "distance", "formatter"], o.getDataItemValue = function (t) {
            return t && (null == t.value ? t : t.value)
        }, o.converDataValue = function (t, e) {
            var r = e && e.type;
            return r === i ? t : ("time" !== r || isFinite(t) || null == t || "-" === t || (t = +n.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
        }, o.dataFormatMixin = {
            getDataParams: function (t, e) {
                var i = this[z](e), n = this[S], r = this.name, a = this.getRawValue(t, e), o = i.getRawIndex(t), s = i.getName(t, !0), l = i.getRawDataItem(t);
                return {
                    componentType: this.mainType,
                    componentSubType: this.subType,
                    seriesType: this.mainType === L ? this.subType : null,
                    seriesIndex: n,
                    seriesName: r,
                    name: s,
                    dataIndex: o,
                    data: l,
                    dataType: e,
                    value: a,
                    color: i.getItemVisual(t, "color"),
                    $vars: ["seriesName", "name", "value"]
                }
            }, getFormattedLabel: function (t, i, n, a) {
                i = i || s;
                var o = this[z](n), l = o.getItemModel(t), c = this.getDataParams(t, n);
                null != a && r[M](c.value) && (c.value = c.value[a]);
                var u = l.get(["label", i, "formatter"]);
                return typeof u === b ? (c.status = i, u(c)) : typeof u === q ? e.formatTpl(u, c) : void 0
            }, getRawValue: function (t, e) {
                var i = this[z](e), n = i.getRawDataItem(t);
                return null != n ? r[I](n) && !r[M](n) ? n.value : n : void 0
            }, formatTooltip: r.noop
        }, o.mappingToExists = function (t, e) {
            e = (e || []).slice();
            var i = r.map(t || [], function (t) {
                return {exist: t}
            });
            return r.each(e, function (t, n) {
                if (r[I](t))for (var a = 0; a < i[P]; a++) {
                    var s = i[a].exist;
                    if (!i[a].option && (null != t.id && s.id === t.id + "" || null != t.name && !o.isIdInner(t) && !o.isIdInner(s) && s.name === t.name + "")) {
                        i[a].option = t, e[n] = null;
                        break
                    }
                }
            }), r.each(e, function (t) {
                if (r[I](t)) {
                    for (var e = 0; e < i[P]; e++) {
                        var n = i[e].exist;
                        if (!i[e].option && !o.isIdInner(n) && null == t.id) {
                            i[e].option = t;
                            break
                        }
                    }
                    e >= i[P] && i.push({option: t})
                }
            }), i
        }, o.isIdInner = function (t) {
            return r[I](t) && t.id && 0 === (t.id + "")[w]("\x00_ec_\x00")
        }, o
    }), e("echarts/model/Model", [U, j, "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function (t) {
        function e(t, e, i, n) {
            this.parentModel = e, this.ecModel = i, this.option = t, this.init && (arguments[P] <= 4 ? this.init(t, e, i, n) : this.init.apply(this, arguments))
        }

        var i = t(j), n = t("../util/clazz");
        e[H] = {
            constructor: e, init: null, mergeOption: function (t) {
                i.merge(this.option, t, !0)
            }, get: function (t, e) {
                if (!t)return this.option;
                typeof t === q && (t = t.split("."));
                for (var i = this.option, n = this.parentModel, r = 0; r < t[P] && (!t[r] || (i = i && "object" == typeof i ? i[t[r]] : null, null != i)); r++);
                return null == i && n && !e && (i = n.get(t)), i
            }, getShallow: function (t, e) {
                var i = this.option, n = i && i[t], r = this.parentModel;
                return null == n && r && !e && (n = r.getShallow(t)), n
            }, getModel: function (t, i) {
                var n = this.get(t, !0), r = this.parentModel, a = new e(n, i || r && r[V](t), this.ecModel);
                return a
            }, isEmpty: function () {
                return null == this.option
            }, restoreData: function () {
            }, clone: function () {
                var t = this.constructor;
                return new t(i.clone(this.option))
            }, setReadOnly: function (t) {
                n.setReadOnly(this, t)
            }
        }, n.enableClassExtend(e);
        var r = i.mixin;
        return r(e, t("./mixin/lineStyle")), r(e, t("./mixin/areaStyle")), r(e, t("./mixin/textStyle")), r(e, t("./mixin/itemStyle")), e
    }), e("echarts/model/globalDefault", [], function () {
        var t = "";
        return typeof navigator !== a && (t = navigator.platform || ""), {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            grid: {},
            textStyle: {
                fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            animation: !0,
            animationThreshold: 2e3,
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut"
        }
    }), e("zrender/tool/path", [U, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function (t) {
        function e(t, e, i, n, r, a, o, s, l, u, p) {
            var m = l * (f / 180), y = d(m) * (t - i) / 2 + h(m) * (e - n) / 2, x = -1 * h(m) * (t - i) / 2 + d(m) * (e - n) / 2, _ = y * y / (o * o) + x * x / (s * s);
            _ > 1 && (o *= c(_), s *= c(_));
            var b = (r === a ? -1 : 1) * c((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0, w = b * o * x / s, M = b * -s * y / o, T = (t + i) / 2 + d(m) * w - h(m) * M, S = (e + n) / 2 + h(m) * w + d(m) * M, C = g([1, 0], [(y - w) / o, (x - M) / s]), z = [(y - w) / o, (x - M) / s], A = [(-1 * y - w) / o, (-1 * x - M) / s], L = g(z, A);
            v(z, A) <= -1 && (L = f), v(z, A) >= 1 && (L = 0), 0 === a && L > 0 && (L -= 2 * f), 1 === a && 0 > L && (L += 2 * f), p.addData(u, T, S, o, s, C, L, m, a)
        }

        function i(t) {
            if (!t)return [];
            var i, n = t[T](/-/g, " -")[T](/  /g, " ")[T](/ /g, ",")[T](/,,/g, ",");
            for (i = 0; i < l[P]; i++)n = n[T](new RegExp(l[i], "g"), "|" + l[i]);
            var r, o = n.split("|"), s = 0, c = 0, u = new a, h = a.CMD;
            for (i = 1; i < o[P]; i++) {
                var d, f = o[i], p = f.charAt(0), v = 0, g = f.slice(1)[T](/e,-/g, "e-").split(",");
                g[P] > 0 && "" === g[0] && g.shift();
                for (var m = 0; m < g[P]; m++)g[m] = parseFloat(g[m]);
                for (; v < g[P] && !isNaN(g[v]) && !isNaN(g[0]);) {
                    var y, x, _, b, w, M, S, C = s, z = c;
                    switch (p) {
                        case"l":
                            s += g[v++], c += g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"L":
                            s = g[v++], c = g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"m":
                            s += g[v++], c += g[v++], d = h.M, u.addData(d, s, c), p = "l";
                            break;
                        case"M":
                            s = g[v++], c = g[v++], d = h.M, u.addData(d, s, c), p = "L";
                            break;
                        case"h":
                            s += g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"H":
                            s = g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"v":
                            c += g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"V":
                            c = g[v++], d = h.L, u.addData(d, s, c);
                            break;
                        case"C":
                            d = h.C, u.addData(d, g[v++], g[v++], g[v++], g[v++], g[v++], g[v++]), s = g[v - 2], c = g[v - 1];
                            break;
                        case"c":
                            d = h.C, u.addData(d, g[v++] + s, g[v++] + c, g[v++] + s, g[v++] + c, g[v++] + s, g[v++] + c), s += g[v - 2], c += g[v - 1];
                            break;
                        case"S":
                            y = s, x = c;
                            var A = u.len(), L = u.data;
                            r === h.C && (y += s - L[A - 4], x += c - L[A - 3]), d = h.C, C = g[v++], z = g[v++], s = g[v++], c = g[v++], u.addData(d, y, x, C, z, s, c);
                            break;
                        case"s":
                            y = s, x = c;
                            var A = u.len(), L = u.data;
                            r === h.C && (y += s - L[A - 4], x += c - L[A - 3]), d = h.C, C = s + g[v++], z = c + g[v++], s += g[v++], c += g[v++], u.addData(d, y, x, C, z, s, c);
                            break;
                        case"Q":
                            C = g[v++], z = g[v++], s = g[v++], c = g[v++], d = h.Q, u.addData(d, C, z, s, c);
                            break;
                        case"q":
                            C = g[v++] + s, z = g[v++] + c, s += g[v++], c += g[v++], d = h.Q, u.addData(d, C, z, s, c);
                            break;
                        case"T":
                            y = s, x = c;
                            var A = u.len(), L = u.data;
                            r === h.Q && (y += s - L[A - 4], x += c - L[A - 3]), s = g[v++], c = g[v++], d = h.Q, u.addData(d, y, x, s, c);
                            break;
                        case"t":
                            y = s, x = c;
                            var A = u.len(), L = u.data;
                            r === h.Q && (y += s - L[A - 4], x += c - L[A - 3]), s += g[v++], c += g[v++], d = h.Q, u.addData(d, y, x, s, c);
                            break;
                        case"A":
                            _ = g[v++], b = g[v++], w = g[v++], M = g[v++], S = g[v++], C = s, z = c, s = g[v++], c = g[v++], d = h.A, e(C, z, s, c, M, S, _, b, w, d, u);
                            break;
                        case"a":
                            _ = g[v++], b = g[v++], w = g[v++], M = g[v++], S = g[v++], C = s, z = c, s += g[v++], c += g[v++], d = h.A, e(C, z, s, c, M, S, _, b, w, d, u)
                    }
                }
                ("z" === p || "Z" === p) && (d = h.Z, u.addData(d)), r = d
            }
            return u.toStatic(), u
        }

        function n(t, e) {
            var n, r = i(t);
            return e = e || {}, e.buildPath = function (t) {
                t.setData(r.data), n && o(t, n);
                var e = t.getContext();
                e && t.rebuildPath(e)
            }, e[u] = function (t) {
                n || (n = s[R]()), s.mul(n, t, n)
            }, e
        }

        var r = t("../graphic/Path"), a = t("../core/PathProxy"), o = t("./transformPath"), s = t("../core/matrix"), l = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"], c = Math.sqrt, h = Math.sin, d = Math.cos, f = Math.PI, p = function (t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        }, v = function (t, e) {
            return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e))
        }, g = function (t, e) {
            return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(v(t, e))
        };
        return {
            createFromString: function (t, e) {
                return new r(n(t, e))
            }, extendFromString: function (t, e) {
                return r[D](n(t, e))
            }, mergePath: function (t, e) {
                var i, n, a = [], o = t[P];
                for (n = 0; o > n; n++)i = t[n], i.__dirty && i.buildPath(i.path, i.shape), a.push(i.path);
                var s = new r(e);
                return s.buildPath = function (t) {
                    t.appendPath(a);
                    var e = t.getContext();
                    e && t.rebuildPath(e)
                }, s
            }
        }
    }), e("zrender/graphic/Path", [U, "./Displayable", r, "../core/PathProxy", "../contain/path", "./Gradient"], function (t) {
        function e(t) {
            var e = t.fill;
            return null != e && "none" !== e
        }

        function i(t) {
            var e = t[l];
            return null != e && "none" !== e && t[c] > 0
        }

        function n(t) {
            a.call(this, t), this.path = new s
        }

        var a = t("./Displayable"), o = t(r), s = t("../core/PathProxy"), u = t("../contain/path"), h = (t("./Gradient"), Math.abs);
        return n[H] = {
            constructor: n, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function (t) {
                t.save();
                var n = this.style, r = this.path, a = i(n), o = e(n), s = o && !!n.fill.colorStops, c = a && !!n[l].colorStops;
                if (n.bind(t, this), this.setTransform(t), this.__dirtyPath) {
                    var u = this[y]();
                    s && (this._fillGradient = n.getGradient(t, n.fill, u)), c && (this._strokeGradient = n.getGradient(t, n[l], u))
                }
                s && (t.fillStyle = this._fillGradient), c && (t.strokeStyle = this._strokeGradient);
                var h = n.lineDash, d = n.lineDashOffset, f = !!t.setLineDash, p = this.getGlobalScale();
                r.setScale(p[0], p[1]), this.__dirtyPath || h && !f && a ? (r = this.path.beginPath(t), h && !f && (r.setLineDash(h), r.setLineDashOffset(d)), this.buildPath(r, this.shape), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), o && r.fill(t), h && f && (t.setLineDash(h), t.lineDashOffset = d), a && r[l](t), null != n.text && this.drawRectText(t, this[y]()), t.restore()
            }, buildPath: function () {
            }, getBoundingRect: function () {
                var t = this._rect, n = this.style, r = !t;
                if (r) {
                    var a = this.path;
                    this.__dirtyPath && (a.beginPath(), this.buildPath(a, this.shape)), t = a[y]()
                }
                if (this._rect = t, i(n)) {
                    var o = this._rectWithStroke || (this._rectWithStroke = t.clone());
                    if (this.__dirty || r) {
                        o.copy(t);
                        var s = n[c], l = n.strokeNoScale ? this.getLineScale() : 1;
                        e(n) || (s = Math.max(s, this.strokeContainThreshold)), l > 1e-10 && (o.width += s / l, o[B] += s / l, o.x -= s / l / 2, o.y -= s / l / 2)
                    }
                    return o
                }
                return t
            }, contain: function (t, n) {
                var r = this.transformCoordToLocal(t, n), a = this[y](), o = this.style;
                if (t = r[0], n = r[1], a[f](t, n)) {
                    var s = this.path.data;
                    if (i(o)) {
                        var l = o[c], h = o.strokeNoScale ? this.getLineScale() : 1;
                        if (h > 1e-10 && (e(o) || (l = Math.max(l, this.strokeContainThreshold)), u.containStroke(s, l / h, t, n)))return !0
                    }
                    if (e(o))return u[f](s, t, n)
                }
                return !1
            }, dirty: function (t) {
                0 === arguments[P] && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
            }, animateShape: function (t) {
                return this.animate("shape", t)
            }, attrKV: function (t, e) {
                "shape" === t ? this.setShape(e) : a[H].attrKV.call(this, t, e)
            }, setShape: function (t, e) {
                var i = this.shape;
                if (i) {
                    if (o[I](t))for (var n in t)i[n] = t[n]; else i[t] = e;
                    this.dirty(!0)
                }
                return this
            }, getLineScale: function () {
                var t = this[Z];
                return t && h(t[0] - 1) > 1e-10 && h(t[3] - 1) > 1e-10 ? Math.sqrt(h(t[0] * t[3] - t[2] * t[1])) : 1
            }
        }, n[D] = function (t) {
            var e = function (e) {
                n.call(this, e), t.style && this.style.extendFrom(t.style, !1);
                var i = t.shape;
                if (i) {
                    this.shape = this.shape || {};
                    var r = this.shape;
                    for (var a in i)!r.hasOwnProperty(a) && i.hasOwnProperty(a) && (r[a] = i[a])
                }
                t.init && t.init.call(this, e)
            };
            o.inherits(e, n);
            for (var i in t)"style" !== i && "shape" !== i && (e[H][i] = t[i]);
            return e
        }, o.inherits(n, a), n
    }), e("zrender/graphic/Gradient", [U], function () {
        var t = function (t) {
            this.colorStops = t || []
        };
        return t[H] = {
            constructor: t, addColorStop: function (t, e) {
                this.colorStops.push({offset: t, color: e})
            }
        }, t
    }), e("zrender/container/Group", [U, r, "../Element", "../core/BoundingRect"], function (t) {
        var e = t(r), i = t("../Element"), n = t("../core/BoundingRect"), a = function (t) {
            t = t || {}, i.call(this, t);
            for (var e in t)this[e] = t[e];
            this._children = [], this.__storage = null, this.__dirty = !0
        };
        return a[H] = {
            constructor: a, type: "group", silent: !1, children: function () {
                return this._children.slice()
            }, childAt: function (t) {
                return this._children[t]
            }, childOfName: function (t) {
                for (var e = this._children, i = 0; i < e[P]; i++)if (e[i].name === t)return e[i]
            }, childCount: function () {
                return this._children[P]
            }, add: function (t) {
                return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
            }, addBefore: function (t, e) {
                if (t && t !== this && t.parent !== this && e && e.parent === this) {
                    var i = this._children, n = i[w](e);
                    n >= 0 && (i[A](n, 0, t), this._doAdd(t))
                }
                return this
            }, _doAdd: function (t) {
                t.parent && t.parent.remove(t), t.parent = this;
                var e = this.__storage, i = this.__zr;
                e && e !== t.__storage && (e.addToMap(t), t instanceof a && t.addChildrenToStorage(e)), i && i.refresh()
            }, remove: function (t) {
                var i = this.__zr, n = this.__storage, r = this._children, o = e[w](r, t);
                return 0 > o ? this : (r[A](o, 1), t.parent = null, n && (n.delFromMap(t.id), t instanceof a && t.delChildrenFromStorage(n)), i && i.refresh(), this)
            }, removeAll: function () {
                var t, e, i = this._children, n = this.__storage;
                for (e = 0; e < i[P]; e++)t = i[e], n && (n.delFromMap(t.id), t instanceof a && t.delChildrenFromStorage(n)), t.parent = null;
                return i[P] = 0, this
            }, eachChild: function (t, e) {
                for (var i = this._children, n = 0; n < i[P]; n++) {
                    var r = i[n];
                    t.call(e, r, n)
                }
                return this
            }, traverse: function (t, e) {
                for (var i = 0; i < this._children[P]; i++) {
                    var n = this._children[i];
                    t.call(e, n), "group" === n.type && n.traverse(t, e)
                }
                return this
            }, addChildrenToStorage: function (t) {
                for (var e = 0; e < this._children[P]; e++) {
                    var i = this._children[e];
                    t.addToMap(i), i instanceof a && i.addChildrenToStorage(t)
                }
            }, delChildrenFromStorage: function (t) {
                for (var e = 0; e < this._children[P]; e++) {
                    var i = this._children[e];
                    t.delFromMap(i.id), i instanceof a && i.delChildrenFromStorage(t)
                }
            }, dirty: function () {
                return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
            }, getBoundingRect: function (t) {
                for (var e = null, i = new n(0, 0, 0, 0), r = t || this._children, a = [], o = 0; o < r[P]; o++) {
                    var s = r[o];
                    if (!s[O] && !s.invisible) {
                        var l = s[y](), c = s.getLocalTransform(a);
                        c ? (i.copy(l), i[u](c), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
                    }
                }
                return e || i
            }
        }, e.inherits(a, i), a
    }), e("zrender/graphic/Image", [U, "./Displayable", "../core/BoundingRect", r, "./helper/roundRect", "../core/LRU"], function (t) {
        function e(t) {
            i.call(this, t)
        }

        var i = t("./Displayable"), n = t("../core/BoundingRect"), a = t(r), o = t("./helper/roundRect"), s = t("../core/LRU"), l = new s(50);
        return e[H] = {
            constructor: e, type: "image", brush: function (t) {
                var e, i = this.style, n = i.image;
                if (e = typeof n === q ? this._image : n, !e && n) {
                    var r = l.get(n);
                    if (!r)return e = new Image, e.onload = function () {
                        e.onload = null;
                        for (var t = 0; t < r.pending[P]; t++)r.pending[t].dirty()
                    }, r = {image: e, pending: [this]}, e.src = n, l.put(n, r), void(this._image = e);
                    if (e = r.image, this._image = e, !e.width || !e[B])return void r.pending.push(this)
                }
                if (e) {
                    var a = i.width || e.width, s = i[B] || e[B], c = i.x || 0, u = i.y || 0;
                    if (!e.width || !e[B])return;
                    if (t.save(), i.bind(t), this.setTransform(t), i.r && (t.beginPath(), o.buildPath(t, i), t.clip()), i.sWidth && i.sHeight) {
                        var h = i.sx || 0, d = i.sy || 0;
                        t.drawImage(e, h, d, i.sWidth, i.sHeight, c, u, a, s)
                    } else if (i.sx && i.sy) {
                        var h = i.sx, d = i.sy, f = a - h, p = s - d;
                        t.drawImage(e, h, d, f, p, c, u, a, s)
                    } else t.drawImage(e, c, u, a, s);
                    null == i.width && (i.width = a), null == i[B] && (i[B] = s), null != i.text && this.drawRectText(t, this[y]()), t.restore()
                }
            }, getBoundingRect: function () {
                var t = this.style;
                return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[B] || 0)), this._rect
            }
        }, a.inherits(e, i), e
    }), e("zrender/graphic/shape/Circle", [U, "../Path"], function (t) {
        return t("../Path")[D]({
            type: "circle", shape: {cx: 0, cy: 0, r: 0}, buildPath: function (t, e) {
                t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
            }
        })
    }), e("zrender/graphic/Text", [U, "./Displayable", r, "../contain/text"], function (t) {
        var e = t("./Displayable"), i = t(r), n = t("../contain/text"), a = function (t) {
            e.call(this, t)
        };
        return a[H] = {
            constructor: a, type: "text", brush: function (t) {
                var e = this.style, i = e.x || 0, r = e.y || 0, a = e.text, o = e.fill, s = e[l];
                if (null != a && (a += ""), a) {
                    if (t.save(), this.style.bind(t), this.setTransform(t), o && (t.fillStyle = o), s && (t.strokeStyle = s), t.font = e.textFont || e.font, t.textAlign = e.textAlign, e.textVerticalAlign) {
                        var c = n[y](a, t.font, e.textAlign, "top");
                        switch (t.textBaseline = m, e.textVerticalAlign) {
                            case m:
                                r -= c[B] / 2 - c.lineHeight / 2;
                                break;
                            case E:
                                r -= c[B] - c.lineHeight / 2;
                                break;
                            default:
                                r += c.lineHeight / 2
                        }
                    } else t.textBaseline = e.textBaseline;
                    for (var u = n.measureText("", t.font).width, h = a.split("\n"), d = 0; d < h[P]; d++)o && t.fillText(h[d], i, r), s && t.strokeText(h[d], i, r), r += u;
                    t.restore()
                }
            }, getBoundingRect: function () {
                if (!this._rect) {
                    var t = this.style, e = t.textVerticalAlign, i = n[y](t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);
                    switch (e) {
                        case m:
                            i.y -= i[B] / 2;
                            break;
                        case E:
                            i.y -= i[B]
                    }
                    i.x += t.x || 0, i.y += t.y || 0, this._rect = i
                }
                return this._rect
            }
        }, i.inherits(a, e), a
    }), e("zrender/graphic/shape/Sector", [U, "../Path"], function (t) {
        return t("../Path")[D]({
            type: "sector",
            shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = Math.max(e.r0 || 0, 0), a = Math.max(e.r, 0), o = e.startAngle, s = e.endAngle, l = e.clockwise, c = Math.cos(o), u = Math.sin(o);
                t.moveTo(c * r + i, u * r + n), t.lineTo(c * a + i, u * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath()
            }
        })
    }), e("zrender/graphic/shape/Ring", [U, "../Path"], function (t) {
        return t("../Path")[D]({
            type: "ring", shape: {cx: 0, cy: 0, r: 0, r0: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = 2 * Math.PI;
                t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0)
            }
        })
    }), e("zrender/graphic/shape/Polygon", [U, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[D]({
            type: "polygon",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            buildPath: function (t, i) {
                e.buildPath(t, i, !0)
            }
        })
    }), e("zrender/graphic/shape/Polyline", [U, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[D]({
            type: "polyline",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, i) {
                e.buildPath(t, i, !1)
            }
        })
    }), e("zrender/graphic/shape/Rect", [U, "../helper/roundRect", "../Path"], function (t) {
        var e = t("../helper/roundRect");
        return t("../Path")[D]({
            type: "rect",
            shape: {r: 0, x: 0, y: 0, width: 0, height: 0},
            buildPath: function (t, i) {
                var n = i.x, r = i.y, a = i.width, o = i[B];
                i.r ? e.buildPath(t, i) : t.rect(n, r, a, o), t.closePath()
            }
        })
    }), e("zrender/graphic/shape/Line", [U, "../Path"], function (t) {
        return t("../Path")[D]({
            type: "line",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.x1, n = e.y1, r = e.x2, a = e.y2, o = e.percent;
                0 !== o && (t.moveTo(i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a))
            },
            pointAt: function (t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
            }
        })
    }), e("zrender/graphic/shape/BezierCurve", [U, "../../core/curve", "../../core/vector", "../Path"], function (t) {
        function e(t, e, i) {
            var n = t.cpx2, r = t.cpy2;
            return null === n || null === r ? [(i ? c : s)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? c : s)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? l : o)(t.x1, t.cpx1, t.x2, e), (i ? l : o)(t.y1, t.cpy1, t.y2, e)]
        }

        var i = t("../../core/curve"), n = t("../../core/vector"), r = i.quadraticSubdivide, a = i.cubicSubdivide, o = i.quadraticAt, s = i.cubicAt, l = i.quadraticDerivativeAt, c = i.cubicDerivativeAt, u = [];
        return t("../Path")[D]({
            type: "bezier-curve",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.x1, n = e.y1, o = e.x2, s = e.y2, l = e.cpx1, c = e.cpy1, h = e.cpx2, d = e.cpy2, f = e.percent;
                0 !== f && (t.moveTo(i, n), null == h || null == d ? (1 > f && (r(i, l, o, f, u), l = u[1], o = u[2], r(n, c, s, f, u), c = u[1], s = u[2]), t.quadraticCurveTo(l, c, o, s)) : (1 > f && (a(i, l, h, o, f, u), l = u[1], h = u[2], o = u[3], a(n, c, d, s, f, u), c = u[1], d = u[2], s = u[3]), t.bezierCurveTo(l, c, h, d, o, s)))
            },
            pointAt: function (t) {
                return e(this.shape, t, !1)
            },
            tangentAt: function (t) {
                var i = e(this.shape, t, !0);
                return n.normalize(i, i)
            }
        })
    }), e("zrender/graphic/shape/Arc", [U, "../Path"], function (t) {
        return t("../Path")[D]({
            type: "arc",
            shape: {cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = Math.max(e.r, 0), a = e.startAngle, o = e.endAngle, s = e.clockwise, l = Math.cos(a), c = Math.sin(a);
                t.moveTo(l * r + i, c * r + n), t.arc(i, n, r, a, o, !s)
            }
        })
    }), e("zrender/graphic/CompoundPath", [U, "./Path"], function (t) {
        var e = t("./Path");
        return e[D]({
            type: "compound", shape: {paths: null}, _updatePathDirty: function () {
                for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e[P]; i++)t = t || e[i].__dirtyPath;
                this.__dirtyPath = t, this.__dirty = this.__dirty || t
            }, beforeBrush: function () {
                this._updatePathDirty();
                for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t[P]; i++)t[i].path.setScale(e[0], e[1])
            }, buildPath: function (t, e) {
                for (var i = e.paths || [], n = 0; n < i[P]; n++)i[n].buildPath(t, i[n].shape)
            }, afterBrush: function () {
                for (var t = this.shape.paths, e = 0; e < t[P]; e++)t[e].__dirtyPath = !1
            }, getBoundingRect: function () {
                return this._updatePathDirty(), e[H][y].call(this)
            }
        })
    }), e("zrender/graphic/LinearGradient", [U, r, "./Gradient"], function (t) {
        var e = t(r), i = t("./Gradient"), n = function (t, e, n, r, a) {
            this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, i.call(this, a)
        };
        return n[H] = {constructor: n, type: "linear"}, e.inherits(n, i), n
    }), e("zrender/graphic/RadialGradient", [U, r, "./Gradient"], function (t) {
        var e = t(r), i = t("./Gradient"), n = function (t, e, n, r) {
            this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, i.call(this, r)
        };
        return n[H] = {constructor: n, type: "radial"}, e.inherits(n, i), n
    }), e("zrender/core/BoundingRect", [U, "./vector", "./matrix"], function (t) {
        function e(t, e, i, n) {
            this.x = t, this.y = e, this.width = i, this[B] = n
        }

        var i = t("./vector"), n = t("./matrix"), r = i[u], a = Math.min, o = Math.abs, s = Math.max;
        return e[H] = {
            constructor: e, union: function (t) {
                var e = a(t.x, this.x), i = a(t.y, this.y);
                this.width = s(t.x + t.width, this.x + this.width) - e, this[B] = s(t.y + t[B], this.y + this[B]) - i, this.x = e, this.y = i
            }, applyTransform: function () {
                var t = [], e = [];
                return function (i) {
                    i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[B], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[B] = o(e[1] - t[1]))
                }
            }(), calculateTransform: function (t) {
                var e = this, i = t.width / e.width, r = t[B] / e[B], a = n[R]();
                return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a
            }, intersect: function (t) {
                var e = this, i = e.x, n = e.x + e.width, r = e.y, a = e.y + e[B], o = t.x, s = t.x + t.width, l = t.y, c = t.y + t[B];
                return !(o > n || i > s || l > a || r > c)
            }, contain: function (t, e) {
                var i = this;
                return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[B]
            }, clone: function () {
                return new e(this.x, this.y, this.width, this[B])
            }, copy: function (t) {
                this.x = t.x, this.y = t.y, this.width = t.width, this[B] = t[B]
            }
        }, e
    }), e("zrender/core/PathProxy", [U, "./curve", "./vector", "./bbox", "./BoundingRect", "../config"], function (t) {
        var e = t("./curve"), i = t("./vector"), n = t("./bbox"), r = t("./BoundingRect"), o = t("../config").devicePixelRatio, s = {
            M: 1,
            L: 2,
            C: 3,
            Q: 4,
            A: 5,
            Z: 6,
            R: 7
        }, c = [], u = [], h = [], d = [], f = Math.min, p = Math.max, v = Math.cos, g = Math.sin, m = Math.sqrt, y = Math.abs, x = typeof Float32Array != a, _ = function () {
            this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
        };
        return _[H] = {
            constructor: _, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function (t, e) {
                this._ux = y(1 / o / t) || 0, this._uy = y(1 / o / e) || 0
            }, getContext: function () {
                return this._ctx
            }, beginPath: function (t) {
                return this._ctx = t, t && t.beginPath(), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
            }, moveTo: function (t, e) {
                return this.addData(s.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
            }, lineTo: function (t, e) {
                var i = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || 0 === this._len;
                return this.addData(s.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
            }, bezierCurveTo: function (t, e, i, n, r, a) {
                return this.addData(s.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this
            }, quadraticCurveTo: function (t, e, i, n) {
                return this.addData(s.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
            }, arc: function (t, e, i, n, r, a) {
                return this.addData(s.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = v(r) * i + t, this._xi = g(r) * i + t, this
            }, arcTo: function (t, e, i, n, r) {
                return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
            }, rect: function (t, e, i, n) {
                return this._ctx && this._ctx.rect(t, e, i, n), this.addData(s.R, t, e, i, n), this
            }, closePath: function () {
                this.addData(s.Z);
                var t = this._ctx, e = this._x0, i = this._y0;
                return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
            }, fill: function (t) {
                t && t.fill(), this.toStatic()
            }, stroke: function (t) {
                t && t[l](), this.toStatic()
            }, setLineDash: function (t) {
                if (t instanceof Array) {
                    this._lineDash = t, this._dashIdx = 0;
                    for (var e = 0, i = 0; i < t[P]; i++)e += t[i];
                    this._dashSum = e
                }
                return this
            }, setLineDashOffset: function (t) {
                return this._dashOffset = t, this
            }, len: function () {
                return this._len
            }, setData: function (t) {
                var e = t[P];
                this.data && this.data[P] == e || !x || (this.data = new Float32Array(e));
                for (var i = 0; e > i; i++)this.data[i] = t[i];
                this._len = e
            }, appendPath: function (t) {
                t instanceof Array || (t = [t]);
                for (var e = t[P], i = 0, n = this._len, r = 0; e > r; r++)i += t[r].len();
                x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                for (var r = 0; e > r; r++)for (var a = t[r].data, o = 0; o < a[P]; o++)this.data[n++] = a[o];
                this._len = n
            }, addData: function (t) {
                var e = this.data;
                this._len + arguments[P] > e[P] && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments[P]; i++)e[this._len++] = arguments[i];
                this._prevCmd = t
            }, _expandData: function () {
                if (!(this.data instanceof Array)) {
                    for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e];
                    this.data = t
                }
            }, _needsDash: function () {
                return this._lineDash
            }, _dashedLineTo: function (t, e) {
                var i, n, r = this._dashSum, a = this._dashOffset, o = this._lineDash, s = this._ctx, l = this._xi, c = this._yi, u = t - l, h = e - c, d = m(u * u + h * h), v = l, g = c, y = o[P];
                for (u /= d, h /= d, 0 > a && (a = r + a), a %= r, v -= a * u, g -= a * h; u >= 0 && t >= v || 0 > u && v > t;)n = this._dashIdx, i = o[n], v += u * i, g += h * i, this._dashIdx = (n + 1) % y, u > 0 && l > v || 0 > u && v > l || s[n % 2 ? "moveTo" : "lineTo"](u >= 0 ? f(v, t) : p(v, t), h >= 0 ? f(g, e) : p(g, e));
                u = v - t, h = g - e, this._dashOffset = -m(u * u + h * h)
            }, _dashedBezierTo: function (t, i, n, r, a, o) {
                var s, l, c, u, h, d = this._dashSum, f = this._dashOffset, p = this._lineDash, v = this._ctx, g = this._xi, y = this._yi, x = e.cubicAt, _ = 0, b = this._dashIdx, w = p[P], M = 0;
                for (0 > f && (f = d + f), f %= d, s = 0; 1 > s; s += .1)l = x(g, t, n, a, s + .1) - x(g, t, n, a, s), c = x(y, i, r, o, s + .1) - x(y, i, r, o, s), _ += m(l * l + c * c);
                for (; w > b && (M += p[b], !(M > f)); b++);
                for (s = (M - f) / _; 1 >= s;)u = x(g, t, n, a, s), h = x(y, i, r, o, s), b % 2 ? v.moveTo(u, h) : v.lineTo(u, h), s += p[b] / _, b = (b + 1) % w;
                b % 2 !== 0 && v.lineTo(a, o), l = a - u, c = o - h, this._dashOffset = -m(l * l + c * c)
            }, _dashedQuadraticTo: function (t, e, i, n) {
                var r = i, a = n;
                i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
            }, toStatic: function () {
                var t = this.data;
                t instanceof Array && (t[P] = this._len, x && (this.data = new Float32Array(t)))
            }, getBoundingRect: function () {
                c[0] = c[1] = h[0] = h[1] = Number.MAX_VALUE, u[0] = u[1] = d[0] = d[1] = -Number.MAX_VALUE;
                for (var t = this.data, e = 0, a = 0, o = 0, l = 0, f = 0; f < t[P];) {
                    var p = t[f++];
                    switch (1 == f && (e = t[f], a = t[f + 1], o = e, l = a), p) {
                        case s.M:
                            o = t[f++], l = t[f++], e = o, a = l, h[0] = o, h[1] = l, d[0] = o, d[1] = l;
                            break;
                        case s.L:
                            n.fromLine(e, a, t[f], t[f + 1], h, d), e = t[f++], a = t[f++];
                            break;
                        case s.C:
                            n.fromCubic(e, a, t[f++], t[f++], t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], a = t[f++];
                            break;
                        case s.Q:
                            n.fromQuadratic(e, a, t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], a = t[f++];
                            break;
                        case s.A:
                            var m = t[f++], y = t[f++], x = t[f++], _ = t[f++], b = t[f++], w = t[f++] + b, M = (t[f++], 1 - t[f++]);
                            1 == f && (o = v(b) * x + m, l = g(b) * _ + y), n.fromArc(m, y, x, _, b, w, M, h, d), e = v(w) * x + m, a = g(w) * _ + y;
                            break;
                        case s.R:
                            o = e = t[f++], l = a = t[f++];
                            var T = t[f++], S = t[f++];
                            n.fromLine(o, l, o + T, l + S, h, d);
                            break;
                        case s.Z:
                            e = o, a = l
                    }
                    i.min(c, c, h), i.max(u, u, d)
                }
                return 0 === f && (c[0] = c[1] = u[0] = u[1] = 0), new r(c[0], c[1], u[0] - c[0], u[1] - c[1])
            }, rebuildPath: function (t) {
                for (var e, i, n, r, a, o, l = this.data, c = this._ux, u = this._uy, h = this._len, d = 0; h > d;) {
                    var f = l[d++];
                    switch (1 == d && (n = l[d], r = l[d + 1], e = n, i = r), f) {
                        case s.M:
                            e = n = l[d++], i = r = l[d++], t.moveTo(n, r);
                            break;
                        case s.L:
                            a = l[d++], o = l[d++], (y(a - n) > c || y(o - r) > u || d === h - 1) && (t.lineTo(a, o), n = a, r = o);
                            break;
                        case s.C:
                            t.bezierCurveTo(l[d++], l[d++], l[d++], l[d++], l[d++], l[d++]), n = l[d - 2], r = l[d - 1];
                            break;
                        case s.Q:
                            t.quadraticCurveTo(l[d++], l[d++], l[d++], l[d++]), n = l[d - 2], r = l[d - 1];
                            break;
                        case s.A:
                            var p = l[d++], m = l[d++], x = l[d++], _ = l[d++], b = l[d++], w = l[d++], M = l[d++], T = l[d++], S = x > _ ? x : _, C = x > _ ? 1 : x / _, z = x > _ ? _ / x : 1, A = Math.abs(x - _) > .001, L = b + w;
                            A ? (t.translate(p, m), t.rotate(M), t.scale(C, z), t.arc(0, 0, S, b, L, 1 - T), t.scale(1 / C, 1 / z), t.rotate(-M), t.translate(-p, -m)) : t.arc(p, m, S, b, L, 1 - T), 1 == d && (e = v(b) * x + p, i = g(b) * _ + m), n = v(L) * x + p, r = g(L) * _ + m;
                            break;
                        case s.R:
                            e = n = l[d], i = r = l[d + 1], t.rect(l[d++], l[d++], l[d++], l[d++]);
                            break;
                        case s.Z:
                            t.closePath(), n = e, r = i
                    }
                }
            }
        }, _.CMD = s, _
    }), e("zrender/contain/text", [U, r, "../core/BoundingRect"], function (t) {
        function e(t, e) {
            var i = t + ":" + e;
            if (l[i])return l[i];
            for (var n = (t + "").split("\n"), r = 0, a = 0, o = n[P]; o > a; a++)r = Math.max(f.measureText(n[a], e).width, r);
            return c > u && (c = 0, l = {}), c++, l[i] = r, r
        }

        function i(t, i, n, r) {
            var a = ((t || "") + "").split("\n")[P], o = e(t, i), s = e("", i), l = a * s, c = new d(0, 0, o, l);
            switch (c.lineHeight = s, r) {
                case E:
                case"alphabetic":
                    c.y -= s;
                    break;
                case m:
                    c.y -= s / 2
            }
            switch (n) {
                case"end":
                case"right":
                    c.x -= c.width;
                    break;
                case g:
                    c.x -= c.width / 2
            }
            return c
        }

        function n(t, e, i, n) {
            var r = e.x, a = e.y, o = e[B], s = e.width, l = i[B], c = o / 2 - l / 2, u = "left";
            switch (t) {
                case"left":
                    r -= n, a += c, u = "right";
                    break;
                case"right":
                    r += n + s, a += c, u = "left";
                    break;
                case"top":
                    r += s / 2, a -= n + l, u = g;
                    break;
                case E:
                    r += s / 2, a += o + n, u = g;
                    break;
                case"inside":
                    r += s / 2, a += c, u = g;
                    break;
                case"insideLeft":
                    r += n, a += c, u = "left";
                    break;
                case"insideRight":
                    r += s - n, a += c, u = "right";
                    break;
                case"insideTop":
                    r += s / 2, a += n, u = g;
                    break;
                case"insideBottom":
                    r += s / 2, a += o - l - n, u = g;
                    break;
                case"insideTopLeft":
                    r += n, a += n, u = "left";
                    break;
                case"insideTopRight":
                    r += s - n, a += n, u = "right";
                    break;
                case"insideBottomLeft":
                    r += n, a += o - l - n;
                    break;
                case"insideBottomRight":
                    r += s - n, a += o - l - n, u = "right"
            }
            return {x: r, y: a, textAlign: u, textBaseline: "top"}
        }

        function a(t, i, n, r) {
            if (!n)return "";
            r = h[k]({
                ellipsis: "...",
                minCharacters: 3,
                maxIterations: 3,
                cnCharWidth: e("", i),
                ascCharWidth: e("a", i)
            }, r, !0), n -= e(r.ellipsis);
            for (var a = (t + "").split("\n"), s = 0, l = a[P]; l > s; s++)a[s] = o(a[s], i, n, r);
            return a.join("\n")
        }

        function o(t, i, n, r) {
            for (var a = 0; ; a++) {
                var o = e(t, i);
                if (n > o || a >= r.maxIterations) {
                    t += r.ellipsis;
                    break
                }
                var l = 0 === a ? s(t, n, r) : Math.floor(t[P] * n / o);
                if (l < r.minCharacters) {
                    t = "";
                    break
                }
                t = t.substr(0, l)
            }
            return t
        }

        function s(t, e, i) {
            for (var n = 0, r = 0, a = t[P]; a > r && e > n; r++) {
                var o = t.charCodeAt(r);
                n += o >= 0 && 127 >= o ? i.ascCharWidth : i.cnCharWidth
            }
            return r
        }

        var l = {}, c = 0, u = 5e3, h = t(r), d = t("../core/BoundingRect"), f = {
            getWidth: e,
            getBoundingRect: i,
            adjustTextPositionOnRect: n,
            ellipsis: a,
            measureText: function (t, e) {
                var i = h.getContext();
                return i.font = e, i.measureText(t)
            }
        };
        return f
    }), e("zrender/graphic/mixin/RectText", [U, "../../contain/text", "../../core/BoundingRect"], function (t) {
        function e(t, e) {
            return typeof t === q ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
        }

        function i(t, e) {
            t[Z](e[0], e[1], e[2], e[3], e[4], e[5])
        }

        var n = t("../../contain/text"), r = t("../../core/BoundingRect"), a = new r, o = function () {
        };
        return o[H] = {
            constructor: o, drawRectText: function (t, r, o) {
                var s = this.style, l = s.text;
                if (null != l && (l += ""), l) {
                    var c, h, d = s.textPosition, f = s.textDistance, p = s.textAlign, v = s.textFont || s.font, g = s.textBaseline, x = s.textVerticalAlign;
                    o = o || n[y](l, v, p, g);
                    var _ = this[Z], b = this.invTransform;
                    if (_ && (a.copy(r), a[u](_), r = a, i(t, b)), d instanceof Array) {
                        if (c = r.x + e(d[0], r.width), h = r.y + e(d[1], r[B]), p = p || "left", g = g || "top", x) {
                            switch (x) {
                                case m:
                                    h -= o[B] / 2 - o.lineHeight / 2;
                                    break;
                                case E:
                                    h -= o[B] - o.lineHeight / 2;
                                    break;
                                default:
                                    h += o.lineHeight / 2
                            }
                            g = m
                        }
                    } else {
                        var w = n.adjustTextPositionOnRect(d, r, o, f);
                        c = w.x, h = w.y, p = p || w.textAlign, g = g || w.textBaseline
                    }
                    t.textAlign = p, t.textBaseline = g;
                    var M = s.textFill, T = s.textStroke;
                    M && (t.fillStyle = M), T && (t.strokeStyle = T), t.font = v, t.shadowColor = s.textShadowColor, t.shadowBlur = s.textShadowBlur, t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
                    for (var S = l.split("\n"), C = 0; C < S[P]; C++)M && t.fillText(S[C], c, h), T && t.strokeText(S[C], c, h), h += o.lineHeight;
                    _ && i(t, _)
                }
            }
        }, o
    }), e("zrender/graphic/Displayable", [U, r, "./Style", "../Element", "./mixin/RectText"], function (t) {
        function e(t) {
            t = t || {}, a.call(this, t);
            for (var e in t)t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
            this.style = new n(t.style), this._rect = null, this.__clipPaths = []
        }

        var i = t(r), n = t("./Style"), a = t("../Element"), o = t("./mixin/RectText");
        return e[H] = {
            constructor: e,
            type: "displayable",
            __dirty: !0,
            invisible: !1,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: !1,
            dragging: !1,
            silent: !1,
            culling: !1,
            cursor: "pointer",
            rectHover: !1,
            beforeBrush: function () {
            },
            afterBrush: function () {
            },
            brush: function () {
            },
            getBoundingRect: function () {
            },
            contain: function (t, e) {
                return this.rectContain(t, e)
            },
            traverse: function (t, e) {
                t.call(e, this)
            },
            rectContain: function (t, e) {
                var i = this.transformCoordToLocal(t, e), n = this[y]();
                return n[f](i[0], i[1])
            },
            dirty: function () {
                this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh()
            },
            animateStyle: function (t) {
                return this.animate("style", t)
            },
            attrKV: function (t, e) {
                "style" !== t ? a[H].attrKV.call(this, t, e) : this.style.set(e)
            },
            setStyle: function (t, e) {
                return this.style.set(t, e), this.dirty(!1), this
            },
            useStyle: function (t) {
                return this.style = new n(t), this.dirty(!1), this
            }
        }, i.inherits(e, a), i.mixin(e, o), e
    }), e("zrender/vml/core", [U, "exports", "module", "../core/env"], function (t, e, i) {
        if (!t("../core/env").canvasSupported) {
            var n, r = "urn:schemas-microsoft-com:vml", a = window, s = a.document, l = !1;
            try {
                !s.namespaces.zrvml && s.namespaces.add("zrvml", r), n = function (t) {
                    return s[o]("<zrvml:" + t + ' class="zrvml">')
                }
            } catch (c) {
                n = function (t) {
                    return s[o]("<" + t + ' xmlns="' + r + '" class="zrvml">')
                }
            }
            var u = function () {
                if (!l) {
                    l = !0;
                    var t = s.styleSheets;
                    t[P] < 31 ? s.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
                }
            };
            i.exports = {doc: s, initVML: u, createNode: n}
        }
    }), e("echarts/util/clazz", [U, j], function (t) {
        function e(t, e) {
            var i = n.slice(arguments, 2);
            return this.superClass[H][e].apply(t, i)
        }

        function i(t, e, i) {
            return this.superClass[H][e].apply(t, i)
        }

        var n = t(j), r = {}, a = ".", o = "___EC__COMPONENT__CONTAINER___", s = r.parseClassType = function (t) {
            var e = {main: "", sub: ""};
            return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e
        };
        return r.enableClassExtend = function (t, r) {
            t[D] = function (a) {
                var o = function () {
                    r && r.apply(this, arguments), t.apply(this, arguments)
                };
                return n[D](o[H], a), o[D] = this[D], o.superCall = e, o.superApply = i, n.inherits(o, this), o.superClass = this, o
            }
        }, r.enableClassManagement = function (t, e) {
            function i(t) {
                var e = r[t.main];
                return e && e[o] || (e = r[t.main] = {}, e[o] = !0), e
            }

            e = e || {};
            var r = {};
            if (t.registerClass = function (t, e) {
                    if (e)if (e = s(e), e.sub) {
                        if (e.sub !== o) {
                            var n = i(e);
                            n[e.sub] = t
                        }
                    } else {
                        if (r[e.main])throw new Error(e.main + "exists.");
                        r[e.main] = t
                    }
                    return t
                }, t.getClass = function (t, e, i) {
                    var n = r[t];
                    if (n && n[o] && (n = e ? n[e] : null), i && !n)throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
                    return n
                }, t.getClassesByMainType = function (t) {
                    t = s(t);
                    var e = [], i = r[t.main];
                    return i && i[o] ? n.each(i, function (t, i) {
                        i !== o && e.push(t)
                    }) : e.push(i), e
                }, t.hasClass = function (t) {
                    return t = s(t), !!r[t.main]
                }, t.getAllClassMainTypes = function () {
                    var t = [];
                    return n.each(r, function (e, i) {
                        t.push(i)
                    }), t
                }, t.hasSubTypes = function (t) {
                    t = s(t);
                    var e = r[t.main];
                    return e && e[o]
                }, t.parseClassType = s, e.registerWhenExtend) {
                var a = t[D];
                a && (t[D] = function (e) {
                    var i = a.call(this, e);
                    return t.registerClass(i, e.type)
                })
            }
            return t
        }, r.setReadOnly = function () {
        }, r
    }), e("echarts/model/mixin/lineStyle", [U, "./makeStyleMapper"], function (t) {
        var e = t("./makeStyleMapper")([[c, "width"], [l, "color"], [p], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
        return {
            getLineStyle: function (t) {
                var i = e.call(this, t), n = this.getLineDash();
                return n && (i.lineDash = n), i
            }, getLineDash: function () {
                var t = this.get("type");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
            }
        }
    }), e("echarts/model/mixin/areaStyle", [U, "./makeStyleMapper"], function (t) {
        return {getAreaStyle: t("./makeStyleMapper")([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], [p], ["shadowColor"]])}
    }), e("echarts/model/mixin/textStyle", [U, "zrender/contain/text"], function (t) {
        function e(t, e) {
            return t && t.getShallow(e)
        }

        var i = t("zrender/contain/text");
        return {
            getTextColor: function () {
                var t = this.ecModel;
                return this.getShallow("color") || t && t.get("textStyle.color")
            }, getFont: function () {
                var t = this.ecModel, i = t && t[V](_);
                return [this.getShallow("fontStyle") || e(i, "fontStyle"), this.getShallow("fontWeight") || e(i, "fontWeight"), (this.getShallow("fontSize") || e(i, "fontSize") || 12) + "px", this.getShallow("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
            }, getTextRect: function (t) {
                var e = this.get(_) || {};
                return i[y](t, this[x](), e.align, e.baseline)
            }, ellipsis: function (t, e, n) {
                return i.ellipsis(t, this[x](), e, n)
            }
        }
    }), e("echarts/model/mixin/itemStyle", [U, "./makeStyleMapper"], function (t) {
        return {getItemStyle: t("./makeStyleMapper")([["fill", "color"], [l, "borderColor"], [c, "borderWidth"], [p], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])}
    }), e("echarts/coord/axisHelper", [U, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", j, "zrender/contain/text"], function (t) {
        var e = t("../scale/Ordinal"), r = t("../scale/Interval");
        t("../scale/Time"), t("../scale/Log");
        var a = t("../scale/Scale"), o = t("../util/number"), s = t(j), l = t("zrender/contain/text"), c = {};
        return c.getScaleExtent = function (t, e) {
            var n = t.scale, r = n[d](), a = r[1] - r[0];
            if (n.type === i)return isFinite(a) ? r : [0, 0];
            var l = e.getMin ? e.getMin() : e.get("min"), c = e.getMax ? e.getMax() : e.get("max"), u = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"), h = e.get("boundaryGap");
            s[M](h) || (h = [h || 0, h || 0]), h[0] = o.parsePercent(h[0], 1), h[1] = o.parsePercent(h[1], 1);
            var f = !0, p = !0;
            return null == l && (l = r[0] - h[0] * a, f = !1), null == c && (c = r[1] + h[1] * a, p = !1), "dataMin" === l && (l = r[0]), "dataMax" === c && (c = r[1]), u && (l > 0 && c > 0 && !f && (l = 0), 0 > l && 0 > c && !p && (c = 0)), [l, c]
        }, c.niceScaleExtent = function (t, e) {
            var i = t.scale, n = c.getScaleExtent(t, e), r = null != (e.getMin ? e.getMin() : e.get("min")), a = null != (e.getMax ? e.getMax() : e.get("max")), o = e.get("splitNumber");
            i.setExtent(n[0], n[1]), i.niceExtent(o, r, a);
            var s = e.get("minInterval");
            if (isFinite(s) && !r && !a && "interval" === i.type) {
                var l = i.getInterval(), u = Math.max(Math.abs(l), s) / l;
                n = i[d](), i.setExtent(u * n[0], n[1] * u), i.niceExtent(o)
            }
            var l = e.get("interval");
            null != l && i.setInterval && i.setInterval(l)
        }, c.createScaleByModel = function (t, i) {
            if (i = i || t.get("type"))switch (i) {
                case n:
                    return new e(t.getCategories(), [1 / 0, -1 / 0]);
                case"value":
                    return new r;
                default:
                    return (a.getClass(i) || r)[R](t)
            }
        }, c.ifAxisCrossZero = function (t) {
            var e = t.scale[d](), i = e[0], n = e[1];
            return !(i > 0 && n > 0 || 0 > i && 0 > n)
        }, c.getAxisLabelInterval = function (t, e, i, n) {
            var r, a = 0, o = 0, s = 1;
            e[P] > 40 && (s = Math.round(e[P] / 40));
            for (var c = 0; c < t[P]; c += s) {
                var u = t[c], h = l[y](e[c], i, g, "top");
                h[n ? "x" : "y"] += u, h[n ? "width" : B] *= 1.5, r ? r.intersect(h) ? (o++, a = Math.max(a, o)) : (r.union(h), o = 0) : r = h.clone()
            }
            return 0 === a && s > 1 ? s : a * s
        }, c.getFormattedLabels = function (t, e) {
            var i = t.scale, r = i.getTicksLabels(), a = i.getTicks();
            return typeof e === q ? (e = function (t) {
                return function (e) {
                    return t[T]("{value}", e)
                }
            }(e), s.map(r, e)) : typeof e === b ? s.map(a, function (r, a) {
                return e(t.type === n ? i.getLabel(r) : r, a)
            }, this) : r
        }, c
    }), e("echarts/coord/cartesian/Cartesian2D", [U, j, "./Cartesian"], function (t) {
        function e(t) {
            r.call(this, t)
        }

        var n = t(j), r = t("./Cartesian");
        return e[H] = {
            constructor: e, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () {
                return this.getAxesByScale(i)[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
            }, containPoint: function (t) {
                var e = this.getAxis("x"), i = this.getAxis("y");
                return e[f](e.toLocalCoord(t[0])) && i[f](i.toLocalCoord(t[1]))
            }, containData: function (t) {
                return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
            }, dataToPoints: function (t, e) {
                return t.mapArray(["x", "y"], function (t, e) {
                    return this.dataToPoint([t, e])
                }, e, this)
            }, dataToPoint: function (t, e) {
                var i = this.getAxis("x"), n = this.getAxis("y");
                return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))]
            }, pointToData: function (t, e) {
                var i = this.getAxis("x"), n = this.getAxis("y");
                return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
            }, getOtherAxis: function (t) {
                return this.getAxis("x" === t.dim ? "y" : "x")
            }
        }, n.inherits(e, r), e
    }), e("echarts/coord/cartesian/Axis2D", [U, j, "../Axis", "./axisLabelInterval"], function (t) {
        var e = t(j), i = t("../Axis"), r = t("./axisLabelInterval"), a = function (t, e, n, r, a) {
            i.call(this, t, e, n), this.type = r || "value", this[v] = a || E
        };
        return a[H] = {
            constructor: a, index: 0, onZero: !1, model: null, isHorizontal: function () {
                var t = this[v];
                return "top" === t || t === E
            }, getGlobalExtent: function () {
                var t = this[d]();
                return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
            }, getLabelInterval: function () {
                var t = this._labelInterval;
                return t || (t = this._labelInterval = r(this)), t
            }, isLabelIgnored: function (t) {
                if (this.type === n) {
                    var e = this.getLabelInterval();
                    return typeof e === b && !e(t, this.scale.getLabel(t)) || t % (e + 1)
                }
            }, toLocalCoord: null, toGlobalCoord: null
        }, e.inherits(a, i), a
    }), e("echarts/coord/cartesian/GridModel", [U, "./AxisModel", "../../model/Component"], function (t) {
        t("./AxisModel");
        var e = t("../../model/Component");
        return e[D]({
            type: "grid",
            dependencies: ["xAxis", "yAxis"],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: !1,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: !1,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        })
    }), e("zrender/tool/transformPath", [U, "../core/PathProxy", "../core/vector"], function (t) {
        function e(t, e) {
            var n, l, c, u, h, d, f = t.data, p = i.M, v = i.C, g = i.L, m = i.R, y = i.A, x = i.Q;
            for (c = 0, u = 0; c < f[P];) {
                switch (n = f[c++], u = c, l = 0, n) {
                    case p:
                        l = 1;
                        break;
                    case g:
                        l = 1;
                        break;
                    case v:
                        l = 3;
                        break;
                    case x:
                        l = 2;
                        break;
                    case y:
                        var _ = e[4], b = e[5], w = o(e[0] * e[0] + e[1] * e[1]), M = o(e[2] * e[2] + e[3] * e[3]), T = s(-e[1] / M, e[0] / w);
                        f[c++] += _, f[c++] += b, f[c++] *= w, f[c++] *= M, f[c++] += T, f[c++] += T, c += 2, u = c;
                        break;
                    case m:
                        d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1], d[0] += f[c++], d[1] += f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
                }
                for (h = 0; l > h; h++) {
                    var d = a[h];
                    d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
                }
            }
        }

        var i = t("../core/PathProxy").CMD, n = t("../core/vector"), r = n[u], a = [[], [], []], o = Math.sqrt, s = Math.atan2;
        return e
    }), e("zrender/core/curve", [U, "./vector"], function (t) {
        function e(t) {
            return t > -_ && _ > t
        }

        function i(t) {
            return t > _ || -_ > t
        }

        function n(t, e, i, n, r) {
            var a = 1 - r;
            return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
        }

        function r(t, e, i, n, r) {
            var a = 1 - r;
            return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
        }

        function a(t, i, n, r, a, o) {
            var s = r + 3 * (i - n) - t, l = 3 * (n - 2 * i + t), c = 3 * (i - t), u = t - a, h = l * l - 3 * s * c, d = l * c - 9 * s * u, f = c * c - 3 * l * u, p = 0;
            if (e(h) && e(d))if (e(l))o[0] = 0; else {
                var v = -c / l;
                v >= 0 && 1 >= v && (o[p++] = v)
            } else {
                var g = d * d - 4 * h * f;
                if (e(g)) {
                    var m = d / h, v = -l / s + m, _ = -m / 2;
                    v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _)
                } else if (g > 0) {
                    var b = x(g), T = h * l + 1.5 * s * (-d + b), S = h * l + 1.5 * s * (-d - b);
                    T = 0 > T ? -y(-T, M) : y(T, M), S = 0 > S ? -y(-S, M) : y(S, M);
                    var v = (-l - (T + S)) / (3 * s);
                    v >= 0 && 1 >= v && (o[p++] = v)
                } else {
                    var C = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)), z = Math.acos(C) / 3, A = x(h), L = Math.cos(z), v = (-l - 2 * A * L) / (3 * s), _ = (-l + A * (L + w * Math.sin(z))) / (3 * s), P = (-l + A * (L - w * Math.sin(z))) / (3 * s);
                    v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _), P >= 0 && 1 >= P && (o[p++] = P)
                }
            }
            return p
        }

        function o(t, n, r, a, o) {
            var s = 6 * r - 12 * n + 6 * t, l = 9 * n + 3 * a - 3 * t - 9 * r, c = 3 * n - 3 * t, u = 0;
            if (e(l)) {
                if (i(s)) {
                    var h = -c / s;
                    h >= 0 && 1 >= h && (o[u++] = h)
                }
            } else {
                var d = s * s - 4 * l * c;
                if (e(d))o[0] = -s / (2 * l); else if (d > 0) {
                    var f = x(d), h = (-s + f) / (2 * l), p = (-s - f) / (2 * l);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
                }
            }
            return u
        }

        function s(t, e, i, n, r, a) {
            var o = (e - t) * r + t, s = (i - e) * r + e, l = (n - i) * r + i, c = (s - o) * r + o, u = (l - s) * r + s, h = (u - c) * r + c;
            a[0] = t, a[1] = o, a[2] = c, a[3] = h, a[4] = h, a[5] = u, a[6] = l, a[7] = n
        }

        function l(t, e, i, r, a, o, s, l, c, u, h) {
            var d, f, p, v, g, y = .005, _ = 1 / 0;
            T[0] = c, T[1] = u;
            for (var w = 0; 1 > w; w += .05)S[0] = n(t, i, a, s, w), S[1] = n(e, r, o, l, w), v = m(T, S), _ > v && (d = w, _ = v);
            _ = 1 / 0;
            for (var M = 0; 32 > M && !(b > y); M++)f = d - y, p = d + y, S[0] = n(t, i, a, s, f), S[1] = n(e, r, o, l, f), v = m(S, T), f >= 0 && _ > v ? (d = f, _ = v) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), g = m(C, T), 1 >= p && _ > g ? (d = p, _ = g) : y *= .5);
            return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)), x(_)
        }

        function c(t, e, i, n) {
            var r = 1 - n;
            return r * (r * t + 2 * n * e) + n * n * i
        }

        function u(t, e, i, n) {
            return 2 * ((1 - n) * (e - t) + n * (i - e))
        }

        function h(t, n, r, a, o) {
            var s = t - 2 * n + r, l = 2 * (n - t), c = t - a, u = 0;
            if (e(s)) {
                if (i(l)) {
                    var h = -c / l;
                    h >= 0 && 1 >= h && (o[u++] = h)
                }
            } else {
                var d = l * l - 4 * s * c;
                if (e(d)) {
                    var h = -l / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h)
                } else if (d > 0) {
                    var f = x(d), h = (-l + f) / (2 * s), p = (-l - f) / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
                }
            }
            return u
        }

        function d(t, e, i) {
            var n = t + i - 2 * e;
            return 0 === n ? .5 : (t - e) / n
        }

        function f(t, e, i, n, r) {
            var a = (e - t) * n + t, o = (i - e) * n + e, s = (o - a) * n + a;
            r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
        }

        function p(t, e, i, n, r, a, o, s, l) {
            var u, h = .005, d = 1 / 0;
            T[0] = o, T[1] = s;
            for (var f = 0; 1 > f; f += .05) {
                S[0] = c(t, i, r, f), S[1] = c(e, n, a, f);
                var p = m(T, S);
                d > p && (u = f, d = p)
            }
            d = 1 / 0;
            for (var v = 0; 32 > v && !(b > h); v++) {
                var g = u - h, y = u + h;
                S[0] = c(t, i, r, g), S[1] = c(e, n, a, g);
                var p = m(S, T);
                if (g >= 0 && d > p)u = g, d = p; else {
                    C[0] = c(t, i, r, y), C[1] = c(e, n, a, y);
                    var _ = m(C, T);
                    1 >= y && d > _ ? (u = y, d = _) : h *= .5
                }
            }
            return l && (l[0] = c(t, i, r, u), l[1] = c(e, n, a, u)), x(d)
        }

        var v = t("./vector"), g = v[R], m = v.distSquare, y = Math.pow, x = Math.sqrt, _ = 1e-8, b = 1e-4, w = x(3), M = 1 / 3, T = g(), S = g(), C = g();
        return {
            cubicAt: n,
            cubicDerivativeAt: r,
            cubicRootAt: a,
            cubicExtrema: o,
            cubicSubdivide: s,
            cubicProjectPoint: l,
            quadraticAt: c,
            quadraticDerivativeAt: u,
            quadraticRootAt: h,
            quadraticExtremum: d,
            quadraticSubdivide: f,
            quadraticProjectPoint: p
        }
    }), e("zrender/contain/path", [U, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function (t) {
        function e(t, e) {
            return Math.abs(t - e) < m
        }

        function i() {
            var t = x[0];
            x[0] = x[1], x[1] = t
        }

        function n(t, e, n, r, a, o, s, l, c, u) {
            if (u > e && u > r && u > o && u > l || e > u && r > u && o > u && l > u)return 0;
            var h = f.cubicRootAt(e, r, o, l, u, y);
            if (0 === h)return 0;
            for (var d, p, v = 0, g = -1, m = 0; h > m; m++) {
                var _ = y[m], b = f.cubicAt(t, n, a, s, _);
                c > b || (0 > g && (g = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && g > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), g > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), v += 2 == g ? _ < x[0] ? e > d ? 1 : -1 : _ < x[1] ? d > p ? 1 : -1 : p > l ? 1 : -1 : _ < x[0] ? e > d ? 1 : -1 : d > l ? 1 : -1)
            }
            return v
        }

        function r(t, e, i, n, r, a, o, s) {
            if (s > e && s > n && s > a || e > s && n > s && a > s)return 0;
            var l = f.quadraticRootAt(e, n, a, s, y);
            if (0 === l)return 0;
            var c = f.quadraticExtremum(e, n, a);
            if (c >= 0 && 1 >= c) {
                for (var u = 0, h = f.quadraticAt(e, n, a, c), d = 0; l > d; d++) {
                    var p = f.quadraticAt(t, i, r, y[d]);
                    o > p || (u += y[d] < c ? e > h ? 1 : -1 : h > a ? 1 : -1)
                }
                return u
            }
            var p = f.quadraticAt(t, i, r, y[0]);
            return o > p ? 0 : e > a ? 1 : -1
        }

        function a(t, e, i, n, r, a, o, s) {
            if (s -= e, s > i || -i > s)return 0;
            var l = Math.sqrt(i * i - s * s);
            y[0] = -l, y[1] = l;
            var c = Math.abs(n - r);
            if (1e-4 > c)return 0;
            if (1e-4 > c % g) {
                n = 0, r = g;
                var u = a ? 1 : -1;
                return o >= y[0] + t && o <= y[1] + t ? u : 0
            }
            if (a) {
                var l = n;
                n = d(r), r = d(l)
            } else n = d(n), r = d(r);
            n > r && (r += g);
            for (var h = 0, f = 0; 2 > f; f++) {
                var p = y[f];
                if (p + t > o) {
                    var v = Math.atan2(s, p), u = a ? 1 : -1;
                    0 > v && (v = g + v), (v >= n && r >= v || v + g >= n && r >= v + g) && (v > Math.PI / 2 && v < 1.5 * Math.PI && (u = -u), h += u)
                }
            }
            return h
        }

        function o(t, i, o, l, d) {
            for (var f = 0, g = 0, m = 0, y = 0, x = 0, _ = 0; _ < t[P];) {
                var b = t[_++];
                if (b === s.M && _ > 1 && (o || (f += p(g, m, y, x, l, d)), 0 !== f))return !0;
                switch (1 == _ && (g = t[_], m = t[_ + 1], y = g, x = m), b) {
                    case s.M:
                        y = t[_++], x = t[_++], g = y, m = x;
                        break;
                    case s.L:
                        if (o) {
                            if (v(g, m, t[_], t[_ + 1], i, l, d))return !0
                        } else f += p(g, m, t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.C:
                        if (o) {
                            if (c.containStroke(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
                        } else f += n(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.Q:
                        if (o) {
                            if (u.containStroke(g, m, t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
                        } else f += r(g, m, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.A:
                        var w = t[_++], M = t[_++], T = t[_++], S = t[_++], C = t[_++], z = t[_++], A = (t[_++], 1 - t[_++]), L = Math.cos(C) * T + w, k = Math.sin(C) * S + M;
                        _ > 1 ? f += p(g, m, L, k, l, d) : (y = L, x = k);
                        var D = (l - w) * S / T + w;
                        if (o) {
                            if (h.containStroke(w, M, S, C, C + z, A, i, D, d))return !0
                        } else f += a(w, M, S, C, C + z, A, D, d);
                        g = Math.cos(C + z) * T + w, m = Math.sin(C + z) * S + M;
                        break;
                    case s.R:
                        y = g = t[_++], x = m = t[_++];
                        var I = t[_++], R = t[_++], L = y + I, k = x + R;
                        if (o) {
                            if (v(y, x, L, x, i, l, d) || v(L, x, L, k, i, l, d) || v(L, k, y, k, i, l, d) || v(y, k, L, k, i, l, d))return !0
                        } else f += p(L, x, L, k, l, d), f += p(y, k, y, x, l, d);
                        break;
                    case s.Z:
                        if (o) {
                            if (v(g, m, y, x, i, l, d))return !0
                        } else if (f += p(g, m, y, x, l, d), 0 !== f)return !0;
                        g = y, m = x
                }
            }
            return o || e(m, x) || (f += p(g, m, y, x, l, d) || 0), 0 !== f
        }

        var s = t("../core/PathProxy").CMD, l = t("./line"), c = t("./cubic"), u = t("./quadratic"), h = t("./arc"), d = t("./util").normalizeRadian, f = t("../core/curve"), p = t("./windingLine"), v = l.containStroke, g = 2 * Math.PI, m = 1e-4, y = [-1, -1, -1], x = [-1, -1];
        return {
            contain: function (t, e, i) {
                return o(t, 0, !1, e, i)
            }, containStroke: function (t, e, i, n) {
                return o(t, e, !0, i, n)
            }
        }
    }), e("zrender/core/bbox", [U, "./vector", "./curve"], function (t) {
        var e = t("./vector"), i = t("./curve"), n = {}, r = Math.min, a = Math.max, o = Math.sin, s = Math.cos, l = e[R](), c = e[R](), u = e[R](), h = 2 * Math.PI;
        n.fromPoints = function (t, e, i) {
            if (0 !== t[P]) {
                var n, o = t[0], s = o[0], l = o[0], c = o[1], u = o[1];
                for (n = 1; n < t[P]; n++)o = t[n], s = r(s, o[0]), l = a(l, o[0]), c = r(c, o[1]), u = a(u, o[1]);
                e[0] = s, e[1] = c, i[0] = l, i[1] = u
            }
        }, n.fromLine = function (t, e, i, n, o, s) {
            o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n)
        };
        var d = [], f = [];
        return n.fromCubic = function (t, e, n, o, s, l, c, u, h, p) {
            var v, g = i.cubicExtrema, m = i.cubicAt, y = g(t, n, s, c, d);
            for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, v = 0; y > v; v++) {
                var x = m(t, n, s, c, d[v]);
                h[0] = r(x, h[0]), p[0] = a(x, p[0])
            }
            for (y = g(e, o, l, u, f), v = 0; y > v; v++) {
                var _ = m(e, o, l, u, f[v]);
                h[1] = r(_, h[1]), p[1] = a(_, p[1])
            }
            h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(c, h[0]), p[0] = a(c, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(u, h[1]), p[1] = a(u, p[1])
        }, n.fromQuadratic = function (t, e, n, o, s, l, c, u) {
            var h = i.quadraticExtremum, d = i.quadraticAt, f = a(r(h(t, n, s), 1), 0), p = a(r(h(e, o, l), 1), 0), v = d(t, n, s, f), g = d(e, o, l, p);
            c[0] = r(t, s, v), c[1] = r(e, l, g), u[0] = a(t, s, v), u[1] = a(e, l, g)
        }, n.fromArc = function (t, i, n, r, a, d, f, p, v) {
            var g = e.min, m = e.max, y = Math.abs(a - d);
            if (1e-4 > y % h && y > 1e-4)return p[0] = t - n, p[1] = i - r, v[0] = t + n, void(v[1] = i + r);
            if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, c[0] = s(d) * n + t, c[1] = o(d) * r + i, g(p, l, c), m(v, l, c), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h : d > a && f && (a += h), f) {
                var x = d;
                d = a, a = x
            }
            for (var _ = 0; d > _; _ += Math.PI / 2)_ > a && (u[0] = s(_) * n + t, u[1] = o(_) * r + i, g(p, u, p), m(v, u, v))
        }, n
    }), e("zrender/config", [], function () {
        var t = 1;
        typeof window !== a && (t = Math.max(window.devicePixelRatio || 1, 1));
        var e = {debugMode: 0, devicePixelRatio: t};
        return e
    }), e("zrender/graphic/Style", [U], function () {
        var t = ["lineCap", "lineJoin", "miterLimit", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowColor"], e = function (t) {
            this.extendFrom(t)
        };
        e[H] = {
            constructor: e,
            fill: "#000000",
            stroke: null,
            opacity: 1,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: !1,
            text: null,
            textFill: "#000",
            textStroke: null,
            textPosition: "inside",
            textBaseline: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            bind: function (e, i) {
                for (var n = this.fill, r = this[l], a = 0; a < t[P]; a++) {
                    var o = t[a];
                    null != this[o] && (e[o] = this[o])
                }
                if (null != r) {
                    var s = this[c];
                    e[c] = s / (this.strokeNoScale && i && i.getLineScale ? i.getLineScale() : 1)
                }
                null == n || "none" === n || n.colorStops || (e.fillStyle = n), null == r || "none" === r || r.colorStops || (e.strokeStyle = r), null != this[p] && (e.globalAlpha = this[p])
            },
            extendFrom: function (t, e) {
                if (t) {
                    var i = this;
                    for (var n in t)!t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
                }
            },
            set: function (t, e) {
                typeof t === q ? this[t] = e : this.extendFrom(t, !0)
            },
            clone: function () {
                var t = new this.constructor;
                return t.extendFrom(this, !0), t
            },
            createLinearGradient: function (t, e, i) {
                var n = e.x * i.width + i.x, r = e.x2 * i.width + i.x, a = e.y * i[B] + i.y, o = e.y2 * i[B] + i.y, s = t.createLinearGradient(n, a, r, o);
                return s
            },
            createRadialGradient: function (t, e, i) {
                var n = i.width, r = i[B], a = Math.min(n, r), o = e.x * n + i.x, s = e.y * r + i.y, l = e.r * a, c = t.createRadialGradient(o, s, 0, o, s, l);
                return c
            },
            getGradient: function (t, e, i) {
                for (var n = "radial" === e.type ? "createRadialGradient" : "createLinearGradient", r = this[n](t, e, i), a = e.colorStops, o = 0; o < a[P]; o++)r.addColorStop(a[o].offset, a[o].color);
                return r
            }
        };
        var i, n, r = e[H];
        for (n = 0; n < t[P]; n++)i = t[n], i in r || (r[i] = null);
        return e
    }), e("echarts/model/mixin/makeStyleMapper", [U, j], function (t) {
        var e = t(j);
        return function (t) {
            for (var i = 0; i < t[P]; i++)t[i][1] || (t[i][1] = t[i][0]);
            return function (i) {
                for (var n = {}, r = 0; r < t[P]; r++) {
                    var a = t[r][1];
                    if (!(i && e[w](i, a) >= 0)) {
                        var o = this.getShallow(a);
                        null != o && (n[t[r][0]] = o)
                    }
                }
                return n
            }
        }
    }), e("zrender/Element", [U, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function (t) {
        var e = t("./core/guid"), i = t("./mixin/Eventful"), n = t("./mixin/Transformable"), r = t("./mixin/Animatable"), a = t("./core/util"), o = function (t) {
            n.call(this, t), i.call(this, t), r.call(this, t), this.id = t.id || e()
        };
        return o[H] = {
            type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function (t, e) {
                switch (this.draggable) {
                    case"horizontal":
                        e = 0;
                        break;
                    case"vertical":
                        t = 0
                }
                var i = this[Z];
                i || (i = this[Z] = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty()
            }, beforeUpdate: function () {
            }, afterUpdate: function () {
            }, update: function () {
                this.updateTransform()
            }, traverse: function () {
            }, attrKV: function (t, e) {
                if (t === v || "scale" === t || "origin" === t) {
                    if (e) {
                        var i = this[t];
                        i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
                    }
                } else this[t] = e
            }, hide: function () {
                this[O] = !0, this.__zr && this.__zr.refresh()
            }, show: function () {
                this[O] = !1, this.__zr && this.__zr.refresh()
            }, attr: function (t, e) {
                if (typeof t === q)this.attrKV(t, e); else if (a[I](t))for (var i in t)t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                return this.dirty(), this
            }, setClipPath: function (t) {
                var e = this.__zr;
                e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty()
            }, removeClipPath: function () {
                var t = this.clipPath;
                t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty())
            }, addSelfToZr: function (t) {
                this.__zr = t;
                var e = this.animators;
                if (e)for (var i = 0; i < e[P]; i++)t.animation.addAnimator(e[i]);
                this.clipPath && this.clipPath.addSelfToZr(t)
            }, removeSelfFromZr: function (t) {
                this.__zr = null;
                var e = this.animators;
                if (e)for (var i = 0; i < e[P]; i++)t.animation.removeAnimator(e[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(t)
            }
        }, a.mixin(o, r), a.mixin(o, n), a.mixin(o, i), o
    }), e("echarts/model/mixin/boxLayout", [U], function () {
        return {
            getBoxLayoutParams: function () {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get(E),
                    width: this.get("width"),
                    height: this.get(B)
                }
            }
        }
    }), e("echarts/scale/Ordinal", [U, j, "./Scale"], function (t) {
        var e = t(j), i = t("./Scale"), n = i[H], r = i[D]({
            type: "ordinal", init: function (t, e) {
                this._data = t, this._extent = e || [0, t[P] - 1]
            }, parse: function (t) {
                return typeof t === q ? e[w](this._data, t) : Math.round(t)
            }, contain: function (t) {
                return t = this.parse(t), n[f].call(this, t) && null != this._data[t]
            }, normalize: function (t) {
                return n.normalize.call(this, this.parse(t))
            }, scale: function (t) {
                return Math.round(n.scale.call(this, t))
            }, getTicks: function () {
                for (var t = [], e = this._extent, i = e[0]; i <= e[1];)t.push(i), i++;
                return t
            }, getLabel: function (t) {
                return this._data[t]
            }, count: function () {
                return this._extent[1] - this._extent[0] + 1
            }, niceTicks: e.noop, niceExtent: e.noop
        });
        return r[R] = function () {
            return new r
        }, r
    }), e("echarts/util/component", [U, j, "./clazz"], function (t) {
        var e = t(j), i = t("./clazz"), n = i.parseClassType, r = 0, a = {}, o = "_";
        return a.getUID = function (t) {
            return [t || "", r++, Math.random()].join(o)
        }, a.enableSubTypeDefaulter = function (t) {
            var e = {};
            return t.registerSubTypeDefaulter = function (t, i) {
                t = n(t), e[t.main] = i
            }, t.determineSubType = function (i, r) {
                var a = r.type;
                if (!a) {
                    var o = n(i).main;
                    t.hasSubTypes(i) && e[o] && (a = e[o](r))
                }
                return a
            }, t
        }, a.enableTopologicalTravel = function (t, i) {
            function n(t) {
                var n = {}, o = [];
                return e.each(t, function (s) {
                    var l = r(n, s), c = l.originalDeps = i(s), u = a(c, t);
                    l.entryCount = u[P], 0 === l.entryCount && o.push(s), e.each(u, function (t) {
                        e[w](l.predecessor, t) < 0 && l.predecessor.push(t);
                        var i = r(n, t);
                        e[w](i.successor, t) < 0 && i.successor.push(s)
                    })
                }), {graph: n, noEntryList: o}
            }

            function r(t, e) {
                return t[e] || (t[e] = {predecessor: [], successor: []}), t[e]
            }

            function a(t, i) {
                var n = [];
                return e.each(t, function (t) {
                    e[w](i, t) >= 0 && n.push(t)
                }), n
            }

            t.topologicalTravel = function (t, i, r, a) {
                function o(t) {
                    c[t].entryCount--, 0 === c[t].entryCount && u.push(t)
                }

                function s(t) {
                    h[t] = !0, o(t)
                }

                if (t[P]) {
                    var l = n(i), c = l.graph, u = l.noEntryList, h = {};
                    for (e.each(t, function (t) {
                        h[t] = !0
                    }); u[P];) {
                        var d = u.pop(), f = c[d], p = !!h[d];
                        p && (r.call(a, d, f.originalDeps.slice()), delete h[d]), e.each(f.successor, p ? s : o)
                    }
                    e.each(h, function () {
                        throw new Error("Circle dependency may exists")
                    })
                }
            }
        }, a
    }), e("zrender/core/guid", [], function () {
        var t = 2311;
        return function () {
            return "zr_" + t++
        }
    }), e("zrender/mixin/Transformable", [U, "../core/matrix", "../core/vector"], function (t) {
        function e(t) {
            return t > a || -a > t
        }

        var i = t("../core/matrix"), n = t("../core/vector"), r = i.identity, a = 5e-5, o = function (t) {
            t = t || {}, t[v] || (this[v] = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
        }, s = o[H];
        s[Z] = null, s.needLocalTransform = function () {
            return e(this.rotation) || e(this[v][0]) || e(this[v][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
        }, s.updateTransform = function () {
            var t = this.parent, e = t && t[Z], n = this.needLocalTransform(), a = this[Z];
            return n || e ? (a = a || i[R](), n ? this.getLocalTransform(a) : r(a), e && (n ? i.mul(a, t[Z], a) : i.copy(a, t[Z])), this[Z] = a, this.invTransform = this.invTransform || i[R](), void i.invert(this.invTransform, a)) : void(a && r(a))
        }, s.getLocalTransform = function (t) {
            t = t || [], r(t);
            var e = this.origin, n = this.scale, a = this.rotation, o = this[v];
            return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), a && i.rotate(t, t, a), e && (t[4] += e[0], t[5] += e[1]), t[4] += o[0], t[5] += o[1], t
        }, s.setTransform = function (t) {
            var e = this[Z];
            e && t[Z](e[0], e[1], e[2], e[3], e[4], e[5])
        };
        var l = [];
        return s.decomposeTransform = function () {
            if (this[Z]) {
                var t = this.parent, n = this[Z];
                t && t[Z] && (i.mul(l, t.invTransform, n), n = l);
                var r = n[0] * n[0] + n[1] * n[1], a = n[2] * n[2] + n[3] * n[3], o = this[v], s = this.scale;
                e(r - 1) && (r = Math.sqrt(r)), e(a - 1) && (a = Math.sqrt(a)), n[0] < 0 && (r = -r), n[3] < 0 && (a = -a), o[0] = n[4], o[1] = n[5], s[0] = r, s[1] = a, this.rotation = Math.atan2(-n[1] / a, n[0] / r)
            }
        }, s.getGlobalScale = function () {
            var t = this[Z];
            if (!t)return [1, 1];
            var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]), i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
            return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i]
        }, s.transformCoordToLocal = function (t, e) {
            var i = [t, e], r = this.invTransform;
            return r && n[u](i, i, r), i
        }, s.transformCoordToGlobal = function (t, e) {
            var i = [t, e], r = this[Z];
            return r && n[u](i, i, r), i
        }, o
    }), e("zrender/mixin/Animatable", [U, "../animation/Animator", r, "../core/log"], function (t) {
        var e = t("../animation/Animator"), i = t(r), n = i.isString, a = i.isFunction, o = i[I], s = t("../core/log"), l = function () {
            this.animators = []
        };
        return l[H] = {
            constructor: l, animate: function (t, n) {
                var r, a = !1, o = this, l = this.__zr;
                if (t) {
                    var c = t.split("."), u = o;
                    a = "shape" === c[0];
                    for (var h = 0, d = c[P]; d > h; h++)u && (u = u[c[h]]);
                    u && (r = u)
                } else r = o;
                if (!r)return void s('Property "' + t + '" is not existed in element ' + o.id);
                var f = o.animators, p = new e(r, n);
                return p.during(function () {
                    o.dirty(a)
                }).done(function () {
                    f[A](i[w](f, p), 1)
                }), f.push(p), l && l.animation.addAnimator(p), p
            }, stopAnimation: function (t) {
                for (var e = this.animators, i = e[P], n = 0; i > n; n++)e[n].stop(t);
                return e[P] = 0, this
            }, animateTo: function (t, e, i, r, o) {
                function s() {
                    c--, c || o && o()
                }

                n(i) ? (o = r, r = i, i = 0) : a(r) ? (o = r, r = "linear", i = 0) : a(i) ? (o = i, i = 0) : a(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, r, o);
                var l = this.animators.slice(), c = l[P];
                c || o && o();
                for (var u = 0; u < l[P]; u++)l[u].done(s).start(r)
            }, _animateToShallow: function (t, e, n, r, a) {
                var s = {}, l = 0;
                for (var c in n)if (null != e[c])o(n[c]) && !i.isArrayLike(n[c]) ? this._animateToShallow(t ? t + "." + c : c, e[c], n[c], r, a) : (s[c] = n[c], l++); else if (null != n[c])if (t) {
                    var u = {};
                    u[t] = {}, u[t][c] = n[c], this.attr(u)
                } else this.attr(c, n[c]);
                return l > 0 && this.animate(t, !1).when(null == r ? 500 : r, s).delay(a || 0), this
            }
        }, l
    }), e("echarts/coord/cartesian/Cartesian", [U, j], function (t) {
        function e(t) {
            return this._axes[t]
        }

        var i = t(j), n = function (t) {
            this._axes = {}, this._dimList = [], this.name = t || ""
        };
        return n[H] = {
            constructor: n, type: "cartesian", getAxis: function (t) {
                return this._axes[t]
            }, getAxes: function () {
                return i.map(this._dimList, e, this)
            }, getAxesByScale: function (t) {
                return t = t[W](), i[X](this.getAxes(), function (e) {
                    return e.scale.type === t
                })
            }, addAxis: function (t) {
                var e = t.dim;
                this._axes[e] = t, this._dimList.push(e)
            }, dataToCoord: function (t) {
                return this._dataCoordConvert(t, "dataToCoord")
            }, coordToData: function (t) {
                return this._dataCoordConvert(t, "coordToData")
            }, _dataCoordConvert: function (t, e) {
                for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[P]; r++) {
                    var a = i[r], o = this._axes[a];
                    n[a] = o[e](t[a])
                }
                return n
            }
        }, n
    }), e("zrender/animation/Animator", [U, "./Clip", "../tool/color", r], function (t) {
        function e(t, e) {
            return t[e]
        }

        function i(t, e, i) {
            t[e] = i
        }

        function n(t, e, i) {
            return (e - t) * i + t
        }

        function a(t, e, i) {
            return i > .5 ? e : t
        }

        function o(t, e, i, r, a) {
            var o = t[P];
            if (1 == a)for (var s = 0; o > s; s++)r[s] = n(t[s], e[s], i); else for (var l = t[0][P], s = 0; o > s; s++)for (var c = 0; l > c; c++)r[s][c] = n(t[s][c], e[s][c], i)
        }

        function s(t, e, i) {
            var n = t[P], r = e[P];
            if (n !== r) {
                var a = n > r;
                if (a)t[P] = r; else for (var o = n; r > o; o++)t.push(1 === i ? e[o] : y.call(e[o]))
            }
            for (var s = t[0] && t[0][P], o = 0; o < t[P]; o++)if (1 === i)isNaN(t[o]) && (t[o] = e[o]); else for (var l = 0; s > l; l++)isNaN(t[o][l]) && (t[o][l] = e[o][l])
        }

        function l(t, e, i) {
            if (t === e)return !0;
            var n = t[P];
            if (n !== e[P])return !1;
            if (1 === i) {
                for (var r = 0; n > r; r++)if (t[r] !== e[r])return !1
            } else for (var a = t[0][P], r = 0; n > r; r++)for (var o = 0; a > o; o++)if (t[r][o] !== e[r][o])return !1;
            return !0
        }

        function c(t, e, i, n, r, a, o, s, l) {
            var c = t[P];
            if (1 == l)for (var h = 0; c > h; h++)s[h] = u(t[h], e[h], i[h], n[h], r, a, o); else for (var d = t[0][P], h = 0; c > h; h++)for (var f = 0; d > f; f++)s[h][f] = u(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o)
        }

        function u(t, e, i, n, r, a, o) {
            var s = .5 * (i - t), l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }

        function h(t) {
            if (m(t)) {
                var e = t[P];
                if (m(t[0])) {
                    for (var i = [], n = 0; e > n; n++)i.push(y.call(t[n]));
                    return i
                }
                return y.call(t)
            }
            return t
        }

        function d(t) {
            return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
        }

        function f(t, e, i, r, h) {
            var f = t._getter, g = t._setter, y = "spline" === e, x = r[P];
            if (x) {
                var _, b = r[0].value, w = m(b), M = !1, T = !1, S = w && m(b[0]) ? 2 : 1;
                r.sort(function (t, e) {
                    return t.time - e.time
                }), _ = r[x - 1].time;
                for (var C = [], z = [], A = r[0].value, L = !0, k = 0; x > k; k++) {
                    C.push(r[k].time / _);
                    var D = r[k].value;
                    if (w && l(D, A, S) || !w && D === A || (L = !1), A = D, typeof D == q) {
                        var I = v.parse(D);
                        I ? (D = I, M = !0) : T = !0
                    }
                    z.push(D)
                }
                if (!L) {
                    for (var R = z[x - 1], k = 0; x - 1 > k; k++)w ? s(z[k], R, S) : !isNaN(z[k]) || isNaN(R) || T || M || (z[k] = R);
                    w && s(f(t._target, h), R, S);
                    var B, E, O, N, F, V, G = 0, H = 0;
                    if (M)var W = [0, 0, 0, 0];
                    var X = function (t, e) {
                        var i;
                        if (H > e) {
                            for (B = Math.min(G + 1, x - 1), i = B; i >= 0 && !(C[i] <= e); i--);
                            i = Math.min(i, x - 2)
                        } else {
                            for (i = G; x > i && !(C[i] > e); i++);
                            i = Math.min(i - 1, x - 2)
                        }
                        G = i, H = e;
                        var r = C[i + 1] - C[i];
                        if (0 !== r)if (E = (e - C[i]) / r, y)if (N = z[i], O = z[0 === i ? i : i - 1], F = z[i > x - 2 ? x - 1 : i + 1], V = z[i > x - 3 ? x - 1 : i + 2], w)c(O, N, F, V, E, E * E, E * E * E, f(t, h), S); else {
                            var s;
                            if (M)s = c(O, N, F, V, E, E * E, E * E * E, W, 1), s = d(W); else {
                                if (T)return a(N, F, E);
                                s = u(O, N, F, V, E, E * E, E * E * E)
                            }
                            g(t, h, s)
                        } else if (w)o(z[i], z[i + 1], E, f(t, h), S); else {
                            var s;
                            if (M)o(z[i], z[i + 1], E, W, 1), s = d(W); else {
                                if (T)return a(z[i], z[i + 1], E);
                                s = n(z[i], z[i + 1], E)
                            }
                            g(t, h, s)
                        }
                    }, Z = new p({
                        target: t._target,
                        life: _,
                        loop: t._loop,
                        delay: t._delay,
                        onframe: X,
                        ondestroy: i
                    });
                    return e && "spline" !== e && (Z.easing = e), Z
                }
            }
        }

        var p = t("./Clip"), v = t("../tool/color"), g = t(r), m = g.isArrayLike, y = Array[H].slice, x = function (t, n, r, a) {
            this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
        };
        return x[H] = {
            when: function (t, e) {
                var i = this._tracks;
                for (var n in e) {
                    if (!i[n]) {
                        i[n] = [];
                        var r = this._getter(this._target, n);
                        if (null == r)continue;
                        0 !== t && i[n].push({time: 0, value: h(r)})
                    }
                    i[n].push({time: t, value: e[n]})
                }
                return this
            }, during: function (t) {
                return this._onframeList.push(t), this
            }, _doneCallback: function () {
                this._tracks = {}, this._clipList[P] = 0;
                for (var t = this._doneList, e = t[P], i = 0; e > i; i++)t[i].call(this)
            }, start: function (t) {
                var e, i = this, n = 0, r = function () {
                    n--, n || i._doneCallback()
                };
                for (var a in this._tracks) {
                    var o = f(this, t, r, this._tracks[a], a);
                    o && (this._clipList.push(o), n++, this.animation && this.animation.addClip(o), e = o)
                }
                if (e) {
                    var s = e.onframe;
                    e.onframe = function (t, e) {
                        s(t, e);
                        for (var n = 0; n < i._onframeList[P]; n++)i._onframeList[n](t, e)
                    }
                }
                return n || this._doneCallback(), this
            }, stop: function (t) {
                for (var e = this._clipList, i = this.animation, n = 0; n < e[P]; n++) {
                    var r = e[n];
                    t && r.onframe(this._target, 1), i && i.removeClip(r)
                }
                e[P] = 0
            }, delay: function (t) {
                return this._delay = t, this
            }, done: function (t) {
                return t && this._doneList.push(t), this
            }, getClips: function () {
                return this._clipList
            }
        }, x
    }), e("zrender/core/log", [U, "../config"], function (t) {
        var e = t("../config");
        return function () {
            if (0 !== e.debugMode)if (1 == e.debugMode)for (var t in arguments)throw new Error(arguments[t]); else if (e.debugMode > 1)for (var t in arguments)console.log(arguments[t])
        }
    }), e("echarts/coord/Axis", [U, "../util/number", j], function (t) {
        function e(t, e) {
            var i = t[1] - t[0], n = e, r = i / n / 2;
            t[0] += r, t[1] -= r
        }

        var n = t("../util/number"), r = n.linearMap, a = t(j), o = [0, 1], s = function (t, e, i) {
            this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
        };
        return s[H] = {
            constructor: s, contain: function (t) {
                var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]);
                return t >= i && n >= t
            }, containData: function (t) {
                return this[f](this.dataToCoord(t))
            }, getExtent: function () {
                var t = this._extent.slice();
                return t
            }, getPixelPrecision: function (t) {
                return n.getPixelPrecision(t || this.scale[d](), this._extent)
            }, setExtent: function (t, e) {
                var i = this._extent;
                i[0] = t, i[1] = e
            }, dataToCoord: function (t, n) {
                var a = this._extent, s = this.scale;
                return t = s.normalize(t), this.onBand && s.type === i && (a = a.slice(), e(a, s.count())), r(t, o, a, n)
            }, coordToData: function (t, n) {
                var a = this._extent, s = this.scale;
                this.onBand && s.type === i && (a = a.slice(), e(a, s.count()));
                var l = r(t, a, o, n);
                return this.scale.scale(l)
            }, getTicksCoords: function () {
                if (this.onBand) {
                    for (var t = this.getBands(), e = [], i = 0; i < t[P]; i++)e.push(t[i][0]);
                    return t[i - 1] && e.push(t[i - 1][1]), e
                }
                return a.map(this.scale.getTicks(), this.dataToCoord, this)
            }, getLabelsCoords: function () {
                if (this.onBand) {
                    for (var t, e = this.getBands(), i = [], n = 0; n < e[P]; n++)t = e[n], i.push((t[0] + t[1]) / 2);
                    return i
                }
                return a.map(this.scale.getTicks(), this.dataToCoord, this)
            }, getBands: function () {
                for (var t = this[d](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++)e.push([a * o / i + n, a * (o + 1) / i + n]);
                return e
            }, getBandWidth: function () {
                var t = this._extent, e = this.scale[d](), i = e[1] - e[0] + (this.onBand ? 1 : 0);
                0 === i && (i = 1);
                var n = Math.abs(t[1] - t[0]);
                return Math.abs(n) / i
            }
        }, s
    }), e("echarts/coord/cartesian/axisLabelInterval", [U, j, "../axisHelper"], function (t) {
        var e = t(j), i = t("../axisHelper");
        return function (t) {
            var r = t.model, a = r[V]("axisLabel"), o = a.get("interval");
            return t.type !== n || "auto" !== o ? "auto" === o ? 0 : o : i.getAxisLabelInterval(e.map(t.scale.getTicks(), t.dataToCoord, t), r.getFormattedLabels(), a[V](_)[x](), t.isHorizontal())
        }
    }),e("zrender/animation/Clip", [U, "./easing"], function (t) {
        function e(t) {
            this._target = t[C], this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
        }

        var i = t("./easing");
        return e[H] = {
            constructor: e, step: function (t) {
                this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
                var e = (t - this._startTime) / this._life;
                if (!(0 > e)) {
                    e = Math.min(e, 1);
                    var n = this.easing, r = typeof n == q ? i[n] : n, a = typeof r === b ? r(e) : e;
                    return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null
                }
            }, restart: function () {
                var t = (new Date).getTime(), e = (t - this._startTime) % this._life;
                this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1
            }, fire: function (t, e) {
                t = "on" + t, this[t] && this[t](this._target, e)
            }
        }, e
    }),e("echarts/coord/cartesian/AxisModel", [U, "../../model/Component", j, "../axisModelCreator", "../axisModelCommonMixin"], function (t) {
        function e(t, e) {
            return e.type || (e.data ? n : "value")
        }

        var i = t("../../model/Component"), r = t(j), a = t("../axisModelCreator"), o = i[D]({
            type: "cartesian2dAxis",
            axis: null,
            init: function () {
                o.superApply(this, "init", arguments), this._resetRange()
            },
            mergeOption: function () {
                o.superApply(this, "mergeOption", arguments), this._resetRange()
            },
            restoreData: function () {
                o.superApply(this, "restoreData", arguments), this._resetRange()
            },
            setRange: function (t, e) {
                this.option.rangeStart = t, this.option.rangeEnd = e
            },
            getMin: function () {
                var t = this.option;
                return null != t.rangeStart ? t.rangeStart : t.min
            },
            getMax: function () {
                var t = this.option;
                return null != t.rangeEnd ? t.rangeEnd : t.max
            },
            getNeedCrossZero: function () {
                var t = this.option;
                return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
            },
            _resetRange: function () {
                this.option.rangeStart = this.option.rangeEnd = null
            }
        });
        r.merge(o[H], t("../axisModelCommonMixin"));
        var s = {gridIndex: 0};
        return a("x", o, e, s), a("y", o, e, s), o
    }),e("zrender/animation/easing", [], function () {
        var t = {
            linear: function (t) {
                return t
            }, quadraticIn: function (t) {
                return t * t
            }, quadraticOut: function (t) {
                return t * (2 - t)
            }, quadraticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            }, cubicIn: function (t) {
                return t * t * t
            }, cubicOut: function (t) {
                return --t * t * t + 1
            }, cubicInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            }, quarticIn: function (t) {
                return t * t * t * t
            }, quarticOut: function (t) {
                return 1 - --t * t * t * t
            }, quarticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            }, quinticIn: function (t) {
                return t * t * t * t * t
            }, quinticOut: function (t) {
                return --t * t * t * t * t + 1
            }, quinticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            }, sinusoidalIn: function (t) {
                return 1 - Math.cos(t * Math.PI / 2)
            }, sinusoidalOut: function (t) {
                return Math.sin(t * Math.PI / 2)
            }, sinusoidalInOut: function (t) {
                return .5 * (1 - Math.cos(Math.PI * t))
            }, exponentialIn: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            }, exponentialOut: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            }, exponentialInOut: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
            }, circularIn: function (t) {
                return 1 - Math.sqrt(1 - t * t)
            }, circularOut: function (t) {
                return Math.sqrt(1 - --t * t)
            }, circularInOut: function (t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }, elasticIn: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
            }, elasticOut: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
            }, elasticInOut: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
            }, backIn: function (t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e)
            }, backOut: function (t) {
                var e = 1.70158;
                return --t * t * ((e + 1) * t + e) + 1
            }, backInOut: function (t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            }, bounceIn: function (e) {
                return 1 - t.bounceOut(1 - e)
            }, bounceOut: function (t) {
                return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }, bounceInOut: function (e) {
                return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
            }
        };
        return t
    }),e("echarts/coord/axisModelCreator", [U, "./axisDefault", j, "../model/Component", "../util/layout"], function (t) {
        var e = t("./axisDefault"), i = t(j), r = t("../model/Component"), a = t("../util/layout"), o = ["value", n, "time", "log"];
        return function (t, n, s, l) {
            i.each(o, function (r) {
                n[D]({
                    type: t + "Axis." + r, mergeDefaultAndTheme: function (e, n) {
                        var o = this.layoutMode, l = o ? a.getLayoutParams(e) : {}, c = n.getTheme();
                        i.merge(e, c.get(r + "Axis")), i.merge(e, this.getDefaultOption()), e.type = s(t, e), o && a.mergeLayoutParam(e, l, o)
                    }, defaultOption: i.mergeAll([{}, e[r + "Axis"], l], !0)
                })
            }), r.registerSubTypeDefaulter(t + "Axis", i.curry(s, t))
        }
    }),e("zrender/contain/cubic", [U, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, c, u, h) {
                if (0 === c)return !1;
                var d = c;
                if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || u > t + d && u > n + d && u > a + d && u > s + d || t - d > u && n - d > u && a - d > u && s - d > u)return !1;
                var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, u, h, null);
                return d / 2 >= f
            }
        }
    }),e("zrender/contain/line", [], function () {
        return {
            containStroke: function (t, e, i, n, r, a, o) {
                if (0 === r)return !1;
                var s = r, l = 0, c = t;
                if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a)return !1;
                if (t === i)return Math.abs(a - t) <= s / 2;
                l = (e - n) / (t - i), c = (t * n - i * e) / (t - i);
                var u = l * a - o + c, h = u * u / (l * l + 1);
                return s / 2 * s / 2 >= h
            }
        }
    }),e("echarts/coord/axisModelCommonMixin", [U, j, "./axisHelper"], function (t) {
        function e(t) {
            return a[I](t) && null != t.value ? t.value : t
        }

        function i() {
            return this.get("type") === n && a.map(this.get("data"), e)
        }

        function r() {
            return o.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
        }

        var a = t(j), o = t("./axisHelper");
        return {getFormattedLabels: r, getCategories: i}
    }),e("zrender/contain/quadratic", [U, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, c) {
                if (0 === s)return !1;
                var u = s;
                if (c > i + u && c > r + u && c > o + u || i - u > c && r - u > c && o - u > c || l > t + u && l > n + u && l > a + u || t - u > l && n - u > l && a - u > l)return !1;
                var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, c, null);
                return u / 2 >= h
            }
        }
    }),e("zrender/contain/arc", [U, "./util"], function (t) {
        var e = t("./util").normalizeRadian, i = 2 * Math.PI;
        return {
            containStroke: function (t, n, r, a, o, s, l, c, u) {
                if (0 === l)return !1;
                var h = l;
                c -= t, u -= n;
                var d = Math.sqrt(c * c + u * u);
                if (d - h > r || r > d + h)return !1;
                if (Math.abs(a - o) % i < 1e-4)return !0;
                if (s) {
                    var f = a;
                    a = e(o), o = e(f)
                } else a = e(a), o = e(o);
                a > o && (o += i);
                var p = Math.atan2(u, c);
                return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i
            }
        }
    }),e("zrender/contain/util", [U], function () {
        var t = 2 * Math.PI;
        return {
            normalizeRadian: function (e) {
                return e %= t, 0 > e && (e += t), e
            }
        }
    }),e("zrender/contain/windingLine", [], function () {
        return function (t, e, i, n, r, a) {
            if (a > e && a > n || e > a && n > a)return 0;
            if (n === e)return 0;
            var o = e > n ? 1 : -1, s = (a - e) / (n - e), l = s * (i - t) + t;
            return l > r ? o : 0
        }
    }),e("zrender/graphic/helper/roundRect", [U], function () {
        return {
            buildPath: function (t, e) {
                var i, n, r, a, o = e.x, s = e.y, l = e.width, c = e[B], u = e.r;
                0 > l && (o += l, l = -l), 0 > c && (s += c, c = -c), "number" == typeof u ? i = n = r = a = u : u instanceof Array ? 1 === u[P] ? i = n = r = a = u[0] : 2 === u[P] ? (i = r = u[0], n = a = u[1]) : 3 === u[P] ? (i = u[0], n = a = u[1], r = u[2]) : (i = u[0], n = u[1], r = u[2], a = u[3]) : i = n = r = a = 0;
                var h;
                i + n > l && (h = i + n, i *= l / h, n *= l / h), r + a > l && (h = r + a, r *= l / h, a *= l / h), n + r > c && (h = n + r, n *= c / h, r *= c / h), i + a > c && (h = i + a, i *= c / h, a *= c / h), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.quadraticCurveTo(o + l, s, o + l, s + n), t.lineTo(o + l, s + c - r), 0 !== r && t.quadraticCurveTo(o + l, s + c, o + l - r, s + c), t.lineTo(o + a, s + c), 0 !== a && t.quadraticCurveTo(o, s + c, o, s + c - a), t.lineTo(o, s + i), 0 !== i && t.quadraticCurveTo(o, s, o + i, s)
            }
        }
    }),e("zrender/core/LRU", [U], function () {
        var t = function () {
            this.head = null, this.tail = null, this._len = 0
        }, e = t[H];
        e.insert = function (t) {
            var e = new i(t);
            return this.insertEntry(e), e
        }, e.insertEntry = function (t) {
            this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
        }, e.remove = function (t) {
            var e = t.prev, i = t.next;
            e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
        }, e.len = function () {
            return this._len
        };
        var i = function (t) {
            this.value = t, this.next, this.prev
        }, n = function (e) {
            this._list = new t, this._map = {}, this._maxSize = e || 10
        }, r = n[H];
        return r.put = function (t, e) {
            var i = this._list, n = this._map;
            if (null == n[t]) {
                var r = i.len();
                if (r >= this._maxSize && r > 0) {
                    var a = i.head;
                    i.remove(a), delete n[a.key]
                }
                var o = i.insert(e);
                o.key = t, n[t] = o
            }
        }, r.get = function (t) {
            var e = this._map[t], i = this._list;
            return null != e ? (e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value) : void 0
        }, r.clear = function () {
            this._list.clear(), this._map = {}
        }, n
    }),e("zrender/graphic/helper/poly", [U, "./smoothSpline", "./smoothBezier"], function (t) {
        var e = t("./smoothSpline"), i = t("./smoothBezier");
        return {
            buildPath: function (t, n, r) {
                var a = n.points, o = n.smooth;
                if (a && a[P] >= 2) {
                    if (o && "spline" !== o) {
                        var s = i(a, o, r, n.smoothConstraint);
                        t.moveTo(a[0][0], a[0][1]);
                        for (var l = a[P], c = 0; (r ? l : l - 1) > c; c++) {
                            var u = s[2 * c], h = s[2 * c + 1], d = a[(c + 1) % l];
                            t.bezierCurveTo(u[0], u[1], h[0], h[1], d[0], d[1])
                        }
                    } else {
                        "spline" === o && (a = e(a, r)), t.moveTo(a[0][0], a[0][1]);
                        for (var c = 1, f = a[P]; f > c; c++)t.lineTo(a[c][0], a[c][1])
                    }
                    r && t.closePath()
                }
            }
        }
    }),e("zrender/Handler", [U, "./core/env", "./core/event", "./core/util", "./mixin/Draggable", "./core/GestureMgr", "./mixin/Eventful"], function (t) {
        function e(t, e, i) {
            return {
                type: t,
                event: i,
                target: e,
                cancelBubble: !1,
                offsetX: i.zrX,
                offsetY: i.zrY,
                gestureEvent: i.gestureEvent,
                pinchX: i.pinchX,
                pinchY: i.pinchY,
                pinchScale: i.pinchScale,
                wheelDelta: i.zrDelta
            }
        }

        function i(t, e, i) {
            var n = t._gestureMgr;
            "start" === i && n.clear();
            var r = n.recognize(e, t.findHover(e.zrX, e.zrY, null));
            if ("end" === i && n.clear(), r) {
                var a = r.type;
                e.gestureEvent = a, t._dispatchProxy(r[C], a, r.event)
            }
        }

        function n(t) {
            function e(t, e) {
                return function () {
                    return e._touching ? void 0 : t.apply(e, arguments)
                }
            }

            for (var i = y[h](x), n = 0; n < i[P]; n++) {
                var r = i[n];
                t._handlers[r] = d.bind(S[r], t)
            }
            for (var n = 0; n < m[P]; n++) {
                var r = m[n];
                t._handlers[r] = e(S[r], t)
            }
        }

        function r(t, e, i) {
            if (t[t.rectHover ? "rectContain" : f](e, i)) {
                for (var n = t; n;) {
                    if (n.silent || n.clipPath && !n.clipPath[f](e, i))return !1;
                    n = n.parent
                }
                return !0
            }
            return !1
        }

        function a(t) {
            t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
                t._touching = !1
            }, 700)
        }

        function o() {
            return !1
        }

        function s() {
            return c.touchEventsSupported
        }

        function l(t) {
            return "mousewheel" === t && c.browser.firefox ? "DOMMouseScroll" : t
        }

        var c = t("./core/env"), u = t("./core/event"), d = t("./core/util"), p = t("./mixin/Draggable"), v = t("./core/GestureMgr"), g = t("./mixin/Eventful"), m = ["click", "dblclick", "mousewheel", "mouseout"];
        !o() && m.push("mouseup", "mousedown", "mousemove");
        var y = ["touchstart", "touchend", "touchmove"], x = ["pointerdown", "pointerup", "pointermove"], _ = 300, w = u.addEventListener, M = u.removeEventListener, T = u.normalizeEvent, S = {
            mousemove: function (t) {
                t = T(this.root, t);
                var e = t.zrX, i = t.zrY, n = this.findHover(e, i, null), r = this._hovered;
                this._hovered = n, this.root.style.cursor = n ? n.cursor : this._defaultCursorStyle, r && n !== r && r.__zr && this._dispatchProxy(r, "mouseout", t), this._dispatchProxy(n, "mousemove", t), n && n !== r && this._dispatchProxy(n, "mouseover", t)
            }, mouseout: function (t) {
                t = T(this.root, t);
                var e = t.toElement || t.relatedTarget;
                if (e != this.root)for (; e && 9 != e.nodeType;) {
                    if (e === this.root)return;
                    e = e.parentNode
                }
                this._dispatchProxy(this._hovered, "mouseout", t), this.trigger("globalout", {event: t})
            }, touchstart: function (t) {
                t = T(this.root, t), this._lastTouchMoment = new Date, i(this, t, "start"), S.mousemove.call(this, t), S.mousedown.call(this, t), a(this)
            }, touchmove: function (t) {
                t = T(this.root, t), i(this, t, "change"), S.mousemove.call(this, t), a(this)
            }, touchend: function (t) {
                t = T(this.root, t), i(this, t, "end"), S.mouseup.call(this, t), +new Date - this._lastTouchMoment < _ && S.click.call(this, t), a(this)
            }
        };
        d.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function (t) {
            S[t] = function (e) {
                e = T(this.root, e);
                var i = this.findHover(e.zrX, e.zrY, null);
                if ("mousedown" === t)this._downel = i, this._upel = i; else if ("mosueup" === t)this._upel = i; else if ("click" === t && this._downel !== this._upel)return;
                this._dispatchProxy(i, t, e)
            }
        });
        var z = function (t, e, i) {
            function r(e, i) {
                d.each(e, function (e) {
                    w(t, l(e), i._handlers[e])
                }, i)
            }

            g.call(this), this.root = t, this.storage = e, this.painter = i, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, this._defaultCursorStyle = "default", this._gestureMgr = new v, this._handlers = [], this._touching = !1, this._touchTimer, n(this), o() ? r(x, this) : s() && r(y, this), r(m, this), p.call(this)
        };
        return z[H] = {
            constructor: z, resize: function () {
                this._hovered = null
            }, dispatch: function (t, e) {
                var i = this._handlers[t];
                i && i.call(this, e)
            }, dispose: function () {
                for (var t = this.root, e = m[h](y), i = 0; i < e[P]; i++) {
                    var n = e[i];
                    M(t, l(n), this._handlers[n])
                }
                this.root = this.storage = this.painter = null
            }, setDefaultCursorStyle: function (t) {
                this._defaultCursorStyle = t
            }, _dispatchProxy: function (t, i, n) {
                for (var r = "on" + i, a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o.trigger(i, a), o = o.parent, !a.cancelBubble););
                a.cancelBubble || (this.trigger(i, a), this.painter && this.painter.eachOtherLayer(function (t) {
                    typeof t[r] == b && t[r].call(t, a), t.trigger && t.trigger(i, a)
                }))
            }, findHover: function (t, e, i) {
                for (var n = this.storage.getDisplayList(), a = n[P] - 1; a >= 0; a--)if (!n[a].silent && n[a] !== i && !n[a][O] && r(n[a], t, e))return n[a]
            }
        }, d.mixin(z, g), d.mixin(z, p), z
    }),e("echarts/coord/axisDefault", [U, j], function (t) {
        var e = t(j), i = {
            show: !0,
            zlevel: 0,
            z: 0,
            inverse: !1,
            name: "",
            nameLocation: "end",
            nameTextStyle: {},
            nameGap: 15,
            silent: !0,
            axisLine: {show: !0, onZero: !0, lineStyle: {color: "#333", width: 1, type: "solid"}},
            axisTick: {show: !0, inside: !1, length: 5, lineStyle: {color: "#333", width: 1}},
            axisLabel: {show: !0, inside: !1, rotate: 0, margin: 8, textStyle: {color: "#333", fontSize: 12}},
            splitLine: {show: !0, lineStyle: {color: ["#ccc"], width: 1, type: "solid"}},
            splitArea: {show: !1, areaStyle: {color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]}}
        }, n = e.merge({
            boundaryGap: !0,
            axisTick: {interval: "auto"},
            axisLabel: {interval: "auto"}
        }, i), r = e[k]({boundaryGap: [0, 0], splitNumber: 5}, i), a = e[k]({
            scale: !0,
            min: "dataMin",
            max: "dataMax"
        }, r), o = e[k]({}, r);
        return o.scale = !0, {categoryAxis: n, valueAxis: r, timeAxis: a, logAxis: o}
    }),e("zrender/Storage", [U, "./core/util", "./container/Group"], function (t) {
        function e(t, e) {
            return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 === e.z2 ? t.__renderidx - e.__renderidx : t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
        }

        var i = t("./core/util"), n = t("./container/Group"), r = function () {
            this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
        };
        return r[H] = {
            constructor: r, getDisplayList: function (t, e) {
                return e = e || !1, t && this.updateDisplayList(e), this._displayList
            }, updateDisplayList: function (t) {
                this._displayListLen = 0;
                for (var i = this._roots, n = this._displayList, r = 0, a = i[P]; a > r; r++)this._updateAndAddDisplayable(i[r], null, t);
                n[P] = this._displayListLen;
                for (var r = 0, a = n[P]; a > r; r++)n[r].__renderidx = r;
                n.sort(e)
            }, _updateAndAddDisplayable: function (t, e, i) {
                if (!t[O] || i) {
                    t.beforeUpdate(), t.update(), t.afterUpdate();
                    var n = t.clipPath;
                    if (n && (n.parent = t, n.updateTransform(), e ? (e = e.slice(), e.push(n)) : e = [n]), "group" == t.type) {
                        for (var r = t._children, a = 0; a < r[P]; a++) {
                            var o = r[a];
                            o.__dirty = t.__dirty || o.__dirty, this._updateAndAddDisplayable(o, e, i)
                        }
                        t.__dirty = !1
                    } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
                }
            }, addRoot: function (t) {
                this._elements[t.id] || (t instanceof n && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
            }, delRoot: function (t) {
                if (null == t) {
                    for (var e = 0; e < this._roots[P]; e++) {
                        var r = this._roots[e];
                        r instanceof n && r.delChildrenFromStorage(this)
                    }
                    return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0)
                }
                if (t instanceof Array)for (var e = 0, a = t[P]; a > e; e++)this.delRoot(t[e]); else {
                    var o;
                    o = typeof t == q ? this._elements[t] : t;
                    var s = i[w](this._roots, o);
                    s >= 0 && (this.delFromMap(o.id), this._roots[A](s, 1), o instanceof n && o.delChildrenFromStorage(this))
                }
            }, addToMap: function (t) {
                return t instanceof n && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this
            }, get: function (t) {
                return this._elements[t]
            }, delFromMap: function (t) {
                var e = this._elements, i = e[t];
                return i && (delete e[t], i instanceof n && (i.__storage = null)), this
            }, dispose: function () {
                this._elements = this._renderList = this._roots = null
            }
        }, r
    }),e("zrender/animation/Animation", [U, r, "../core/event", "./Animator"], function (t) {
        var e = t(r), i = t("../core/event").Dispatcher, n = typeof window !== a && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
                setTimeout(t, 16)
            }, o = t("./Animator"), s = function (t) {
            t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {
            }, this._clips = [], this._running = !1, this._time = 0, i.call(this)
        };
        return s[H] = {
            constructor: s, addClip: function (t) {
                this._clips.push(t)
            }, addAnimator: function (t) {
                t.animation = this;
                for (var e = t.getClips(), i = 0; i < e[P]; i++)this.addClip(e[i])
            }, removeClip: function (t) {
                var i = e[w](this._clips, t);
                i >= 0 && this._clips[A](i, 1)
            }, removeAnimator: function (t) {
                for (var e = t.getClips(), i = 0; i < e[P]; i++)this.removeClip(e[i]);
                t.animation = null
            }, _update: function () {
                for (var t = (new Date).getTime(), e = t - this._time, i = this._clips, n = i[P], r = [], a = [], o = 0; n > o; o++) {
                    var s = i[o], l = s.step(t);
                    l && (r.push(l), a.push(s))
                }
                for (var o = 0; n > o;)i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
                n = r[P];
                for (var o = 0; n > o; o++)a[o].fire(r[o]);
                this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update()
            }, start: function () {
                function t() {
                    e._running && (n(t), e._update())
                }

                var e = this;
                this._running = !0, this._time = (new Date).getTime(), n(t)
            }, stop: function () {
                this._running = !1
            }, clear: function () {
                this._clips = []
            }, animate: function (t, e) {
                e = e || {};
                var i = new o(t, e.loop, e.getter, e.setter);
                return i
            }
        }, e.mixin(s, i), s
    }),e("zrender/Painter", [U, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./Layer", "./graphic/Image"], function (t) {
        function e(t) {
            return parseInt(t, 10)
        }

        function i(t) {
            return t ? t.isBuildin ? !0 : typeof t[G] !== b || typeof t.refresh !== b ? !1 : !0 : !1
        }

        function n(t) {
            t.__unusedCount++
        }

        function r(t) {
            t.__dirty = !1, 1 == t.__unusedCount && t.clear()
        }

        function a(t, e, i) {
            return m.copy(t[y]()), t[Z] && m[u](t[Z]), x.width = e, x[B] = i, !m.intersect(x)
        }

        function s(t, e) {
            if (!t || !e || t[P] !== e[P])return !0;
            for (var i = 0; i < t[P]; i++)if (t[i] !== e[i])return !0
        }

        function l(t, e) {
            for (var i = 0; i < t[P]; i++) {
                var n, r = t[i];
                r[Z] && (n = r[Z], e[Z](n[0], n[1], n[2], n[3], n[4], n[5]));
                var a = r.path;
                a.beginPath(e), r.buildPath(a, r.shape), e.clip(), r[Z] && (n = r.invTransform, e[Z](n[0], n[1], n[2], n[3], n[4], n[5]))
            }
        }

        var c = t("./config"), h = t("./core/util"), d = t("./core/log"), f = t("./core/BoundingRect"), g = t("./Layer"), m = new f(0, 0, 0, 0), x = new f(0, 0, 0, 0), _ = function (t, e, i) {
            var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            i = i || {}, this.dpr = i.devicePixelRatio || c.devicePixelRatio, this._singleCanvas = n, this.root = t;
            var r = t.style;
            if (r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e, n) {
                var a = t.width, s = t[B];
                this._width = a, this._height = s;
                var l = new g(t, this, 1);
                l.initContext(), this._layers = {0: l}, this._zlevelList = [0]
            } else {
                var a = this._getWidth(), s = this._getHeight();
                this._width = a, this._height = s;
                var u = document[o]("div");
                this._domRoot = u;
                var h = u.style;
                h[v] = "relative", h.overflow = "hidden", h.width = this._width + "px", h[B] = this._height + "px", t.appendChild(u), this._layers = {}, this._zlevelList = []
            }
            this._layerConfig = {}, this.pathToImage = this._createPathToImage()
        };
        return _[H] = {
            constructor: _, isSingleCanvas: function () {
                return this._singleCanvas
            }, getViewportRoot: function () {
                return this._singleCanvas ? this._layers[0].dom : this._domRoot
            }, refresh: function (t) {
                var e = this.storage.getDisplayList(!0), i = this._zlevelList;
                this._paintList(e, t);
                for (var n = 0; n < i[P]; n++) {
                    var r = i[n], a = this._layers[r];
                    !a.isBuildin && a.refresh && a.refresh()
                }
                return this
            }, _paintList: function (t, e) {
                null == e && (e = !1), this._updateLayerStatus(t);
                var i, o, c, u = this._width, h = this._height;
                this.eachBuildinLayer(n);
                for (var f = null, v = 0, g = t[P]; g > v; v++) {
                    var m = t[v], y = this._singleCanvas ? 0 : m.zlevel;
                    if (o !== y && (o = y, i = this.getLayer(o), i.isBuildin || d("ZLevel " + o + " has been used by unkown layer " + i.id), c = i.ctx, i.__unusedCount = 0, (i.__dirty || e) && i.clear()), (i.__dirty || e) && !m.invisible && 0 !== m.style[p] && m.scale[0] && m.scale[1] && (!m.culling || !a(m, u, h))) {
                        var x = m.__clipPaths;
                        s(x, f) && (f && c.restore(), x && (c.save(), l(x, c)), f = x), m.beforeBrush && m.beforeBrush(c), m.brush(c, !1), m.afterBrush && m.afterBrush(c)
                    }
                    m.__dirty = !1
                }
                f && c.restore(), this.eachBuildinLayer(r)
            }, getLayer: function (t) {
                if (this._singleCanvas)return this._layers[0];
                var e = this._layers[t];
                return e || (e = new g("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && h.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
            }, insertLayer: function (t, e) {
                var n = this._layers, r = this._zlevelList, a = r[P], o = null, s = -1, l = this._domRoot;
                if (n[t])return void d("ZLevel " + t + " has been used already");
                if (!i(e))return void d("Layer of zlevel " + t + " is not valid");
                if (a > 0 && t > r[0]) {
                    for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
                    o = n[r[s]]
                }
                if (r[A](s + 1, 0, t), o) {
                    var c = o.dom;
                    c.nextSibling ? l.insertBefore(e.dom, c.nextSibling) : l.appendChild(e.dom)
                } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
                n[t] = e
            }, eachLayer: function (t, e) {
                var i, n, r = this._zlevelList;
                for (n = 0; n < r[P]; n++)i = r[n], t.call(e, this._layers[i], i)
            }, eachBuildinLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[P]; r++)n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
            }, eachOtherLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[P]; r++)n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
            }, getLayers: function () {
                return this._layers
            }, _updateLayerStatus: function (t) {
                var e = this._layers, i = {};
                this.eachBuildinLayer(function (t, e) {
                    i[e] = t.elCount, t.elCount = 0
                });
                for (var n = 0, r = t[P]; r > n; n++) {
                    var a = t[n], o = this._singleCanvas ? 0 : a.zlevel, s = e[o];
                    if (s) {
                        if (s.elCount++, s.__dirty)continue;
                        s.__dirty = a.__dirty
                    }
                }
                this.eachBuildinLayer(function (t, e) {
                    i[e] !== t.elCount && (t.__dirty = !0)
                })
            }, clear: function () {
                return this.eachBuildinLayer(this._clearLayer), this
            }, _clearLayer: function (t) {
                t.clear()
            }, configLayer: function (t, e) {
                if (e) {
                    var i = this._layerConfig;
                    i[t] ? h.merge(i[t], e, !0) : i[t] = e;
                    var n = this._layers[t];
                    n && h.merge(n, i[t], !0)
                }
            }, delLayer: function (t) {
                var e = this._layers, i = this._zlevelList, n = e[t];
                n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i[A](h[w](i, t), 1))
            }, resize: function (t, e) {
                var i = this._domRoot;
                if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) {
                    i.style.width = t + "px", i.style[B] = e + "px";
                    for (var n in this._layers)this._layers[n][G](t, e);
                    this.refresh(!0)
                }
                return this._width = t, this._height = e, this
            }, clearLayer: function (t) {
                var e = this._layers[t];
                e && e.clear()
            }, dispose: function () {
                this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
            }, getRenderedCanvas: function (t) {
                if (t = t || {}, this._singleCanvas)return this._layers[0].dom;
                var e = new g("image", this, t.pixelRatio || this.dpr);
                e.initContext();
                var i = e.ctx;
                e.clearColor = t.backgroundColor, e.clear();
                for (var n = this.storage.getDisplayList(!0), r = 0; r < n[P]; r++) {
                    var a = n[r];
                    a.invisible || (a.beforeBrush && a.beforeBrush(i), a.brush(i, !1), a.afterBrush && a.afterBrush(i))
                }
                return e.dom
            }, getWidth: function () {
                return this._width
            }, getHeight: function () {
                return this._height
            }, _getWidth: function () {
                var t = this.root, i = document.defaultView.getComputedStyle(t);
                return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0
            }, _getHeight: function () {
                var t = this.root, i = document.defaultView.getComputedStyle(t);
                return (t.clientHeight || e(i[B]) || e(t.style[B])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0
            }, _pathToImage: function (e, i, n, r, a) {
                var s = document[o]("canvas"), l = s.getContext("2d");
                s.width = n * a, s[B] = r * a, l.clearRect(0, 0, n * a, r * a);
                var c = {position: i[v], rotation: i.rotation, scale: i.scale};
                i[v] = [0, 0, 0], i.rotation = 0, i.scale = [1, 1], i && i.brush(l);
                var u = t("./graphic/Image"), h = new u({id: e, style: {x: 0, y: 0, image: s}});
                return null != c[v] && (h[v] = i[v] = c[v]), null != c.rotation && (h.rotation = i.rotation = c.rotation), null != c.scale && (h.scale = i.scale = c.scale), h
            }, _createPathToImage: function () {
                var t = this;
                return function (e, i, n, r) {
                    return t._pathToImage(e, i, n, r, t.dpr)
                }
            }
        }, _
    }),e("zrender/mixin/Draggable", [U], function () {
        function t() {
            this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
        }

        return t[H] = {
            constructor: t, _dragStart: function (t) {
                var e = t[C];
                e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this._dispatchProxy(e, "dragstart", t.event))
            }, _drag: function (t) {
                var e = this._draggingTarget;
                if (e) {
                    var i = t.offsetX, n = t.offsetY, r = i - this._x, a = n - this._y;
                    this._x = i, this._y = n, e.drift(r, a, t), this._dispatchProxy(e, "drag", t.event);
                    var o = this.findHover(i, n, e), s = this._dropTarget;
                    this._dropTarget = o, e !== o && (s && o !== s && this._dispatchProxy(s, "dragleave", t.event), o && o !== s && this._dispatchProxy(o, "dragenter", t.event))
                }
            }, _dragEnd: function (t) {
                var e = this._draggingTarget;
                e && (e.dragging = !1), this._dispatchProxy(e, "dragend", t.event), this._dropTarget && this._dispatchProxy(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
            }
        }, t
    }),e("zrender/graphic/helper/smoothSpline", [U, "../../core/vector"], function (t) {
        function e(t, e, i, n, r, a, o) {
            var s = .5 * (i - t), l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }

        var i = t("../../core/vector");
        return function (t, n) {
            for (var r = t[P], a = [], o = 0, s = 1; r > s; s++)o += i.distance(t[s - 1], t[s]);
            var l = o / 2;
            l = r > l ? r : l;
            for (var s = 0; l > s; s++) {
                var c, u, h, d = s / (l - 1) * (n ? r : r - 1), f = Math.floor(d), p = d - f, v = t[f % r];
                n ? (c = t[(f - 1 + r) % r], u = t[(f + 1) % r], h = t[(f + 2) % r]) : (c = t[0 === f ? f : f - 1], u = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
                var g = p * p, m = p * g;
                a.push([e(c[0], v[0], u[0], h[0], p, g, m), e(c[1], v[1], u[1], h[1], p, g, m)])
            }
            return a
        }
    }),e("zrender/graphic/helper/smoothBezier", [U, "../../core/vector"], function (t) {
        var e = t("../../core/vector"), i = e.min, n = e.max, r = e.scale, a = e.distance, o = e.add;
        return function (t, s, l, c) {
            var u, h, d, f, p = [], v = [], g = [], m = [];
            if (c) {
                d = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
                for (var y = 0, x = t[P]; x > y; y++)i(d, d, t[y]), n(f, f, t[y]);
                i(d, d, c[0]), n(f, f, c[1])
            }
            for (var y = 0, x = t[P]; x > y; y++) {
                var _ = t[y];
                if (l)u = t[y ? y - 1 : x - 1], h = t[(y + 1) % x]; else {
                    if (0 === y || y === x - 1) {
                        p.push(e.clone(t[y]));
                        continue
                    }
                    u = t[y - 1], h = t[y + 1]
                }
                e.sub(v, h, u), r(v, v, s);
                var b = a(_, u), w = a(_, h), M = b + w;
                0 !== M && (b /= M, w /= M), r(g, v, -b), r(m, v, w);
                var T = o([], _, g), S = o([], _, m);
                c && (n(T, T, d), i(T, T, f), n(S, S, d), i(S, S, f)), p.push(T), p.push(S)
            }
            return l && p.push(p.shift()), p
        }
    }),e("zrender/core/event", [U, "../mixin/Eventful"], function (t) {
        function e(t) {
            return t.getBoundingClientRect ? t.getBoundingClientRect() : {left: 0, top: 0}
        }

        function i(t, i) {
            if (i = i || window.event, null != i.zrX)return i;
            var n = i.type, r = n && n[w]("touch") >= 0;
            if (r) {
                var a = "touchend" != n ? i.targetTouches[0] : i.changedTouches[0];
                if (a) {
                    var o = e(t);
                    i.zrX = a.clientX - o.left, i.zrY = a.clientY - o.top
                }
            } else {
                var s = e(t);
                i.zrX = i.clientX - s.left, i.zrY = i.clientY - s.top, i.zrDelta = i.wheelDelta ? i.wheelDelta / 120 : -(i.detail || 0) / 3
            }
            return i
        }

        function n(t, e, i) {
            s ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
        }

        function r(t, e, i) {
            s ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
        }

        var o = t("../mixin/Eventful"), s = typeof window !== a && !!window.addEventListener, l = s ? function (t) {
            t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
        } : function (t) {
            t.returnValue = !1, t.cancelBubble = !0
        };
        return {normalizeEvent: i, addEventListener: n, removeEventListener: r, stop: l, Dispatcher: o}
    }),e("zrender/core/GestureMgr", [U], function () {
        function t(t) {
            var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1];
            return Math.sqrt(e * e + i * i)
        }

        function e(t) {
            return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
        }

        var i = function () {
            this._track = []
        };
        i[H] = {
            constructor: i, recognize: function (t, e) {
                return this._doTrack(t, e), this._recognize(t)
            }, clear: function () {
                return this._track[P] = 0, this
            }, _doTrack: function (t, e) {
                var i = t.touches;
                if (i) {
                    for (var n = {points: [], touches: [], target: e, event: t}, r = 0, a = i[P]; a > r; r++) {
                        var o = i[r];
                        n.points.push([o.clientX, o.clientY]), n.touches.push(o)
                    }
                    this._track.push(n)
                }
            }, _recognize: function (t) {
                for (var e in n)if (n.hasOwnProperty(e)) {
                    var i = n[e](this._track, t);
                    if (i)return i
                }
            }
        };
        var n = {
            pinch: function (i, n) {
                var r = i[P];
                if (r) {
                    var a = (i[r - 1] || {}).points, o = (i[r - 2] || {}).points || a;
                    if (o && o[P] > 1 && a && a[P] > 1) {
                        var s = t(a) / t(o);
                        !isFinite(s) && (s = 1), n.pinchScale = s;
                        var l = e(a);
                        return n.pinchX = l[0], n.pinchY = l[1], {type: "pinch", target: i[0][C], event: n}
                    }
                }
            }
        };
        return i
    }),e("echarts/chart/helper/createListFromArray", [U, "../../data/List", "../../data/helper/completeDimensions", j, "../../util/model", "../../CoordinateSystem"], function (t) {
        function e(t) {
            for (var e = 0; e < t[P] && null == t[e];)e++;
            return t[e]
        }

        function r(t) {
            var i = e(t);
            return null != i && !d[M](v(i))
        }

        function a(t, e, n) {
            if (t = t || [], !d[M](t))throw new Error("Invalid data.");
            var a = e.get("coordinateSystem"), o = m[a], s = p.get(a), f = o && o(t, e, n), y = f && f.dimensions;
            y || (y = s && s.dimensions || ["x", "y"], y = u(y, t, y[h](["value"])));
            var x, _ = f && f.categoryAxisModel, b = y[0].type === i ? 0 : y[1].type === i ? 1 : -1, T = new c(y, e), S = l(f, t), C = _ && r(t) ? function (t, e, i, n) {
                return n === b ? i : g(v(t), y[n])
            } : function (t, e, i, n) {
                var r = v(t), a = g(r && r[n], y[n]);
                return b === n && typeof a === q && (x = x || _.getCategories(), a = d[w](x, a), 0 > a && !isNaN(a) && (a = +a)), a
            };
            return T.initData(t, S, C), T
        }

        function o(t) {
            return t !== n && "time" !== t
        }

        function s(t) {
            return t === n ? i : "time" === t ? "time" : "float"
        }

        function l(t, e) {
            var i = [];
            if (t && t.categoryAxisModel) {
                var n = t.categoryAxisModel.getCategories();
                if (n) {
                    var r = e[P];
                    if (d[M](e[0]) && e[0][P] > 1) {
                        i = [];
                        for (var a = 0; r > a; a++)i[a] = n[e[a][t.categoryIndex || 0]]
                    } else i = n.slice(0)
                }
            }
            return i
        }

        var c = t("../../data/List"), u = t("../../data/helper/completeDimensions"), d = t(j), f = t("../../util/model"), p = t("../../CoordinateSystem"), v = f.getDataItemValue, g = f.converDataValue, m = {
            cartesian2d: function (t, e, i) {
                var r = i.getComponent("xAxis", e.get("xAxisIndex")), a = i.getComponent("yAxis", e.get("yAxisIndex"));
                if (!r || !a)throw new Error("Axis option not found");
                var l = r.get("type"), c = a.get("type"), h = [{name: "x", type: s(l), stackable: o(l)}, {
                    name: "y",
                    type: s(c),
                    stackable: o(c)
                }], d = l === n;
                return u(h, t, ["x", "y", "z"]), {
                    dimensions: h,
                    categoryIndex: d ? 0 : 1,
                    categoryAxisModel: d ? r : c === n ? a : null
                }
            }, polar: function (t, e, i) {
                var r = e.get("polarIndex") || 0, a = function (t) {
                    return t.get("polarIndex") === r
                }, l = i.findComponents({
                    mainType: "angleAxis",
                    filter: a
                })[0], c = i.findComponents({mainType: "radiusAxis", filter: a})[0];
                if (!l || !c)throw new Error("Axis option not found");
                var h = c.get("type"), d = l.get("type"), f = [{
                    name: "radius",
                    type: s(h),
                    stackable: o(h)
                }, {name: "angle", type: s(d), stackable: o(d)}], p = d === n;
                return u(f, t, ["radius", "angle", "value"]), {
                    dimensions: f,
                    categoryIndex: p ? 1 : 0,
                    categoryAxisModel: p ? l : h === n ? c : null
                }
            }, geo: function (t) {
                return {dimensions: u([{name: "lng"}, {name: "lat"}], t, ["lng", "lat", "value"])}
            }
        };
        return a
    }),e("zrender/Layer", [U, "./core/util", "./config"], function (t) {
        function e() {
            return !1
        }

        function i(t, e, i, n) {
            var r = document[o](e), a = i[F](), s = i[N](), l = r.style;
            return l[v] = "absolute", l.left = 0, l.top = 0, l.width = a + "px", l[B] = s + "px", r.width = a * n, r[B] = s * n, r.setAttribute("data-zr-dom-id", t), r
        }

        var n = t("./core/util"), r = t("./config"), a = function (t, a, o) {
            var s;
            o = o || r.devicePixelRatio, typeof t === q ? s = i(t, "canvas", a, o) : n[I](t) && (s = t, t = s.id), this.id = t, this.dom = s;
            var l = s.style;
            l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o
        };
        return a[H] = {
            constructor: a, elCount: 0, __dirty: !0, initContext: function () {
                this.ctx = this.dom.getContext("2d");
                var t = this.dpr;
                1 != t && this.ctx.scale(t, t)
            }, createBackBuffer: function () {
                var t = this.dpr;
                this.domBack = i("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t)
            }, resize: function (t, e) {
                var i = this.dpr, n = this.dom, r = n.style, a = this.domBack;
                r.width = t + "px", r[B] = e + "px", n.width = t * i, n[B] = e * i, 1 != i && this.ctx.scale(i, i), a && (a.width = t * i, a[B] = e * i, 1 != i && this.ctxBack.scale(i, i))
            }, clear: function (t) {
                var e = this.dom, i = this.ctx, n = e.width, r = e[B], a = this.clearColor, o = this.motionBlur && !t, s = this.lastFrameAlpha, l = this.dpr;
                if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / l, r / l)), i.clearRect(0, 0, n / l, r / l), a && (i.save(), i.fillStyle = this.clearColor, i.fillRect(0, 0, n / l, r / l), i.restore()), o) {
                    var c = this.domBack;
                    i.save(), i.globalAlpha = s, i.drawImage(c, 0, 0, n / l, r / l), i.restore()
                }
            }
        }, a
    }),e("echarts/component/axis/AxisView", [U, j, "../../util/graphic", "./AxisBuilder", "../../echarts"], function (t) {
        function e(t, e) {
            function i(t) {
                var e = n.getAxis(t);
                return e.toGlobalCoord(e.dataToCoord(0))
            }

            var n = t.coordinateSystem, r = e.axis, a = {}, o = r[v], s = r.onZero ? "onZero" : o, l = r.dim, c = n.getRect(), u = [c.x, c.x + c.width, c.y, c.y + c[B]], h = {
                x: {
                    top: u[2],
                    bottom: u[3]
                }, y: {left: u[0], right: u[1]}
            };
            h.x.onZero = Math.max(Math.min(i("y"), h.x[E]), h.x.top), h.y.onZero = Math.max(Math.min(i("x"), h.y.right), h.y.left), a[v] = ["y" === l ? h.y[s] : u[0], "x" === l ? h.x[s] : u[3]];
            var d = {x: 0, y: 1};
            a.rotation = Math.PI / 2 * d[l];
            var f = {top: -1, bottom: 1, left: -1, right: 1};
            a.labelDirection = a.tickDirection = a.nameDirection = f[o], r.onZero && (a.labelOffset = h[l][o] - h[l].onZero), e[V]("axisTick").get("inside") && (a.tickDirection = -a.tickDirection), e[V]("axisLabel").get("inside") && (a.labelDirection = -a.labelDirection);
            var p = e[V]("axisLabel").get("rotate");
            return a.labelRotation = "top" === s ? -p : p, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a
        }

        var i = t(j), n = t("../../util/graphic"), r = t("./AxisBuilder"), a = r.ifIgnoreOnTick, o = r.getInterval, s = ["axisLine", "axisLabel", "axisTick", "axisName"], l = ["splitLine", "splitArea"], c = t("../../echarts").extendComponentView({
            type: "axis",
            render: function (t, n) {
                if (this.group.removeAll(), t.get("show")) {
                    var a = n.getComponent("grid", t.get("gridIndex")), o = e(a, t), c = new r(t, o);
                    i.each(s, c.add, c), this.group.add(c.getGroup()), i.each(l, function (e) {
                        t.get(e + ".show") && this["_" + e](t, a, o.labelInterval)
                    }, this)
                }
            },
            _splitLine: function (t, e, r) {
                var s = t.axis, l = t[V]("splitLine"), c = l[V]("lineStyle"), u = c.get("width"), h = c.get("color"), d = o(l, r);
                h = i[M](h) ? h : [h];
                for (var f = e.coordinateSystem.getRect(), p = s.isHorizontal(), v = [], g = 0, m = s.getTicksCoords(), y = [], x = [], _ = 0; _ < m[P]; _++)if (!a(s, _, d)) {
                    var b = s.toGlobalCoord(m[_]);
                    p ? (y[0] = b, y[1] = f.y, x[0] = b, x[1] = f.y + f[B]) : (y[0] = f.x, y[1] = b, x[0] = f.x + f.width, x[1] = b);
                    var w = g++ % h[P];
                    v[w] = v[w] || [], v[w].push(new n.Line(n.subPixelOptimizeLine({
                        shape: {
                            x1: y[0],
                            y1: y[1],
                            x2: x[0],
                            y2: x[1]
                        }, style: {lineWidth: u}, silent: !0
                    })))
                }
                for (var T = c.getLineStyle(), _ = 0; _ < v[P]; _++)this.group.add(n.mergePath(v[_], {
                    style: i[k]({stroke: h[_ % h[P]]}, T),
                    silent: !0
                }))
            },
            _splitArea: function (t, e, r) {
                var s = t.axis, l = t[V]("splitArea"), c = l[V]("areaStyle"), u = c.get("color"), h = e.coordinateSystem.getRect(), d = s.getTicksCoords(), f = s.toGlobalCoord(d[0]), p = s.toGlobalCoord(d[0]), v = [], g = 0, m = o(l, r);
                u = i[M](u) ? u : [u];
                for (var y = 1; y < d[P]; y++)if (!a(s, y, m)) {
                    var x, _, b, w, T = s.toGlobalCoord(d[y]);
                    s.isHorizontal() ? (x = f, _ = h.y, b = T - x, w = h[B]) : (x = h.x, _ = p, b = h.width, w = T - _);
                    var S = g++ % u[P];
                    v[S] = v[S] || [], v[S].push(new n.Rect({
                        shape: {x: x, y: _, width: b, height: w},
                        silent: !0
                    })), f = x + b, p = _ + w
                }
                for (var C = c.getAreaStyle(), y = 0; y < v[P]; y++)this.group.add(n.mergePath(v[y], {
                    style: i[k]({fill: u[y % u[P]]}, C),
                    silent: !0
                }))
            }
        });
        c[D]({type: "xAxis"}), c[D]({type: "yAxis"})
    }),e("echarts/data/List", [U, "../model/Model", "./DataDiffer", j, "../util/model"], function (t) {
        function e(t) {
            return f[M](t) || (t = [t]), t
        }

        function n(t, e) {
            var i = t.dimensions, n = new y(f.map(i, t.getDimensionInfo, t), t.hostModel);
            m(n, t);
            for (var r = n._storage = {}, a = t._storage, o = 0; o < i[P]; o++) {
                var s = i[o], l = a[s];
                r[s] = f[w](e, s) >= 0 ? new l.constructor(a[s][P]) : a[s]
            }
            return n
        }

        var r = a, o = typeof window === a ? global : window, s = typeof o.Float64Array === r ? Array : o.Float64Array, l = typeof o.Int32Array === r ? Array : o.Int32Array, c = {
            "float": s,
            "int": l,
            ordinal: Array,
            number: Array,
            time: Array
        }, u = t("../model/Model"), d = t("./DataDiffer"), f = t(j), p = t("../util/model"), v = f[I], g = ["stackedOn", "_nameList", "_idList", "_rawData"], m = function (t, e) {
            f.each(g[h](e.__wrappedMethods || []), function (i) {
                e.hasOwnProperty(i) && (t[i] = e[i])
            }), t.__wrappedMethods = e.__wrappedMethods
        }, y = function (t, e) {
            t = t || ["x", "y"];
            for (var i = {}, n = [], r = 0; r < t[P]; r++) {
                var a, o = {};
                typeof t[r] === q ? (a = t[r], o = {
                    name: a,
                    stackable: !1,
                    type: "number"
                }) : (o = t[r], a = o.name, o.type = o.type || "number"), n.push(a), i[a] = o
            }
            this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
        }, x = y[H];
        x.type = "list", x.getDimension = function (t) {
            return isNaN(t) || (t = this.dimensions[t] || t), t
        }, x.getDimensionInfo = function (t) {
            return f.clone(this._dimensionInfos[this.getDimension(t)])
        }, x.initData = function (t, e, i) {
            if (t = t || [], !f[M](t))throw new Error("Invalid data.");
            this._rawData = t;
            var n = this._storage = {}, r = this.indices = [], a = this.dimensions, o = t[P], s = this._dimensionInfos, l = [], u = {};
            e = e || [];
            for (var h = 0; h < a[P]; h++) {
                var d = s[a[h]], v = c[d.type];
                n[a[h]] = new v(o)
            }
            i = i || function (t, e, i, n) {
                var r = p.getDataItemValue(t);
                return p.converDataValue(f[M](r) ? r[n] : r, s[e])
            };
            for (var g = 0; g < t[P]; g++) {
                for (var m = t[g], y = 0; y < a[P]; y++) {
                    var x = a[y], _ = n[x];
                    _[g] = i(m, x, g, y)
                }
                r.push(g)
            }
            for (var h = 0; h < t[P]; h++) {
                var b = "";
                e[h] || (e[h] = t[h].name, b = t[h].id);
                var w = e[h] || "";
                !b && w && (u[w] = u[w] || 0, b = w, u[w] > 0 && (b += "__ec__" + u[w]), u[w]++), b && (l[h] = b)
            }
            this._nameList = e, this._idList = l
        }, x.count = function () {
            return this.indices[P]
        }, x.get = function (t, e, i) {
            var n = this._storage, r = this.indices[e];
            if (null == r)return 0 / 0;
            var a = n[t] && n[t][r];
            if (i) {
                var o = this._dimensionInfos[t];
                if (o && o.stackable)for (var s = this.stackedOn; s;) {
                    var l = s.get(t, e);
                    (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn
                }
            }
            return a
        }, x.getValues = function (t, e, i) {
            var n = [];
            f[M](t) || (i = e, e = t, t = this.dimensions);
            for (var r = 0, a = t[P]; a > r; r++)n.push(this.get(t[r], e, i));
            return n
        }, x.hasValue = function (t) {
            for (var e = this.dimensions, n = this._dimensionInfos, r = 0, a = e[P]; a > r; r++)if (n[e[r]].type !== i && isNaN(this.get(e[r], t)))return !1;
            return !0
        }, x.getDataExtent = function (t, e) {
            var i = this._storage[t], n = this.getDimensionInfo(t);
            e = n && n.stackable && e;
            var r, a = (this._extent || (this._extent = {}))[t + !!e];
            if (a)return a;
            if (i) {
                for (var o = 1 / 0, s = -1 / 0, l = 0, c = this.count(); c > l; l++)r = this.get(t, l, e), o > r && (o = r), r > s && (s = r);
                return this._extent[t + e] = [o, s]
            }
            return [1 / 0, -1 / 0]
        }, x.getSum = function (t, e) {
            var i = this._storage[t], n = 0;
            if (i)for (var r = 0, a = this.count(); a > r; r++) {
                var o = this.get(t, r, e);
                isNaN(o) || (n += o)
            }
            return n
        }, x[w] = function (t, e) {
            var i = this._storage, n = i[t], r = this.indices;
            if (n)for (var a = 0, o = r[P]; o > a; a++) {
                var s = r[a];
                if (n[s] === e)return a
            }
            return -1
        }, x.indexOfName = function (t) {
            for (var e = this.indices, i = this._nameList, n = 0, r = e[P]; r > n; n++) {
                var a = e[n];
                if (i[a] === t)return n
            }
            return -1
        }, x.indexOfNearest = function (t, e, i) {
            var n = this._storage, r = n[t];
            if (r) {
                for (var a = Number.MAX_VALUE, o = -1, s = 0, l = this.count(); l > s; s++) {
                    var c = e - this.get(t, s, i), u = Math.abs(c);
                    (a > u || u === a && c > 0) && (a = u, o = s)
                }
                return o
            }
            return -1
        }, x.getRawIndex = function (t) {
            var e = this.indices[t];
            return null == e ? -1 : e
        }, x.getRawDataItem = function (t) {
            return this._rawData[this.getRawIndex(t)]
        }, x.getName = function (t) {
            return this._nameList[this.indices[t]] || ""
        }, x.getId = function (t) {
            return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
        }, x.each = function (t, i, n, r) {
            typeof t === b && (r = n, n = i, i = t, t = []), t = f.map(e(t), this.getDimension, this);
            var a = [], o = t[P], s = this.indices;
            r = r || this;
            for (var l = 0; l < s[P]; l++)if (0 === o)i.call(r, l); else if (1 === o)i.call(r, this.get(t[0], l, n), l); else {
                for (var c = 0; o > c; c++)a[c] = this.get(t[c], l, n);
                a[c] = l, i.apply(r, a)
            }
        }, x.filterSelf = function (t, i, n, r) {
            typeof t === b && (r = n, n = i, i = t, t = []), t = f.map(e(t), this.getDimension, this);
            var a = [], o = [], s = t[P], l = this.indices;
            r = r || this;
            for (var c = 0; c < l[P]; c++) {
                var u;
                if (1 === s)u = i.call(r, this.get(t[0], c, n), c); else {
                    for (var h = 0; s > h; h++)o[h] = this.get(t[h], c, n);
                    o[h] = c, u = i.apply(r, o)
                }
                u && a.push(l[c])
            }
            return this.indices = a, this._extent = {}, this
        }, x.mapArray = function (t, e, i, n) {
            typeof t === b && (n = i, i = e, e = t, t = []);
            var r = [];
            return this.each(t, function () {
                r.push(e && e.apply(this, arguments))
            }, i, n), r
        }, x.map = function (t, i, r, a) {
            t = f.map(e(t), this.getDimension, this);
            var o = n(this, t), s = o.indices = this.indices, l = o._storage, c = [];
            return this.each(t, function () {
                var e = arguments[arguments[P] - 1], n = i && i.apply(this, arguments);
                if (null != n) {
                    "number" == typeof n && (c[0] = n, n = c);
                    for (var r = 0; r < n[P]; r++) {
                        var a = t[r], o = l[a], u = s[e];
                        o && (o[u] = n[r])
                    }
                }
            }, r, a), o
        }, x.downSample = function (t, e, i, r) {
            for (var a = n(this, [t]), o = this._storage, s = a._storage, l = this.indices, c = a.indices = [], u = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), v = 0; v < o[t][P]; v++)s[t][v] = o[t][v];
            for (var v = 0; p > v; v += d) {
                d > p - v && (d = p - v, u[P] = d);
                for (var g = 0; d > g; g++) {
                    var m = l[v + g];
                    u[g] = f[m], h[g] = m
                }
                var y = i(u), m = h[r(u, y) || 0];
                f[m] = y, c.push(m)
            }
            return a
        }, x.getItemModel = function (t) {
            var e = this.hostModel;
            return t = this.indices[t], new u(this._rawData[t], e, e && e.ecModel)
        }, x.diff = function (t) {
            var e = this._idList, i = t && t._idList;
            return new d(t ? t.indices : [], this.indices, function (t) {
                return i[t] || t + ""
            }, function (t) {
                return e[t] || t + ""
            })
        }, x.getVisual = function (t) {
            var e = this._visual;
            return e && e[t]
        }, x.setVisual = function (t, e) {
            if (v(t))for (var i in t)t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e
        }, x.setLayout = function (t, e) {
            if (v(t))for (var i in t)t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e
        }, x.getLayout = function (t) {
            return this._layout[t]
        }, x.getItemLayout = function (t) {
            return this._itemLayouts[t]
        }, x.setItemLayout = function (t, e, i) {
            this._itemLayouts[t] = i ? f[D](this._itemLayouts[t] || {}, e) : e
        }, x.clearItemLayouts = function () {
            this._itemLayouts[P] = 0
        }, x.getItemVisual = function (t, e, i) {
            var n = this._itemVisuals[t], r = n && n[e];
            return null != r || i ? r : this.getVisual(e)
        }, x.setItemVisual = function (t, e, i) {
            var n = this._itemVisuals[t] || {};
            if (this._itemVisuals[t] = n, v(e))for (var r in e)e.hasOwnProperty(r) && (n[r] = e[r]); else n[e] = i
        };
        var _ = function (t) {
            t[S] = this[S], t.dataIndex = this.dataIndex, t.dataType = this.dataType
        };
        return x.setItemGraphicEl = function (t, e) {
            var i = this.hostModel;
            e && (e.dataIndex = t, e.dataType = this.dataType, e[S] = i && i[S], "group" === e.type && e.traverse(_, e)), this._graphicEls[t] = e
        }, x.getItemGraphicEl = function (t) {
            return this._graphicEls[t]
        }, x.eachItemGraphicEl = function (t, e) {
            f.each(this._graphicEls, function (i, n) {
                i && t && t.call(e, i, n)
            })
        }, x.cloneShallow = function () {
            var t = f.map(this.dimensions, this.getDimensionInfo, this), e = new y(t, this.hostModel);
            return e._storage = this._storage, m(e, this), e.indices = this.indices.slice(), e
        }, x.wrapMethod = function (t, e) {
            var i = this[t];
            typeof i === b && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
                var t = i.apply(this, arguments);
                return e.apply(this, [t][h](f.slice(arguments)))
            })
        }, x.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], x.CHANGABLE_METHODS = ["filterSelf"], y
    }),e("echarts/data/helper/completeDimensions", [U, j], function (t) {
        function e(t, e, a, o) {
            if (!e)return t;
            var s = n(e[0]), l = r[M](s) && s[P] || 1;
            a = a || [], o = o || "extra";
            for (var c = 0; l > c; c++)if (!t[c]) {
                var u = a[c] || o + (c - a[P]);
                t[c] = i(e, c) ? {type: "ordinal", name: u} : u
            }
            return t
        }

        function i(t, e) {
            for (var i = 0, a = t[P]; a > i; i++) {
                var o = n(t[i]);
                if (!r[M](o))return !1;
                var o = o[e];
                if (null != o && isFinite(o))return !1;
                if (r.isString(o) && "-" !== o)return !0
            }
            return !1
        }

        function n(t) {
            return r[M](t) ? t : r[I](t) ? t.value : t
        }

        var r = t(j);
        return e
    }),e("echarts/preprocessor/helper/compatStyle", [U, j], function (t) {
        function e(t) {
            var e = t && t.itemStyle;
            e && i.each(n, function (n) {
                var r = e[s], a = e.emphasis;
                r && r[n] && (t[n] = t[n] || {}, t[n][s] ? i.merge(t[n][s], r[n]) : t[n][s] = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n].emphasis ? i.merge(t[n].emphasis, a[n]) : t[n].emphasis = a[n], a[n] = null)
            })
        }

        var i = t(j), n = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
        return function (t) {
            if (t) {
                e(t), e(t.markPoint), e(t.markLine);
                var n = t.data;
                if (n) {
                    for (var r = 0; r < n[P]; r++)e(n[r]);
                    var a = t.markPoint;
                    if (a && a.data)for (var o = a.data, r = 0; r < o[P]; r++)e(o[r]);
                    var s = t.markLine;
                    if (s && s.data)for (var l = s.data, r = 0; r < l[P]; r++)i[M](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
                }
            }
        }
    }),e("echarts/component/axis/AxisBuilder", [U, j, "../../util/graphic", "../../model/Model", "../../util/number"], function (t) {
        function e(t) {
            var e = {componentType: t.mainType};
            return e[t.mainType + "Index"] = t.componentIndex, e
        }

        function r(t, e, i) {
            var n, r, a = h(e - t.rotation);
            return f(a) ? (r = i > 0 ? "top" : E, n = g) : f(a - p) ? (r = i > 0 ? E : "top", n = g) : (r = m, n = a > 0 && p > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
                rotation: a,
                textAlign: n,
                verticalAlign: r
            }
        }

        function a(t, e, i) {
            var n, r, a = h(-t.rotation), o = i[0] > i[1], s = "start" === e && !o || "start" !== e && o;
            return f(a - p / 2) ? (r = s ? E : "top", n = g) : f(a - 1.5 * p) ? (r = s ? "top" : E, n = g) : (r = m, n = 1.5 * p > a && a > p / 2 ? s ? "left" : "right" : s ? "right" : "left"), {
                rotation: a,
                textAlign: n,
                verticalAlign: r
            }
        }

        var o = t(j), s = t("../../util/graphic"), l = t("../../model/Model"), c = t("../../util/number"), h = c.remRadian, f = c.isRadianAroundZero, p = Math.PI, w = function (t, e) {
            this.opt = e, this.axisModel = t, o[k](e, {
                labelOffset: 0,
                nameDirection: 1,
                tickDirection: 1,
                labelDirection: 1,
                silent: !0
            }), this.group = new s.Group({position: e[v].slice(), rotation: e.rotation})
        };
        w[H] = {
            constructor: w, hasBuilder: function (t) {
                return !!M[t]
            }, add: function (t) {
                M[t].call(this)
            }, getGroup: function () {
                return this.group
            }
        };
        var M = {
            axisLine: function () {
                var t = this.opt, e = this.axisModel;
                if (e.get("axisLine.show")) {
                    var i = this.axisModel.axis[d]();
                    this.group.add(new s.Line({
                        shape: {x1: i[0], y1: 0, x2: i[1], y2: 0},
                        style: o[D]({lineCap: "round"}, e[V]("axisLine.lineStyle").getLineStyle()),
                        strokeContainThreshold: t.strokeContainThreshold,
                        silent: !!t.axisLineSilent,
                        z2: 1
                    }))
                }
            }, axisTick: function () {
                var t = this.axisModel;
                if (t.get("axisTick.show")) {
                    for (var e = t.axis, i = t[V]("axisTick"), n = this.opt, r = i[V]("lineStyle"), a = i.get(P), o = S(i, n.labelInterval), l = e.getTicksCoords(), c = [], u = 0; u < l[P]; u++)if (!T(e, u, o)) {
                        var h = l[u];
                        c.push(new s.Line(s.subPixelOptimizeLine({
                            shape: {x1: h, y1: 0, x2: h, y2: n.tickDirection * a},
                            style: {lineWidth: r.get("width")},
                            silent: !0
                        })))
                    }
                    this.group.add(s.mergePath(c, {style: r.getLineStyle(), z2: 2, silent: !0}))
                }
            }, axisLabel: function () {
                function t(t, e) {
                    var i = t && t[y]().clone(), n = e && e[y]().clone();
                    return i && n ? (i[u](t.getLocalTransform()), n[u](e.getLocalTransform()), i.intersect(n)) : void 0
                }

                var i = this.axisModel;
                if (i.get("axisLabel.show")) {
                    var a = this.opt, o = i.axis, c = i[V]("axisLabel"), h = c[V](_), d = c.get("margin"), f = o.scale.getTicks(), v = i.getFormattedLabels(), g = a.labelRotation;
                    null == g && (g = c.get("rotate") || 0), g = g * p / 180;
                    for (var m = r(a, g, a.labelDirection), w = i.get("data"), M = [], S = i.get("silent"), C = 0; C < f[P]; C++)if (!T(o, C, a.labelInterval)) {
                        var z = h;
                        w && w[C] && w[C][_] && (z = new l(w[C][_], h, i.ecModel));
                        var A = z.getTextColor(), L = o.dataToCoord(f[C]), k = [L, a.labelOffset + a.labelDirection * d], D = o.scale.getLabel(f[C]), I = new s.Text({
                            style: {
                                text: v[C],
                                textAlign: z.get("align", !0) || m.textAlign,
                                textVerticalAlign: z.get("baseline", !0) || m.verticalAlign,
                                textFont: z[x](),
                                fill: typeof A === b ? A(D) : A
                            }, position: k, rotation: m.rotation, silent: S, z2: 10
                        });
                        I.eventData = e(i), I.eventData.targetType = "axisLabel", I.eventData.value = D, M.push(I), this.group.add(I)
                    }
                    if (o.type !== n) {
                        if (i.getMin ? i.getMin() : i.get("min")) {
                            var R = M[0], B = M[1];
                            t(R, B) && (R[O] = !0)
                        }
                        if (i.getMax ? i.getMax() : i.get("max")) {
                            var E = M[M[P] - 1], N = M[M[P] - 2];
                            t(N, E) && (E[O] = !0)
                        }
                    }
                }
            }, axisName: function () {
                var t = this.opt, i = this.axisModel, n = this.opt.axisName;
                if (null == n && (n = i.get("name")), n) {
                    var o, l = i.get("nameLocation"), c = t.nameDirection, u = i[V]("nameTextStyle"), h = i.get("nameGap") || 0, f = this.axisModel.axis[d](), p = f[0] > f[1] ? -1 : 1, v = ["start" === l ? f[0] - p * h : "end" === l ? f[1] + p * h : (f[0] + f[1]) / 2, l === m ? t.labelOffset + c * h : 0];
                    o = l === m ? r(t, t.rotation, c) : a(t, l, f);
                    var g = new s.Text({
                        style: {
                            text: n,
                            textFont: u[x](),
                            fill: u.getTextColor() || i.get("axisLine.lineStyle.color"),
                            textAlign: o.textAlign,
                            textVerticalAlign: o.verticalAlign
                        }, position: v, rotation: o.rotation, silent: i.get("silent"), z2: 1
                    });
                    g.eventData = e(i), g.eventData.targetType = "axisName", g.eventData.name = n, this.group.add(g)
                }
            }
        }, T = w.ifIgnoreOnTick = function (t, e, n) {
            var r, a = t.scale;
            return a.type === i && (typeof n === b ? (r = a.getTicks()[e], !n(r, a.getLabel(r))) : e % (n + 1))
        }, S = w.getInterval = function (t, e) {
            var i = t.get("interval");
            return (null == i || "auto" == i) && (i = e), i
        };
        return w
    }),e("echarts/data/DataDiffer", [U], function () {
        function t(t) {
            return t
        }

        function e(e, i, n, r) {
            this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t
        }

        function i(t, e, i) {
            for (var n = 0; n < t[P]; n++) {
                var r = i(t[n]), a = e[r];
                null == a ? e[r] = n : (a[P] || (e[r] = a = [a]), a.push(n))
            }
        }

        return e[H] = {
            constructor: e, add: function (t) {
                return this._add = t, this
            }, update: function (t) {
                return this._update = t, this
            }, remove: function (t) {
                return this._remove = t, this
            }, execute: function () {
                var t, e = this._old, n = this._new, r = this._oldKeyGetter, a = this._newKeyGetter, o = {}, s = {};
                for (i(e, o, r), i(n, s, a), t = 0; t < e[P]; t++) {
                    var l = r(e[t]), c = s[l];
                    if (null != c) {
                        var u = c[P];
                        u ? (1 === u && (s[l] = null), c = c.unshift()) : s[l] = null, this._update && this._update(c, t)
                    } else this._remove && this._remove(t)
                }
                for (var l in s)if (s.hasOwnProperty(l)) {
                    var c = s[l];
                    if (null == c)continue;
                    if (c[P])for (var t = 0, u = c[P]; u > t; t++)this._add && this._add(c[t]); else this._add && this._add(c)
                }
            }
        }, e
    }),e("echarts/util/symbol", [U, "./graphic", "zrender/core/BoundingRect"], function (t) {
        var e = t("./graphic"), i = t("zrender/core/BoundingRect"), n = e.extendShape({
            type: "triangle",
            shape: {cx: 0, cy: 0, width: 0, height: 0},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = e.width / 2, a = e[B] / 2;
                t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath()
            }
        }), r = e.extendShape({
            type: "diamond", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = e.width / 2, a = e[B] / 2;
                t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath()
            }
        }), a = e.extendShape({
            type: "pin", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e.x, n = e.y, r = e.width / 5 * 3, a = Math.max(r, e[B]), o = r / 2, s = o * o / (a - o), l = n - a + o + s, c = Math.asin(s / o), u = Math.cos(c) * o, h = Math.sin(c), d = Math.cos(c);
                t.arc(i, l, o, Math.PI - c, 2 * Math.PI + c);
                var f = .6 * o, p = .7 * o;
                t.bezierCurveTo(i + u - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - u + h * f, l + s + d * f, i - u, l + s), t.closePath()
            }
        }), o = e.extendShape({
            type: "arrow", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var i = e[B], n = e.width, r = e.x, a = e.y, o = n / 3 * 2;
                t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath()
            }
        }), s = {
            line: e.Line,
            rect: e.Rect,
            roundRect: e.Rect,
            square: e.Rect,
            circle: e.Circle,
            diamond: r,
            pin: a,
            arrow: o,
            triangle: n
        }, c = {
            line: function (t, e, i, n, r) {
                r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
            }, rect: function (t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r[B] = n
            }, roundRect: function (t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r[B] = n, r.r = Math.min(i, n) / 4
            }, square: function (t, e, i, n, r) {
                var a = Math.min(i, n);
                r.x = t, r.y = e, r.width = a, r[B] = a
            }, circle: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
            }, diamond: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[B] = n
            }, pin: function (t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[B] = n
            }, arrow: function (t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[B] = n
            }, triangle: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[B] = n
            }
        }, u = {};
        for (var h in s)u[h] = new s[h];
        var d = e.extendShape({
            type: "symbol",
            shape: {symbolType: "", x: 0, y: 0, width: 0, height: 0},
            beforeBrush: function () {
                var t = this.style, e = this.shape;
                "pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = g, t.textVerticalAlign = m)
            },
            buildPath: function (t, e) {
                var i = e.symbolType, n = u[i];
                "none" !== e.symbolType && (n || (i = "rect", n = u[i]), c[i](e.x, e.y, e.width, e[B], n.shape), n.buildPath(t, n.shape))
            }
        }), f = function (t) {
            if ("image" !== this.type) {
                var e = this.style, i = this.shape;
                i && "line" === i.symbolType ? e[l] = t : this.__isEmptyBrush ? (e[l] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[l] && (e[l] = t)), this.dirty()
            }
        }, p = {
            createSymbol: function (t, n, r, a, o, s) {
                var l = 0 === t[w]("empty");
                l && (t = t.substr(5, 1)[W]() + t.substr(6));
                var c;
                return c = 0 === t[w]("image://") ? new e.Image({
                    style: {
                        image: t.slice(8),
                        x: n,
                        y: r,
                        width: a,
                        height: o
                    }
                }) : 0 === t[w]("path://") ? e.makePath(t.slice(7), {}, new i(n, r, a, o)) : new d({
                    shape: {
                        symbolType: t,
                        x: n,
                        y: r,
                        width: a,
                        height: o
                    }
                }), c.__isEmptyBrush = l, c.setColor = f, c.setColor(s), c
            }
        };
        return p
    }),e("echarts/component/tooltip/TooltipContent", [U, j, "zrender/tool/color", "zrender/core/event", "../../util/format", "zrender/core/env"], function (t) {
        function e(t) {
            var e = "cubic-bezier(0.23, 1, 0.32, 1)", i = "left " + t + "s " + e + ",top " + t + "s " + e;
            return s.map(p, function (t) {
                return t + "transition:" + i
            }).join(";")
        }

        function i(t) {
            var e = [], i = t.get("fontSize"), n = t.getTextColor();
            return n && e.push("color:" + n), e.push("font:" + t[x]()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), h(["decoration", "align"], function (i) {
                var n = t.get(i);
                n && e.push("text-" + i + ":" + n)
            }), e.join(";")
        }

        function n(t) {
            t = t;
            var n = [], r = t.get("transitionDuration"), a = t.get("backgroundColor"), o = t[V](_), s = t.get("padding");
            return r && n.push(e(r)), a && (f.canvasSupported ? n.push("background-Color:" + a) : (n.push("background-Color:#" + l.toHex(a)), n.push("filter:alpha(opacity=70)"))), h(["width", "color", "radius"], function (e) {
                var i = "border-" + e, r = d(i), a = t.get(r);
                null != a && n.push(i + ":" + a + ("color" === e ? "" : "px"))
            }), n.push(i(o)), null != s && n.push("padding:" + u.normalizeCssArray(s).join("px ") + "px"), n.join(";") + ";"
        }

        function r(t, e) {
            var i = document[o]("div"), n = e.getZr();
            this.el = i, this._x = e[F]() / 2, this._y = e[N]() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
            var r = this;
            i.onmouseenter = function () {
                r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
            }, i.onmousemove = function (e) {
                if (!r.enterable) {
                    var i = n.handler;
                    c.normalizeEvent(t, e), i.dispatch("mousemove", e)
                }
            }, i.onmouseleave = function () {
                r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
            }, a(i, t)
        }

        function a(t, e) {
            function i(t) {
                n(t[C]) && t.preventDefault()
            }

            function n(i) {
                for (; i && i !== e;) {
                    if (i === t)return !0;
                    i = i.parentNode
                }
            }

            c.addEventListener(e, "touchstart", i), c.addEventListener(e, "touchmove", i), c.addEventListener(e, "touchend", i)
        }

        var s = t(j), l = t("zrender/tool/color"), c = t("zrender/core/event"), u = t("../../util/format"), h = s.each, d = u.toCamelCase, f = t("zrender/core/env"), p = ["", "-webkit-", "-moz-", "-o-"], g = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
        return r[H] = {
            constructor: r, enterable: !0, update: function () {
                var t = this._container, e = t.currentStyle || document.defaultView.getComputedStyle(t), i = t.style;
                "absolute" !== i[v] && "absolute" !== e[v] && (i[v] = "relative")
            }, show: function (t) {
                clearTimeout(this._hideTimeout), this.el.style.cssText = g + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), this._show = !0
            }, setContent: function (t) {
                var e = this.el;
                e.innerHTML = t, e.style.display = t ? "block" : "none"
            }, moveTo: function (t, e) {
                var i = this.el.style;
                i.left = t + "px", i.top = e + "px", this._x = t, this._y = e
            }, hide: function () {
                this.el.style.display = "none", this._show = !1
            }, hideLater: function (t) {
                !this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(s.bind(this.hide, this), t)) : this.hide())
            }, isShow: function () {
                return this._show
            }
        }, r
    }),e("echarts/component/helper/listComponent", [U, "../../util/layout", "../../util/format", "../../util/graphic"], function (t) {
        function e(t, e, n) {
            i.positionGroup(t, e.getBoxLayoutParams(), {width: n[F](), height: n[N]()}, e.get("padding"))
        }

        var i = t("../../util/layout"), n = t("../../util/format"), r = t("../../util/graphic");
        return {
            layout: function (t, n, r) {
                var a = i.getLayoutRect(n.getBoxLayoutParams(), {width: r[F](), height: r[N]()}, n.get("padding"));
                i.box(n.get("orient"), t, n.get("itemGap"), a.width, a[B]), e(t, n, r)
            }, addBackground: function (t, e) {
                var i = n.normalizeCssArray(e.get("padding")), a = t[y](), o = e.getItemStyle(["color", p]);
                o.fill = e.get("backgroundColor");
                var s = new r.Rect({
                    shape: {
                        x: a.x - i[3],
                        y: a.y - i[0],
                        width: a.width + i[1] + i[3],
                        height: a[B] + i[0] + i[2]
                    }, style: o, silent: !0, z2: -1
                });
                r.subPixelOptimizeRect(s), t.add(s)
            }
        }
    }),e("echarts/chart/bar/barItemStyle", [U, "../../model/mixin/makeStyleMapper"], function (t) {
        return {getBarItemStyle: t("../../model/mixin/makeStyleMapper")([["fill", "color"], [l, "borderColor"], [c, "borderWidth"], [l, "barBorderColor"], [c, "barBorderWidth"], [p], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])}
    }),e("zrender", ["zrender/zrender"], function (t) {
        return t
    }),e("echarts", ["echarts/echarts"], function (t) {
        return t
    });
    var Y = t("echarts");
    return Y.graphic = t("echarts/util/graphic"), Y.number = t("echarts/util/number"), Y.format = t("echarts/util/format"), t("echarts/chart/bar"), t("echarts/component/grid"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/tooltip"), t("zrender/vml/vml"), Y
});